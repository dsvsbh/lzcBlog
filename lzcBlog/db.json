{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/background.png","path":"img/background.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/head-pic.png","path":"img/head-pic.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/15-三数之和.md","hash":"241eff88eb032c8352d6cc1b513f9d692c291bd0","modified":1736429371758},{"_id":"source/_posts/42-接雨水.md","hash":"84c2ea87badede1a263afde6a7ed9f09a86d19b2","modified":1737038449414},{"_id":"source/_posts/438-找到字符串中所有字母异位词.md","hash":"bda30d05e770d6bb50174991f02da5c0c0e6e16b","modified":1737129263535},{"_id":"source/_posts/AQS.md","hash":"4a61d73ac58346b44922d437631f629200b9e0e7","modified":1735050625145},{"_id":"source/_posts/ai语音合成项目中线程池优化ppt每一页任务执行.md","hash":"0e5e1a01f9f454c12f11f0708d2dbbd6df0613c5","modified":1737031287907},{"_id":"source/_posts/gradle构建java项目时乱码问题解决方案.md","hash":"0d0430f10333ed68cb93b40566fc1fba4bfeb0e1","modified":1735050389245},{"_id":"source/_posts/java中Atomic原子类型.md","hash":"abc8c8c9cab0c540553531a8022920e9def8581b","modified":1734162516139},{"_id":"source/_posts/java的bigdecimal是怎么解决精度丢失的.md","hash":"a29a81db85acad01c1a0d86c675d80c290012d39","modified":1736837453466},{"_id":"source/_posts/leetcode第31题解.md","hash":"bbc7301420ca92794d9cca18c50082ed3437d17f","modified":1734163773135},{"_id":"source/_posts/54-螺旋矩阵.md","hash":"439be54ea0d5ce05ae367e7389f45c0d3959ad01","modified":1737733638146},{"_id":"source/_posts/localCache实现expire过期原理.md","hash":"8c390627779c78e5e94d3e5c408e2dc3ba8ebefd","modified":1734410372926},{"_id":"source/_posts/localCache持久化和加载的实现.md","hash":"ed29aa1ca6b009ef8a4a7d0404b759045891831e","modified":1734859239240},{"_id":"source/_posts/java中的代理.md","hash":"102586c833b5902bc022a4bf62a8e25c7c0f37fd","modified":1734162614235},{"_id":"source/_posts/mysql列的联合索引什么时候生效.md","hash":"22a412f6273063f13a034b651dda42569a8e0852","modified":1736852815925},{"_id":"source/_posts/mysql数据库索引分类及其底层数据结构.md","hash":"e66a6660305bcd2fbef9ff10f0d7cd8e3c1a7b92","modified":1734162705874},{"_id":"source/_posts/redisson的分布式锁实现.md","hash":"acdf2033a5158911542e9fa0be9f0ac25606999f","modified":1736842154093},{"_id":"source/_posts/redis淘汰策略.md","hash":"1a4c60742d732920c1204ed684c6eac142f572a3","modified":1734167660682},{"_id":"source/_posts/localCache本地缓存项目实现固定大小缓存.md","hash":"f0fbe759bd8283605c09dabaf05b98a7fcf7b879","modified":1734275683084},{"_id":"source/_posts/redo-log和undo-log.md","hash":"a723c907866990e382e89b45dd7f205e6424f00c","modified":1734167684312},{"_id":"source/_posts/两个线程轮流打印0-100.md","hash":"9dd25822b35167ff4e51e80003cd62baf95c3e16","modified":1737286240034},{"_id":"source/_posts/实在智能实习经历收获.md","hash":"739fb15158a995a579af124e3aaecffef7be48c6","modified":1734167807121},{"_id":"source/_posts/反转链表.md","hash":"eeb15b2b3d41327fe2c806aa53acd30908a95131","modified":1736346779044},{"_id":"source/_posts/工厂-注册表模式设计nodeHandler.md","hash":"32ddfa6422a5293f6a83390ff76f91626ea17d4a","modified":1734167753521},{"_id":"source/_posts/删除链表的倒数第n个结点.md","hash":"4b42268da1315bc36d4aa31fa8f3dfbfaef01232","modified":1738577970163},{"_id":"source/_posts/力扣146-LRU缓存.md","hash":"2db5c1ff3a7b018a2136d4a2366c6ef014c3cdb4","modified":1735050256135},{"_id":"source/_posts/旋转图像.md","hash":"ac06e1eec2fa0cf5e88504f0acb0ba1382e778a7","modified":1738497852030},{"_id":"source/_posts/搜索二维矩阵.md","hash":"608fd3509d0300d5b58d09f6ceaf33f43dce5ce4","modified":1738498943672},{"_id":"source/_posts/最大子数组和.md","hash":"c4100831d2e2bb191efdaaa8ab34a30a782e1023","modified":1736178911750},{"_id":"source/_posts/杭州实在智能java实习面经.md","hash":"374bfad2eb65c3dfa67eab8969a7e18491dc4120","modified":1735050523793},{"_id":"source/_posts/普通线程池的执行流程.md","hash":"804ca26dbcc2f0988dcff2f8d0db741eadbd60f8","modified":1734167769195},{"_id":"source/_posts/面试题收集.md","hash":"73839831125b2dc8e22e6d6c12bd7cd81899712b","modified":1736841709231},{"_id":"source/_posts/盛最多水的容器.md","hash":"3c05f0097b0889786b0134cc937a97ccec0f9fb7","modified":1736246062352},{"_id":"source/_posts/用线程池执行批量耗时任务的优点.md","hash":"52c18bd7496099961eb9c9b3a1e64f927ac0164c","modified":1734167819572},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1733383146000},{"_id":"themes/butterfly/README.md","hash":"310bf423097f1cefb6121ce3f115b2ef68aacc44","modified":1733383146000},{"_id":"themes/butterfly/plugins.yml","hash":"a244af3b578de079666bd87c3055917220e63c25","modified":1733383146000},{"_id":"themes/butterfly/package.json","hash":"dc0b4447ce57e182169c634b0018e9b0bd3b5bdc","modified":1734159092018},{"_id":"themes/butterfly/package-lock.json","hash":"552f3a90ddf6282d0d0cce79a0893f93cc4dc98c","modified":1734159092018},{"_id":"themes/butterfly/_config.yml","hash":"e426545d6d2b515ff70e96a246e5cbd4e554b24e","modified":1734271454940},{"_id":"themes/butterfly/README_CN.md","hash":"6e79be6f188bd671eb6ef1084ea7dd757fa2b3e9","modified":1733383146000},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1733383146000},{"_id":"themes/butterfly/layout/category.pug","hash":"bf07d9624ac7285214c7f1d505da3a813c164c8c","modified":1733383146000},{"_id":"themes/butterfly/layout/index.pug","hash":"6aba5fd01aba75fd38ef2e2c1d406d951b8c5560","modified":1733383146000},{"_id":"themes/butterfly/layout/page.pug","hash":"a59b90dd3f845ef6bac18091c55e8e019f4fe7a3","modified":1733383146000},{"_id":"themes/butterfly/layout/tag.pug","hash":"98c0084a4c62415775ca9e261e3d4eeb7668f35b","modified":1733383146000},{"_id":"themes/butterfly/layout/post.pug","hash":"d000b6a16418c1d95d4ce49ff9346416bbb151d3","modified":1733383146000},{"_id":"themes/butterfly/layout/archive.pug","hash":"bb32c9c476372de747dfa563b83f77d7a917a77d","modified":1733383146000},{"_id":"themes/butterfly/languages/default.yml","hash":"f46a8e362641f7a7c432d68e3984e739d5fe6b44","modified":1733383146000},{"_id":"themes/butterfly/languages/ja.yml","hash":"c978fbf9421af4d96978161cef828ea88ae06037","modified":1733383146000},{"_id":"themes/butterfly/languages/ko.yml","hash":"ca8d31350e60b5849bb609a4d33f90d3dd8905a2","modified":1733383146000},{"_id":"themes/butterfly/languages/en.yml","hash":"f46a8e362641f7a7c432d68e3984e739d5fe6b44","modified":1733383146000},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"e91ac1a94e1fc84cd75bc6b0a8b7a62acfb2a516","modified":1733383146000},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"9fecee5467e9c5034515fea73f1901c3c67e8ef9","modified":1733383146000},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"c3e863ad5b5aa618873ad4370cf0335a9cc67b39","modified":1733383146000},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1733383146000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7b4831ae8f8f8c55dd1b856781210c517c63e6dd","modified":1733383146000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1733383146000},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1733383146000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"df07add8fca55a7a12173af53201d306000fd9e0","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"78cd51877c72a66de13ad88af6687627d4743b03","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"cd2e0141d7bbd2bd348703ead52c8060904ab338","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"82548510310fb44587371fcc9afd7f0bbdb673b1","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"eb31f49a826c1f95890078745e55c9a2ccb319f9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"7d3581a446285b0cd9362266d54b59fe8768af9e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"345cb07213cdf66cfef7d9699c60f5f3297e9585","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"d4f3a798cdded0c0744efab3b1397b00cdb0c6e5","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/404.js","hash":"a196e0d2eb40d1643bcf53a467ad37104f877ca5","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"0e59424100fc3138b9096b38a0a2384a6411f8d9","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"072f042e069e7a0523fa439569c0c672f389b5c4","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"1ac9527c510ca757724f15dec84b0ead032411b2","modified":1733383146000},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"b69c137c06791db58e347474b88803e112d100dd","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1733383146000},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"860f967ecf3c6a6ea785b560a7aae4d0757cd18a","modified":1733383146000},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a8eef3f37428436554f58a2b6bac7c255fbdf38d","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"24a88d138ccabf29698a6cfe399b2e10f126367f","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7397db8012c27a4a1da75dd659745676654a0c65","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"5edf400514843e28b329c3fd3f12f66ed5faca66","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"39325366b622cfd2089cb1c9344d89f2edd79816","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"1b37a484cbcc81f51953ea093644b70499c26314","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"9c2ee5868879529f7cef7d93edca5b755f45e7e9","modified":1733383146000},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"806e2e5843df23e7eb94709056676f5ce6bfefa7","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"132d1e7757d0dac42d6b0957a25484613d7ed873","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"555f7e4a2a7d8c4420ca467e87625bf96db11a70","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"a26402edc63cbe8faa6a99647f039ffd9616e1f6","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"365db87ddfc582bf8c15cb440c48bed95106e4b1","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"e0abf9f0ec51a78258bbf0101632e7dd2c54db25","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"1acefc59ead75ebd8cafee36efc7da4fa426d088","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"512c68a22ae4a58d6a6b24b368a0c00c2ccb4fcb","modified":1733383146000},{"_id":"themes/butterfly/source/css/var.styl","hash":"8cc7b245da61e35cfcc80cafb4e553b5fa968111","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"5c2a07df5874b5377540884e4da14dd21489378f","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"22bc3a24c3610b5a3c3a2043b7d10e26d00018b8","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"f4507d1527cc0d5fe9fdd89eb769e15814a18fec","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"5cb273e95846874e3a58074074c501df23c5e912","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3a9a28f6833e9cea60761e52ab8990fcb597444f","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"67c1aad5ddfe56deae672146c2774379aa65af95","modified":1733383146000},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1733383146000},{"_id":"themes/butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1733383146000},{"_id":"themes/butterfly/source/img/head-pic.png","hash":"3f0bf78cf120b48293a5ba6652684fe748faeb1c","modified":1734164859846},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1733383146000},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1733383146000},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1733383146000},{"_id":"themes/butterfly/source/js/main.js","hash":"9fb88eb196f9368768aaa554c679129e4969f069","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"2beb68bdd43b09a539c8f4ed0cb7c0838c03409a","modified":1733383146000},{"_id":"themes/butterfly/source/js/utils.js","hash":"fd3c26366c78dd82bc87d4ddebe76c582122e1b7","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"e5a26d2e2ca789dffc6bd9cfc13ff9e530c9911c","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"c681697eac3657c2c3e921c2774d67bb93d47331","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"fbe602e22ee4a60d711485ad925dfe06b92a4c76","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"5208fe1e75d97a05fd9bdd6cc53c59d8b741b94b","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"0e301fe266b3260257b5a619dc8eedf2c1955e7e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"cd507e58852dc59a72e624fc1b22dc9b138c2575","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"95316827e12ec1a2cee18b7d5f49971e9a88b138","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"605809f97b2f0da0e2e84dd2365fc8ccee1de6bd","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"b7608dca3d361001d661779fe8be03c370231c41","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"10aa44e0216dbde863e2bd41267b613dc220e517","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"8b12fa52bd522dded8b7f1ae3f580f339d75aecf","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"77eca4f5dbf38c2c805b732ff8d7d9c1560b6f16","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"55090eee8076af761be7741b4e330ceea07c27d7","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"38b85f46c8e1bcbc43d2a4875d94ea201518eeeb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"ca9cc03a51561413728d7211f0a544654c5d4e36","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"f4f590102c1937d63da5edf35f2ff37f5932ccc1","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"4912beecdef7af33f0704ef4d6605e1ac69fbb11","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"7e7cd9dfd832c8f3e829ad445eccf5cb5dc8ff18","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/post/outdate-notice.pug","hash":"1661f8a53334789099efffa92246158cb3d933b3","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"a6c3a4a608f540d05105a7ae19e2f5719c2a3f71","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"2dca79799c566ffa68b21ecefa9c63432b5088e1","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"38c0781ac7544d2010d5bfe7ae521125f3672975","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"1d39670ee6225f85f5c53bf5c84f3fd6e19290e8","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"0595d60dbf701e2ffa92181923861b1457a02112","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"5c7605a0353ef2709f75bad27794f985c7c78907","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"2bef558fa87986805b3397319b4c088564ba7c44","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"512111475060798925eb1a7bc7617c34b8bd32ab","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0c1affa498b28e79e5a465f3f8f18035993bcb88","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"21d42f43f26a2075abf2e6d13d35fb1aaf53a8b4","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"e2fa3804c0fef70bb6fa884f1055c978725ccef2","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"4ae59a48f8984ce8316cfc82756180dc496774eb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"ba95646b78688bcdcf77166407c4799e5e3c3e6d","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"bd5ad01277f8c6ddf8a3a29af1518e5fe6eed23f","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"66f7a8b0cebc05c575ec3cb70b08d6854029d87a","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"a658a274c5f7896ee5122725bee45548693bdd66","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"5da5f11a0f7f0fc06732df412bb77a7dddc41429","modified":1733383146000},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"15f321aee7876f2366677914a7cd2ab8b071b162","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"79e95511d8d51e8944092b9596994d9779c1f4e4","modified":1733383146000},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"506bbff9c954d5f92a6d97145be2d732571fae39","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"4765d72ab300910437d64991d3f70a82b41d4e3a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"e2761a2515b34d2d41dea00551abc44d4ce72aeb","modified":1733383146000},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"11a0fde4e784b0af5bb813c9e9ca9e480e5db99a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"134811b2d696f9ed2c0cd578f3886f1c60770c0a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"1a864887fb1bc9d24caa6b8b63a9bfc251762ffd","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3312e3bc1076ac8ba9dd902a671602c78a5e1479","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dbd4af28bbf2fe9a7d75a75fdf460dfb3317311a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"4382ecffdb778de9fa05edf24765b68ae6da1220","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"517361bf999e41fdea2c57e0af6e82d310f76edd","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"316447b94933af2cc580cc9c2b8b42e3875b8c08","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"0ba6e4f5252d1a95e9dfa20b4a17207b6713947d","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"743f9dd5585ecac812f3aa908eede4093d84fbd7","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"0d0ef8a9260b494e50ef545e5f395d649418f0a9","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"be7ee2c63cedbc6b7f03cb3993ec533d9ae9d8bb","modified":1733383146000},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"44d6b9fa9f0cb9026722f7dda15368d41d3fed20","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"a96513acd7f51ffa01531ef3a24fdf5391ae93ae","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"354902d03f13068cf8a3617fb0ea92669e6b2a86","modified":1733383146000},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e2046eed9503ac506d5ca120b60203dd2cd968af","modified":1733383146000},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"1ce084ed240d0e998bcdf1416ada598637878398","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c08432ecceaa187005c55144cf6f2b092ca50820","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"8aa755a3f588e6e598e4fb6510faa6e766d59a94","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"643ff8c79d033947da312b70847b1b45850d7b29","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"b02e88bb5dafcef11be4669da6cd9cddbf9a852a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"3fa5aa012c62da3b5220654426c0708cab24e9af","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"855af8f97daad51b0161d96d50abd71edec87142","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"e765323537d174c7dcb88614100ccdc3e2d020e1","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"2c71b5bfb873d57eb6532144f66e86183dd0dcf6","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"5ded9ddc66777e93cc4f0e1e4349540c0249346d","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"4a651e47d658340443bb63b7d15a1e9e34f76aca","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"7e5ca6a899c66b26cebc027db530d54018e2c5c0","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"f7415acfee7adb5ba01fd278b1e16b636a6b20a1","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"909bb5079b26b6ee68177919f522566503654058","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"cf24d72ea16ef253a438efe95b9a0a8fdfbb6d01","modified":1733383146000},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"62d03f6c429c2de256a204399610a041cab23b04","modified":1733383146000},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"e76655e699154c3d39043c1a5bb8400dc1658399","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"cb77a73a2b47156d18afb9f2376b3d502d0d12d7","modified":1733383146000},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"71af0b679e00290b0854384368b3c7e9b3e5f26a","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"cabb3a06f8ef297a1ea3d91ced8abeaa0831aa14","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"c5f7081ca29db8cc80f808dfc29e36d5fa22fd7e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"a35c21e9ec2bef465c945408da515bfb5d848d6d","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"5715fc2dc75808af0a434fe66b81d0f651d03ed3","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"3a5ccfc69bd8ccb4b8f3ce3502023f7914f2a022","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"007bb96fd84f38852b7ab5f761e6867b6058422f","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2c6eb1b0b3586ce6a92228f809be37642a2010b0","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"8b21906b1b3f3faa19bdc16f4167b0b5d487c9ac","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"9ed621742714de6de6593490e3d4aaa3f30a4791","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"be40f20273c31e8b37353d9705ad9b9c693e16a2","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"5aaef147ae31e1ffc49152acd43dabc5f15b39ba","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"8f3d4c33ec3d1be4bd203ba2461db9ccfad63f23","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"dd5c7e808654aefeb3fcc81c7b0911cff1ee8776","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"f71d8acf5b0f3ece91ae1e018962c73b50941a45","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"a9709905593d960954e2dd572f09f48a6c2b1ef7","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"d040c00332e83c985dbc0e76e3242336edbcd764","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"830bafcf50180fed4fcf76f0da277d702e66a5b3","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"966ef931a9545cdde8c270322e8650b54b965935","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"6ddd9dce1a553a0d24509d7f9c78b9f6742be030","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"46c177643a8e65f036cb08c29387d4ab29485859","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"8869bac6ec822a70dfe432d7bd5e599750441ddb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"bfc6e6690e70c5bd646bdff354b750ebd782f4ad","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"bd87dc207f1cab66e48496548b18f0dd9021eb91","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"a3f409a0c1ed3df8c920f7d32b86c3832459f3bf","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"49aece5be2a0a8e414257ecbfc2abd7d0d5f8c64","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"5227663ccbe86c830447e4dcc594202b1582595d","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"1c2190c9bac26992de8d52be4f8522309d566750","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"7e3b4e1124c9917b820e96bd0c915c08da68aecd","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"2e82651607326e7f999fc7891480c74a06cbb416","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"eee2c6b5c73ea280c7b683a1d117cab5a2ea5f66","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"619c41729691a54871b49da54ea27657d1b58e7e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"86cf7ba9cae6eb8bee0ca792df7a82f58c8451ff","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"b82c936cb73c325fcac69832a3e475ed732e06f9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"8a7d5cdca6a87897d435fc88ebcb7ec0b7ec8591","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"393a327a7f41de070abd53cd95149d3e7e1bbf61","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"16796729df739a47508999b5467a57037ee6e9df","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"988f75833dcb18d4a02c34cdea51e39434ea5723","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"393c94702fd65c585e37bcf9a4f33c638d8bac72","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"18b492731f67d449bb32d7fac321deb57a92e75f","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"11a4e7decb634fbd6af454aa5ec230945837b6a9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"cc272f7d612a52f4f1d2a95456cc89bc709fe0e5","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"f11c6db285f57a475db638e74920efb2d0e5a4d0","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"fdcc5a88505fcbf0593aa04ecb4ac0c8ad4f8fa3","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"dcd3af96d8be1a6358a88daf2c66165cc9b792d9","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"1997713a8722391c8b5c8c1598ec19adee993fa5","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"ed77729c26cf815c75efd3a6889b6ac805471765","modified":1733383146000},{"_id":"themes/butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1733383146000},{"_id":"themes/butterfly/source/img/background.png","hash":"fad38e75bb760bd9794f7ea9d2583fb3dc4921a4","modified":1734164701664},{"_id":"public/categories/算法/index.html","hash":"29461e57db5f3101eba9af456298c9c593c3b103","modified":1738655685177},{"_id":"public/categories/算法/page/2/index.html","hash":"5a54e75cead78b14ac4d7ed0c20e11b65111afc4","modified":1738655685177},{"_id":"public/categories/八股文/index.html","hash":"3099389416623c04c21e56782fdf97686f76f926","modified":1738655685177},{"_id":"public/categories/业务场景/index.html","hash":"810c3c83839c4ec30dfad56310e8625ff55d18e3","modified":1738655685177},{"_id":"public/categories/面试/index.html","hash":"0fb188e35977dda05d1929dc1c3280d8bd6e2540","modified":1738655685177},{"_id":"public/categories/项目/index.html","hash":"4d971898bd432fecca95a510f3fde621825f6603","modified":1738655685177},{"_id":"public/categories/底层实现/index.html","hash":"8d45b0a98033b7caabbb38078da55ce972bec49b","modified":1738655685177},{"_id":"public/categories/实习业务/index.html","hash":"9614767743b01c0791361e5de6f7ed5052afe4f6","modified":1738655685177},{"_id":"public/categories/面经/index.html","hash":"5ffb91d910aec89561974225b1a08bfe7ec6b8dc","modified":1738655685177},{"_id":"public/categories/面试题/index.html","hash":"8017390fd36a863afde42589aabd2d81f415cd4b","modified":1738655685177},{"_id":"public/tags/leetcode/index.html","hash":"865d7742c2d8084c0bad0c584dff428f83d7c24a","modified":1738655685177},{"_id":"public/tags/leetcode/page/2/index.html","hash":"cb822857567137e5088bcd3070526675297bc734","modified":1738655685177},{"_id":"public/tags/juc/index.html","hash":"1b42b20c263b5c63afb07857eb2173d2e4d5e20d","modified":1738655685177},{"_id":"public/tags/线程池/index.html","hash":"b3921e490cab1d061bbc22b4d0dced0181f9f4e5","modified":1738655685177},{"_id":"public/tags/gradle/index.html","hash":"1dca93932fe2cece9ae6603a98b9c26b963ff49b","modified":1738655685177},{"_id":"public/tags/java基础/index.html","hash":"25dd524aed1093fde35282c91583d0b5d74eb44d","modified":1738655685177},{"_id":"public/tags/java/index.html","hash":"ac010f7a82efcc47c4e9937ed023242d82eb92a3","modified":1738655685177},{"_id":"public/tags/localCache/index.html","hash":"b8589e0e867677447a347a7063196935cbf58d42","modified":1738655685177},{"_id":"public/tags/mysql/index.html","hash":"046b478e5b08f41e284db72f642db83797b9b95a","modified":1738655685177},{"_id":"public/tags/redis/index.html","hash":"feec796ed66dafbc83142de974e5c968bc05d8df","modified":1738655685177},{"_id":"public/tags/算法/index.html","hash":"4bc25916339be7f3288ad6e13010f71d73485ae8","modified":1738655685177},{"_id":"public/tags/实习/index.html","hash":"143ee486b17ea596279d4134073e1d7393a1c0de","modified":1738655685177},{"_id":"public/tags/设计模式/index.html","hash":"8ff2d1f380ed5c5b59dec23776c396c559aecc76","modified":1738655685177},{"_id":"public/tags/实在智能/index.html","hash":"48572ccbc20152cd95c6ff1d48828d9999e2e66a","modified":1738655685177},{"_id":"public/tags/面试/index.html","hash":"c0976bc990f6cb1680cc0f24001a05303f77a80e","modified":1738655685177},{"_id":"public/2025/02/03/删除链表的倒数第n个结点/index.html","hash":"bc10e93954c11da1de472e11850597d949c5d592","modified":1738655685177},{"_id":"public/2025/02/02/搜索二维矩阵/index.html","hash":"8b14a876132dcca083dc9ff3ef77a2baeee38224","modified":1738655685177},{"_id":"public/2025/02/02/旋转图像/index.html","hash":"85de78359e3ba211a4829aa30cffa0a15a53bc19","modified":1738655685177},{"_id":"public/2025/01/24/54-螺旋矩阵/index.html","hash":"f9b4ab97c70e1323eb9145efc7c693a6f0a62634","modified":1738655685177},{"_id":"public/2025/01/19/两个线程轮流打印0-100/index.html","hash":"746102736107b03cf60ad0cc2cffe5f8b0ebcde4","modified":1738655685177},{"_id":"public/2025/01/17/438-找到字符串中所有字母异位词/index.html","hash":"8c3edd937366b06e270a31ce627ef2d51e529555","modified":1738655685177},{"_id":"public/2025/01/16/42-接雨水/index.html","hash":"2c36d3e1c7956b26c863ef2b8e249bdfd06e99a8","modified":1738655685177},{"_id":"public/2025/01/15/ai语音合成项目中线程池优化ppt每一页任务执行/index.html","hash":"555608322911d17ea85f00fbb06be8610152669f","modified":1738655685177},{"_id":"public/2025/01/14/mysql列的联合索引什么时候生效/index.html","hash":"eda667933eeed98e6912aee253f43d08b762a911","modified":1738655685177},{"_id":"public/2025/01/14/redisson的分布式锁实现/index.html","hash":"bebf8726cdbaae1f3323ce8743e3df3689ba4926","modified":1738655685177},{"_id":"public/2025/01/14/java的bigdecimal是怎么解决精度丢失的/index.html","hash":"b212b75d11b76f85485b34d16b0c247d1755a507","modified":1738655685177},{"_id":"public/2025/01/09/面试题收集/index.html","hash":"6d246c9866d40d3c70faa9eb3d72bfd5b7e9f0b8","modified":1738655685177},{"_id":"public/2025/01/09/15-三数之和/index.html","hash":"62dc3ec30ffab31478ccfd4753ecbaaa99039621","modified":1738655685177},{"_id":"public/2025/01/08/反转链表/index.html","hash":"64d83a2bed101d90616937dfe3983f303d14ccb3","modified":1738655685177},{"_id":"public/2025/01/07/盛最多水的容器/index.html","hash":"b702f8b4cad9af2643b303be7a0c8c5efdfeeaac","modified":1738655685177},{"_id":"public/2025/01/06/最大子数组和/index.html","hash":"d78da73565b1f5aca9f4fb25cf14067167bf1d51","modified":1738655685177},{"_id":"public/2024/12/24/AQS/index.html","hash":"0a32bd84b336fb295d39c350777a08e31e0352fc","modified":1738655685177},{"_id":"public/2024/12/22/localCache持久化和加载的实现/index.html","hash":"3fa91dec973dde20a667c94a0f32c71e3e0ae018","modified":1738655685177},{"_id":"public/2024/12/17/localCache实现expire过期原理/index.html","hash":"616511b7cb60f4d0a631703797248b38597c8e90","modified":1738655685177},{"_id":"public/2024/12/15/localCache本地缓存项目实现固定大小缓存/index.html","hash":"6049091b45ab8df7a45b7888f5046895ccde6188","modified":1738655685177},{"_id":"public/2024/12/14/leetcode第31题解/index.html","hash":"e887bf78162dcb4b94b30b64cd07ff80dd38fd4f","modified":1738655685177},{"_id":"public/2024/12/14/java中的代理/index.html","hash":"479f8535c7ea9761e953477c77f33b53d9f34441","modified":1738655685177},{"_id":"public/2024/11/21/用线程池执行批量耗时任务的优点/index.html","hash":"909b4a8c6ccdfdcad23fbfbf629cd93e5c40e366","modified":1738655685177},{"_id":"public/2024/11/14/工厂-注册表模式设计nodeHandler/index.html","hash":"4748819056a05368bcb295bfec5a9a0cf9fa48b3","modified":1738655685177},{"_id":"public/2024/11/01/普通线程池的执行流程/index.html","hash":"d372c64365b99f0c2593ddc6c81659c53ccab6ac","modified":1738655685177},{"_id":"public/2024/10/26/实在智能实习经历收获/index.html","hash":"e2df95cc2ee16a5179d0587ea571cee5fc493593","modified":1738655685177},{"_id":"public/2024/10/15/redis淘汰策略/index.html","hash":"a4e6cf6bc3ba25d53afbe01e68b3a1e25ad2fe45","modified":1738655685177},{"_id":"public/2024/10/15/java中Atomic原子类型/index.html","hash":"44c0fb901caff6559dae0e2c55802047a5ba0b68","modified":1738655685177},{"_id":"public/2024/10/15/mysql数据库索引分类及其底层数据结构/index.html","hash":"332fcc730f5320124fea6ea53e42a908982d2aec","modified":1738655685177},{"_id":"public/2024/10/15/redo-log和undo-log/index.html","hash":"a53f9a65bd5e43ab86f56ccda7a8c92fe91e5a57","modified":1738655685177},{"_id":"public/2024/10/11/gradle构建java项目时乱码问题解决方案/index.html","hash":"cdbf95ba6ac483c5858ba5d0691dc0d99fce1afb","modified":1738655685177},{"_id":"public/2024/09/14/杭州实在智能java实习面经/index.html","hash":"7ce2d3aeb18e2f97cd1ad68bad83feac70c15d92","modified":1738655685177},{"_id":"public/2024/09/10/力扣146-LRU缓存/index.html","hash":"535e98c01f2869fb8c6fc01add70fd882aca2615","modified":1738655685177},{"_id":"public/index.html","hash":"72c6160cf4d33bbfa63b56f464ffcc402c0d30dd","modified":1738655685177},{"_id":"public/page/2/index.html","hash":"00ac69778b497c53163dcf88828db5109de31a5b","modified":1738655685177},{"_id":"public/page/3/index.html","hash":"716e377682751a340d3460cf430d15fb4ee822e8","modified":1738655685177},{"_id":"public/page/4/index.html","hash":"e7599552db3788fed1a07b88d52944725c112701","modified":1738655685177},{"_id":"public/archives/index.html","hash":"db9d0f6ea6aaee203c07922d9345037922d2e419","modified":1738655685177},{"_id":"public/archives/page/2/index.html","hash":"681ff0f5fe968d777c3572e0733c0a28fd15d10a","modified":1738655685177},{"_id":"public/archives/page/3/index.html","hash":"0d4672db77e4ce9070c947abc0c56c72829d2995","modified":1738655685177},{"_id":"public/archives/page/4/index.html","hash":"c99a94c0890e49e694f967f4201af6612f0080cc","modified":1738655685177},{"_id":"public/archives/2024/index.html","hash":"269018a5edc7bcbe27ed8dc374feee1b4b5ca358","modified":1738655685177},{"_id":"public/archives/2024/page/2/index.html","hash":"9854cbe6de0bf57822d7573b245e3e542e7d9e8f","modified":1738655685177},{"_id":"public/archives/2024/09/index.html","hash":"ed4bbb941dad9c6a4dfc04fdd090b04aee4c1b69","modified":1738655685177},{"_id":"public/archives/2024/10/index.html","hash":"cb21ad4f8b3208fc4845d1cbd8dead2b361cf70c","modified":1738655685177},{"_id":"public/archives/2024/11/index.html","hash":"6683ce74b7f03b2c3fb8c08520f8a387c39ce75e","modified":1738655685177},{"_id":"public/archives/2024/12/index.html","hash":"3e0a3a597d6427e2a461ea2e2e725cebd860fb1f","modified":1738655685177},{"_id":"public/archives/2025/index.html","hash":"68be27aa4959bcdb0c037ffa4ad9dfbb588589f1","modified":1738655685177},{"_id":"public/archives/2025/page/2/index.html","hash":"c048f94ea3b72f81abe625aaf44c9cd5040aab7b","modified":1738655685177},{"_id":"public/archives/2025/01/index.html","hash":"0e1d05e4edb6b6ab513a181591fa8ac1b21cd5ee","modified":1738655685177},{"_id":"public/archives/2025/01/page/2/index.html","hash":"0f0326d8a1da51cadcddf667dcda3e00d14893f1","modified":1738655685177},{"_id":"public/archives/2025/02/index.html","hash":"d57753316bd9c63473ac61f1fb36d1fa273e8271","modified":1738655685177},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1738655685177},{"_id":"public/img/head-pic.png","hash":"3f0bf78cf120b48293a5ba6652684fe748faeb1c","modified":1738655685177},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1738655685177},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1738655685177},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1738655685177},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1738655685177},{"_id":"public/js/utils.js","hash":"fd3c26366c78dd82bc87d4ddebe76c582122e1b7","modified":1738655685177},{"_id":"public/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1738655685177},{"_id":"public/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1738655685177},{"_id":"public/css/index.css","hash":"d484681db4bf50b47b19c4d0fe6fec17c9599a08","modified":1738655685177},{"_id":"public/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1738655685177},{"_id":"public/js/main.js","hash":"9fb88eb196f9368768aaa554c679129e4969f069","modified":1738655685177},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1738655685177},{"_id":"public/img/background.png","hash":"fad38e75bb760bd9794f7ea9d2583fb3dc4921a4","modified":1738655685177}],"Category":[{"name":"算法","_id":"cm6q6pd1p00033ga8bp4l1b0s"},{"name":"八股文","_id":"cm6q6pd1s00083ga82c4304lb"},{"name":"业务场景","_id":"cm6q6pd1u000e3ga8bznnf4kh"},{"name":"面试","_id":"cm6q6pd2000113ga8godb6ykd"},{"name":"项目","_id":"cm6q6pd2100183ga8daw0a1n7"},{"name":"底层实现","_id":"cm6q6pd24001n3ga8e2gw8n8m"},{"name":"实习业务","_id":"cm6q6pd28001u3ga84zpk8u51"},{"name":"面经","_id":"cm6q6pd2g002m3ga819xp1dv4"},{"name":"面试题","_id":"cm6q6pd2i002v3ga8glfz4j2g"}],"Data":[],"Page":[],"Post":[{"title":"15.三数之和","date":"2025-01-09T13:25:03.000Z","_content":"\n# 题目\n\n## [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。\n\n**注意**：答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n**输入**：nums = [-1,0,1,2,-1,-4]\n**输出：**[[-1,-1,2],[-1,0,1]]\n**解释：**\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n\n**示例 2：**\n\n**输入**：nums = [0,1,1]\n**输出：**[]\n**解释**：唯一可能的三元组和不为 0 。\n\n**示例 3：**\n\n**输入**：nums = [0,0,0]\n**输出：**[[0,0,0]]\n**解释**：唯一可能的三元组和为 0 。\n\n**提示：**\n\n- `3 <= nums.length <= 3000`\n- `-105 <= nums[i] <= 105`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList();\n        for(int i=0;i<nums.length-2;i++)\n        {\n            if(i!=0&&nums[i]==nums[i-1])\n            {\n                continue ;\n            }\n            int l=i+1;\n            int r=nums.length-1;\n            while(l<r)\n            {\n                if(nums[i]+nums[l]+nums[r]==0)\n                {\n                    List<Integer> list = new ArrayList();\n                    list.add(nums[i]);\n                    list.add(nums[l]);\n                    list.add(nums[r]);\n                    result.add(list);\n                    l++;r--;\n                    while(nums[l]==nums[l-1]&&l<r)\n                    {\n                        l++;\n                    }\n                    while(nums[r]==nums[r+1]&&l<r)\n                    {\n                        r--;\n                    }\n                } else if(nums[i]+nums[l]+nums[r]<0)\n                {\n                    l++;\n                } else {\n                    r--;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n# 思路\n\n1. 先排序\n\n2. 遍历第一个，跳过重复元素避免结果重复\n\n3. 后两个用双指针思想，跳过重复元素，通过和的大小去移动双指针\n","source":"_posts/15-三数之和.md","raw":"---\ntitle: 15.三数之和\ndate: 2025-01-09 21:25:03\ntags:\n---\n\n# 题目\n\n## [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。\n\n**注意**：答案中不可以包含重复的三元组。\n\n**示例 1：**\n\n**输入**：nums = [-1,0,1,2,-1,-4]\n**输出：**[[-1,-1,2],[-1,0,1]]\n**解释：**\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n\n**示例 2：**\n\n**输入**：nums = [0,1,1]\n**输出：**[]\n**解释**：唯一可能的三元组和不为 0 。\n\n**示例 3：**\n\n**输入**：nums = [0,0,0]\n**输出：**[[0,0,0]]\n**解释**：唯一可能的三元组和为 0 。\n\n**提示：**\n\n- `3 <= nums.length <= 3000`\n- `-105 <= nums[i] <= 105`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList();\n        for(int i=0;i<nums.length-2;i++)\n        {\n            if(i!=0&&nums[i]==nums[i-1])\n            {\n                continue ;\n            }\n            int l=i+1;\n            int r=nums.length-1;\n            while(l<r)\n            {\n                if(nums[i]+nums[l]+nums[r]==0)\n                {\n                    List<Integer> list = new ArrayList();\n                    list.add(nums[i]);\n                    list.add(nums[l]);\n                    list.add(nums[r]);\n                    result.add(list);\n                    l++;r--;\n                    while(nums[l]==nums[l-1]&&l<r)\n                    {\n                        l++;\n                    }\n                    while(nums[r]==nums[r+1]&&l<r)\n                    {\n                        r--;\n                    }\n                } else if(nums[i]+nums[l]+nums[r]<0)\n                {\n                    l++;\n                } else {\n                    r--;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n# 思路\n\n1. 先排序\n\n2. 遍历第一个，跳过重复元素避免结果重复\n\n3. 后两个用双指针思想，跳过重复元素，通过和的大小去移动双指针\n","slug":"15-三数之和","published":1,"updated":"2025-01-09T13:29:31.758Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1i00003ga8f1d9c7tu","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a><a href=\"https://leetcode.cn/problems/3sum/\">15. 三数之和</a></h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [-1,0,1,2,-1,-4]<br><strong>输出：</strong>[[-1,-1,2],[-1,0,1]]<br><strong>解释：</strong><br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [0,1,1]<br><strong>输出：</strong>[]<br><strong>解释</strong>：唯一可能的三元组和不为 0 。</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [0,0,0]<br><strong>输出：</strong>[[0,0,0]]<br><strong>解释</strong>：唯一可能的三元组和为 0 。</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">threeSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length-<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i!=<span class=\"number\">0</span>&amp;&amp;nums[i]==nums[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> l=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> r=nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]+nums[l]+nums[r]==<span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">                    list.add(nums[i]);</span><br><span class=\"line\">                    list.add(nums[l]);</span><br><span class=\"line\">                    list.add(nums[r]);</span><br><span class=\"line\">                    result.add(list);</span><br><span class=\"line\">                    l++;r--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(nums[l]==nums[l-<span class=\"number\">1</span>]&amp;&amp;l&lt;r)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(nums[r]==nums[r+<span class=\"number\">1</span>]&amp;&amp;l&lt;r)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]+nums[l]+nums[r]&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    l++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li><p>先排序</p>\n</li>\n<li><p>遍历第一个，跳过重复元素避免结果重复</p>\n</li>\n<li><p>后两个用双指针思想，跳过重复元素，通过和的大小去移动双指针</p>\n</li>\n</ol>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><h2 id=\"15-三数之和\"><a href=\"#15-三数之和\" class=\"headerlink\" title=\"15. 三数之和\"></a><a href=\"https://leetcode.cn/problems/3sum/\">15. 三数之和</a></h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [-1,0,1,2,-1,-4]<br><strong>输出：</strong>[[-1,-1,2],[-1,0,1]]<br><strong>解释：</strong><br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [0,1,1]<br><strong>输出：</strong>[]<br><strong>解释</strong>：唯一可能的三元组和不为 0 。</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [0,0,0]<br><strong>输出：</strong>[[0,0,0]]<br><strong>解释</strong>：唯一可能的三元组和为 0 。</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">threeSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length-<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i!=<span class=\"number\">0</span>&amp;&amp;nums[i]==nums[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> l=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> r=nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l&lt;r)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]+nums[l]+nums[r]==<span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">                    list.add(nums[i]);</span><br><span class=\"line\">                    list.add(nums[l]);</span><br><span class=\"line\">                    list.add(nums[r]);</span><br><span class=\"line\">                    result.add(list);</span><br><span class=\"line\">                    l++;r--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(nums[l]==nums[l-<span class=\"number\">1</span>]&amp;&amp;l&lt;r)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        l++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(nums[r]==nums[r+<span class=\"number\">1</span>]&amp;&amp;l&lt;r)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        r--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]+nums[l]+nums[r]&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    l++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    r--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ol>\n<li><p>先排序</p>\n</li>\n<li><p>遍历第一个，跳过重复元素避免结果重复</p>\n</li>\n<li><p>后两个用双指针思想，跳过重复元素，通过和的大小去移动双指针</p>\n</li>\n</ol>\n"},{"title":"42.接雨水","date":"2025-01-16T14:31:03.000Z","_content":"\n# 题目\n\n[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\n\n已解答\n\n困难\n\n相关标签\n\n相关企业\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n**输入：**height = [0,1,0,2,1,0,1,3,2,1,2,1]\n**输出：**6\n**解释：**上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n**示例 2：**\n\n**输入：**height = [4,2,0,3,2,5]\n**输出：**9\n\n**提示：**\n\n- `n == height.length`\n- `1 <= n <= 2 * 104`\n- `0 <= height[i] <= 105`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length<=2)\n        {\n            return 0;\n        }\n        int result=0;\n        int[] leftMax = new int[height.length];\n        int[] rightMax = new int[height.length];//记录每一位的左最大值和右最大值\n        leftMax[1]=height[0];\n        rightMax[height.length-2]=height[height.length-1];\n        for(int i=2;i<height.length-1;i++)\n        {\n            leftMax[i]=height[i-1]>leftMax[i-1]?height[i-1]:leftMax[i-1];\n        }\n        for(int i=height.length-3;i>=0;i--)\n        {\n            rightMax[i]=height[i+1]>rightMax[i+1]?height[i+1]:rightMax[i+1];\n        }\n       for(int i=1;i<height.length-1;i++)\n       {\n        int h=Math.min(leftMax[i],rightMax[i]);\n        result+=h>height[i]?h-height[i]:0;\n       }\n       return result;\n    }\n}\n```\n\n\n\n# 思路\n\n根据木桶效应，每个下标可以容纳的水为该下标的左最大高度和右最大高度的最小值减去当前下标的高度，所以我们用两个数组去记录每个下标的左最大值和右最大值，并遍历下标，计算每个位置容纳的水的和即可\n","source":"_posts/42-接雨水.md","raw":"---\ntitle: 42.接雨水\ndate: 2025-01-16 22:31:03\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\n\n已解答\n\n困难\n\n相关标签\n\n相关企业\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n**输入：**height = [0,1,0,2,1,0,1,3,2,1,2,1]\n**输出：**6\n**解释：**上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n**示例 2：**\n\n**输入：**height = [4,2,0,3,2,5]\n**输出：**9\n\n**提示：**\n\n- `n == height.length`\n- `1 <= n <= 2 * 104`\n- `0 <= height[i] <= 105`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length<=2)\n        {\n            return 0;\n        }\n        int result=0;\n        int[] leftMax = new int[height.length];\n        int[] rightMax = new int[height.length];//记录每一位的左最大值和右最大值\n        leftMax[1]=height[0];\n        rightMax[height.length-2]=height[height.length-1];\n        for(int i=2;i<height.length-1;i++)\n        {\n            leftMax[i]=height[i-1]>leftMax[i-1]?height[i-1]:leftMax[i-1];\n        }\n        for(int i=height.length-3;i>=0;i--)\n        {\n            rightMax[i]=height[i+1]>rightMax[i+1]?height[i+1]:rightMax[i+1];\n        }\n       for(int i=1;i<height.length-1;i++)\n       {\n        int h=Math.min(leftMax[i],rightMax[i]);\n        result+=h>height[i]?h-height[i]:0;\n       }\n       return result;\n    }\n}\n```\n\n\n\n# 思路\n\n根据木桶效应，每个下标可以容纳的水为该下标的左最大高度和右最大高度的最小值减去当前下标的高度，所以我们用两个数组去记录每个下标的左最大值和右最大值，并遍历下标，计算每个位置容纳的水的和即可\n","slug":"42-接雨水","published":1,"updated":"2025-01-16T14:40:49.414Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1m00013ga87mog2k3h","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/trapping-rain-water/\">42. 接雨水</a></p>\n<p>已解答</p>\n<p>困难</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\"></p>\n<p><strong>输入：</strong>height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong>6<br><strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>height &#x3D; [4,2,0,3,2,5]<br><strong>输出：</strong>9</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 105</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">trap</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height.length&lt;=<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] leftMax = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[height.length];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] rightMax = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[height.length];<span class=\"comment\">//记录每一位的左最大值和右最大值</span></span><br><span class=\"line\">        leftMax[<span class=\"number\">1</span>]=height[<span class=\"number\">0</span>];</span><br><span class=\"line\">        rightMax[height.length-<span class=\"number\">2</span>]=height[height.length-<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;height.length-<span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            leftMax[i]=height[i-<span class=\"number\">1</span>]&gt;leftMax[i-<span class=\"number\">1</span>]?height[i-<span class=\"number\">1</span>]:leftMax[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=height.length-<span class=\"number\">3</span>;i&gt;=<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rightMax[i]=height[i+<span class=\"number\">1</span>]&gt;rightMax[i+<span class=\"number\">1</span>]?height[i+<span class=\"number\">1</span>]:rightMax[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;height.length-<span class=\"number\">1</span>;i++)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> h=Math.min(leftMax[i],rightMax[i]);</span><br><span class=\"line\">        result+=h&gt;height[i]?h-height[i]:<span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>根据木桶效应，每个下标可以容纳的水为该下标的左最大高度和右最大高度的最小值减去当前下标的高度，所以我们用两个数组去记录每个下标的左最大值和右最大值，并遍历下标，计算每个位置容纳的水的和即可</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/trapping-rain-water/\">42. 接雨水</a></p>\n<p>已解答</p>\n<p>困难</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\"></p>\n<p><strong>输入：</strong>height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br><strong>输出：</strong>6<br><strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>height &#x3D; [4,2,0,3,2,5]<br><strong>输出：</strong>9</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>1 &lt;= n &lt;= 2 * 104</code></li>\n<li><code>0 &lt;= height[i] &lt;= 105</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">trap</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(height.length&lt;=<span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> result=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] leftMax = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[height.length];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] rightMax = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[height.length];<span class=\"comment\">//记录每一位的左最大值和右最大值</span></span><br><span class=\"line\">        leftMax[<span class=\"number\">1</span>]=height[<span class=\"number\">0</span>];</span><br><span class=\"line\">        rightMax[height.length-<span class=\"number\">2</span>]=height[height.length-<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;height.length-<span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            leftMax[i]=height[i-<span class=\"number\">1</span>]&gt;leftMax[i-<span class=\"number\">1</span>]?height[i-<span class=\"number\">1</span>]:leftMax[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=height.length-<span class=\"number\">3</span>;i&gt;=<span class=\"number\">0</span>;i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rightMax[i]=height[i+<span class=\"number\">1</span>]&gt;rightMax[i+<span class=\"number\">1</span>]?height[i+<span class=\"number\">1</span>]:rightMax[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;height.length-<span class=\"number\">1</span>;i++)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> h=Math.min(leftMax[i],rightMax[i]);</span><br><span class=\"line\">        result+=h&gt;height[i]?h-height[i]:<span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>根据木桶效应，每个下标可以容纳的水为该下标的左最大高度和右最大高度的最小值减去当前下标的高度，所以我们用两个数组去记录每个下标的左最大值和右最大值，并遍历下标，计算每个位置容纳的水的和即可</p>\n"},{"title":"AQS","date":"2024-12-24T14:29:34.000Z","_content":"\n**AQS（AbstractQueuedSynchronizer）** 是 Java 并发包（`java.util.concurrent`）中的核心类之一，作为构建锁和同步器的基础。很多 JUC 中的同步工具，如 `ReentrantLock`、`Semaphore`、`CountDownLatch`、`ReadWriteLock` 等，都是基于 AQS 实现的。AQS 通过维护一个**FIFO（先进先出）的等待队列**，来管理多个线程之间的同步操作。\n\nAQS 主要通过内部的**状态（state）**和**队列**来控制锁的获取和释放，线程的阻塞和唤醒。\n\n### 1. **AQS 的基本结构**\n\nAQS 的核心由以下几个部分组成：\n\n- **同步状态（state）**：一个 `int` 类型的变量，用于表示同步状态。可以由子类实现锁的状态，如 `ReentrantLock` 使用 `state == 0` 表示锁未被持有，`state == 1` 表示锁被持有。\n- **等待队列**：AQS 内部维护一个 **FIFO 队列**（双向链表），所有无法获得锁的线程都会被加入到这个队列中，并且线程会被挂起，直到锁可用时被唤醒。\n- **Node 节点**：队列中的每个节点（`Node`）代表一个等待锁的线程，Node 包含了线程的状态、前驱和后继节点的引用。\n\n### 2. **AQS 的工作原理**\n\nAQS 主要通过以下几种机制来实现线程的同步控制：\n\n#### 1. **独占模式（Exclusive）**\n\n在独占模式下，只有一个线程可以获取到锁，其他线程需要等待。独占模式是 `ReentrantLock` 使用的模式。\n\n**工作流程**：\n\n- 当线程尝试获取锁时，AQS 调用 `acquire()` 方法。\n- 如果锁被占用，线程会被加入到等待队列的尾部，并进入阻塞状态（通过调用 `LockSupport.park()` 挂起线程）。\n- 当持有锁的线程释放锁时，AQS 会唤醒等待队列中的第一个线程（通过 `LockSupport.unpark()` 唤醒线程）。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n`acquire()` 方法尝试获取锁，如果获取失败，线程将进入队列等待。`addWaiter(Node.EXCLUSIVE)` 方法会将线程以独占模式加入等待队列。\n\n#### 2. **共享模式（Shared）**\n\n在共享模式下，多个线程可以同时获得锁，这种模式适用于 `Semaphore`、`CountDownLatch` 等允许多个线程共享资源的场景。\n\n**工作流程**：\n\n- 在共享模式下，多个线程可以同时获取锁。\n- AQS 中的 `acquireShared()` 方法会尝试获取共享锁，如果成功，多个线程会被唤醒并共享资源。\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n```\n\n### 3. **等待队列的管理**\n\nAQS 内部通过一个双向链表来维护阻塞线程的等待队列。等待队列的节点是 `Node`，每个 `Node` 包含了一个线程的引用和线程的状态：\n\n- **Node 的状态**：\n  - `CANCELLED`：表示线程等待超时或被中断，该节点被取消。\n  - `SIGNAL`：表示当前节点的线程阻塞，需要被唤醒。\n  - `CONDITION`：表示线程等待在某个 `Condition` 上。\n  - `PROPAGATE`：用于共享模式，表示后续节点需要被唤醒。\n\n当某个线程释放锁时，AQS 会从队列中唤醒下一个等待线程，唤醒时调用 `LockSupport.unpark(thread)`。\n\n### 4. **锁的实现**\n\n#### **独占模式下的 ReentrantLock**\n\n`ReentrantLock` 是 AQS 的典型实现之一。在独占模式下，锁的获取和释放由 AQS 提供的方法来管理。\n\n- **获取锁**：`ReentrantLock.lock()` 方法调用 AQS 的 `acquire()`，该方法首先尝试通过 `tryAcquire()` 获取锁，如果失败，则将当前线程加入等待队列并进入阻塞状态。\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    } else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n- **释放锁**：`ReentrantLock.unlock()` 方法调用 AQS 的 `release()`，该方法通过 `tryRelease()` 判断是否能够释放锁，并唤醒等待队列中的下一个线程。\n\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n### 5. **Condition 的实现**\n\nAQS 还为每个锁提供了 `Condition` 支持，允许线程等待某个条件的发生。当线程调用 `Condition.await()` 时，线程会被放入**条件队列**，并在条件满足时由 `Condition.signal()` 唤醒。\n\n- **await()**：线程调用 `await()` 后会释放锁并进入条件队列，挂起当前线程。\n- **signal()**：唤醒等待队列中的一个线程，重新竞争锁。\n\n```java\npublic final void await() throws InterruptedException {\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n    }\n    acquireQueued(node, savedState);\n}\n```\n\n### 6. **AQS 的优点**\n\n- **简化并发工具的开发**：通过 AQS，开发者可以方便地实现复杂的同步工具（如自定义锁、信号量等），无需重复实现底层的同步机制。\n- **可扩展性**：AQS 提供了丰富的扩展点，允许开发者自定义锁的行为（独占或共享模式）。\n- **高效的线程管理**：AQS 通过队列管理等待线程，采用 `park()` 和 `unpark()` 提供了高效的线程阻塞与唤醒机制。\n\n### 总结\n\nAQS 是 Java 并发框架中实现锁、信号量等同步工具的基础框架，通过维护同步状态、等待队列和提供独占与共享两种模式，实现了对线程的阻塞和唤醒控制。它极大简化了同步器的实现，使得 `ReentrantLock`、`Semaphore` 等工具类变得更加灵活和高效。\n","source":"_posts/AQS.md","raw":"---\ntitle: AQS\ndate: 2024-12-24 22:29:34\ntags: juc\ncategories: 八股文\n---\n\n**AQS（AbstractQueuedSynchronizer）** 是 Java 并发包（`java.util.concurrent`）中的核心类之一，作为构建锁和同步器的基础。很多 JUC 中的同步工具，如 `ReentrantLock`、`Semaphore`、`CountDownLatch`、`ReadWriteLock` 等，都是基于 AQS 实现的。AQS 通过维护一个**FIFO（先进先出）的等待队列**，来管理多个线程之间的同步操作。\n\nAQS 主要通过内部的**状态（state）**和**队列**来控制锁的获取和释放，线程的阻塞和唤醒。\n\n### 1. **AQS 的基本结构**\n\nAQS 的核心由以下几个部分组成：\n\n- **同步状态（state）**：一个 `int` 类型的变量，用于表示同步状态。可以由子类实现锁的状态，如 `ReentrantLock` 使用 `state == 0` 表示锁未被持有，`state == 1` 表示锁被持有。\n- **等待队列**：AQS 内部维护一个 **FIFO 队列**（双向链表），所有无法获得锁的线程都会被加入到这个队列中，并且线程会被挂起，直到锁可用时被唤醒。\n- **Node 节点**：队列中的每个节点（`Node`）代表一个等待锁的线程，Node 包含了线程的状态、前驱和后继节点的引用。\n\n### 2. **AQS 的工作原理**\n\nAQS 主要通过以下几种机制来实现线程的同步控制：\n\n#### 1. **独占模式（Exclusive）**\n\n在独占模式下，只有一个线程可以获取到锁，其他线程需要等待。独占模式是 `ReentrantLock` 使用的模式。\n\n**工作流程**：\n\n- 当线程尝试获取锁时，AQS 调用 `acquire()` 方法。\n- 如果锁被占用，线程会被加入到等待队列的尾部，并进入阻塞状态（通过调用 `LockSupport.park()` 挂起线程）。\n- 当持有锁的线程释放锁时，AQS 会唤醒等待队列中的第一个线程（通过 `LockSupport.unpark()` 唤醒线程）。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n`acquire()` 方法尝试获取锁，如果获取失败，线程将进入队列等待。`addWaiter(Node.EXCLUSIVE)` 方法会将线程以独占模式加入等待队列。\n\n#### 2. **共享模式（Shared）**\n\n在共享模式下，多个线程可以同时获得锁，这种模式适用于 `Semaphore`、`CountDownLatch` 等允许多个线程共享资源的场景。\n\n**工作流程**：\n\n- 在共享模式下，多个线程可以同时获取锁。\n- AQS 中的 `acquireShared()` 方法会尝试获取共享锁，如果成功，多个线程会被唤醒并共享资源。\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n```\n\n### 3. **等待队列的管理**\n\nAQS 内部通过一个双向链表来维护阻塞线程的等待队列。等待队列的节点是 `Node`，每个 `Node` 包含了一个线程的引用和线程的状态：\n\n- **Node 的状态**：\n  - `CANCELLED`：表示线程等待超时或被中断，该节点被取消。\n  - `SIGNAL`：表示当前节点的线程阻塞，需要被唤醒。\n  - `CONDITION`：表示线程等待在某个 `Condition` 上。\n  - `PROPAGATE`：用于共享模式，表示后续节点需要被唤醒。\n\n当某个线程释放锁时，AQS 会从队列中唤醒下一个等待线程，唤醒时调用 `LockSupport.unpark(thread)`。\n\n### 4. **锁的实现**\n\n#### **独占模式下的 ReentrantLock**\n\n`ReentrantLock` 是 AQS 的典型实现之一。在独占模式下，锁的获取和释放由 AQS 提供的方法来管理。\n\n- **获取锁**：`ReentrantLock.lock()` 方法调用 AQS 的 `acquire()`，该方法首先尝试通过 `tryAcquire()` 获取锁，如果失败，则将当前线程加入等待队列并进入阻塞状态。\n\n```java\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    } else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n- **释放锁**：`ReentrantLock.unlock()` 方法调用 AQS 的 `release()`，该方法通过 `tryRelease()` 判断是否能够释放锁，并唤醒等待队列中的下一个线程。\n\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n### 5. **Condition 的实现**\n\nAQS 还为每个锁提供了 `Condition` 支持，允许线程等待某个条件的发生。当线程调用 `Condition.await()` 时，线程会被放入**条件队列**，并在条件满足时由 `Condition.signal()` 唤醒。\n\n- **await()**：线程调用 `await()` 后会释放锁并进入条件队列，挂起当前线程。\n- **signal()**：唤醒等待队列中的一个线程，重新竞争锁。\n\n```java\npublic final void await() throws InterruptedException {\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n    }\n    acquireQueued(node, savedState);\n}\n```\n\n### 6. **AQS 的优点**\n\n- **简化并发工具的开发**：通过 AQS，开发者可以方便地实现复杂的同步工具（如自定义锁、信号量等），无需重复实现底层的同步机制。\n- **可扩展性**：AQS 提供了丰富的扩展点，允许开发者自定义锁的行为（独占或共享模式）。\n- **高效的线程管理**：AQS 通过队列管理等待线程，采用 `park()` 和 `unpark()` 提供了高效的线程阻塞与唤醒机制。\n\n### 总结\n\nAQS 是 Java 并发框架中实现锁、信号量等同步工具的基础框架，通过维护同步状态、等待队列和提供独占与共享两种模式，实现了对线程的阻塞和唤醒控制。它极大简化了同步器的实现，使得 `ReentrantLock`、`Semaphore` 等工具类变得更加灵活和高效。\n","slug":"AQS","published":1,"updated":"2024-12-24T14:30:25.145Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1o00023ga84vwc79qy","content":"<p><strong>AQS（AbstractQueuedSynchronizer）</strong> 是 Java 并发包（<code>java.util.concurrent</code>）中的核心类之一，作为构建锁和同步器的基础。很多 JUC 中的同步工具，如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReadWriteLock</code> 等，都是基于 AQS 实现的。AQS 通过维护一个<strong>FIFO（先进先出）的等待队列</strong>，来管理多个线程之间的同步操作。</p>\n<p>AQS 主要通过内部的<strong>状态（state）</strong>和<strong>队列</strong>来控制锁的获取和释放，线程的阻塞和唤醒。</p>\n<h3 id=\"1-AQS-的基本结构\"><a href=\"#1-AQS-的基本结构\" class=\"headerlink\" title=\"1. AQS 的基本结构\"></a>1. <strong>AQS 的基本结构</strong></h3><p>AQS 的核心由以下几个部分组成：</p>\n<ul>\n<li><strong>同步状态（state）</strong>：一个 <code>int</code> 类型的变量，用于表示同步状态。可以由子类实现锁的状态，如 <code>ReentrantLock</code> 使用 <code>state == 0</code> 表示锁未被持有，<code>state == 1</code> 表示锁被持有。</li>\n<li><strong>等待队列</strong>：AQS 内部维护一个 <strong>FIFO 队列</strong>（双向链表），所有无法获得锁的线程都会被加入到这个队列中，并且线程会被挂起，直到锁可用时被唤醒。</li>\n<li><strong>Node 节点</strong>：队列中的每个节点（<code>Node</code>）代表一个等待锁的线程，Node 包含了线程的状态、前驱和后继节点的引用。</li>\n</ul>\n<h3 id=\"2-AQS-的工作原理\"><a href=\"#2-AQS-的工作原理\" class=\"headerlink\" title=\"2. AQS 的工作原理\"></a>2. <strong>AQS 的工作原理</strong></h3><p>AQS 主要通过以下几种机制来实现线程的同步控制：</p>\n<h4 id=\"1-独占模式（Exclusive）\"><a href=\"#1-独占模式（Exclusive）\" class=\"headerlink\" title=\"1. 独占模式（Exclusive）\"></a>1. <strong>独占模式（Exclusive）</strong></h4><p>在独占模式下，只有一个线程可以获取到锁，其他线程需要等待。独占模式是 <code>ReentrantLock</code> 使用的模式。</p>\n<p><strong>工作流程</strong>：</p>\n<ul>\n<li>当线程尝试获取锁时，AQS 调用 <code>acquire()</code> 方法。</li>\n<li>如果锁被占用，线程会被加入到等待队列的尾部，并进入阻塞状态（通过调用 <code>LockSupport.park()</code> 挂起线程）。</li>\n<li>当持有锁的线程释放锁时，AQS 会唤醒等待队列中的第一个线程（通过 <code>LockSupport.unpark()</code> 唤醒线程）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>acquire()</code> 方法尝试获取锁，如果获取失败，线程将进入队列等待。<code>addWaiter(Node.EXCLUSIVE)</code> 方法会将线程以独占模式加入等待队列。</p>\n<h4 id=\"2-共享模式（Shared）\"><a href=\"#2-共享模式（Shared）\" class=\"headerlink\" title=\"2. 共享模式（Shared）\"></a>2. <strong>共享模式（Shared）</strong></h4><p>在共享模式下，多个线程可以同时获得锁，这种模式适用于 <code>Semaphore</code>、<code>CountDownLatch</code> 等允许多个线程共享资源的场景。</p>\n<p><strong>工作流程</strong>：</p>\n<ul>\n<li>在共享模式下，多个线程可以同时获取锁。</li>\n<li>AQS 中的 <code>acquireShared()</code> 方法会尝试获取共享锁，如果成功，多个线程会被唤醒并共享资源。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireShared</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-等待队列的管理\"><a href=\"#3-等待队列的管理\" class=\"headerlink\" title=\"3. 等待队列的管理\"></a>3. <strong>等待队列的管理</strong></h3><p>AQS 内部通过一个双向链表来维护阻塞线程的等待队列。等待队列的节点是 <code>Node</code>，每个 <code>Node</code> 包含了一个线程的引用和线程的状态：</p>\n<ul>\n<li><strong>Node 的状态</strong>：<ul>\n<li><code>CANCELLED</code>：表示线程等待超时或被中断，该节点被取消。</li>\n<li><code>SIGNAL</code>：表示当前节点的线程阻塞，需要被唤醒。</li>\n<li><code>CONDITION</code>：表示线程等待在某个 <code>Condition</code> 上。</li>\n<li><code>PROPAGATE</code>：用于共享模式，表示后续节点需要被唤醒。</li>\n</ul>\n</li>\n</ul>\n<p>当某个线程释放锁时，AQS 会从队列中唤醒下一个等待线程，唤醒时调用 <code>LockSupport.unpark(thread)</code>。</p>\n<h3 id=\"4-锁的实现\"><a href=\"#4-锁的实现\" class=\"headerlink\" title=\"4. 锁的实现\"></a>4. <strong>锁的实现</strong></h3><h4 id=\"独占模式下的-ReentrantLock\"><a href=\"#独占模式下的-ReentrantLock\" class=\"headerlink\" title=\"独占模式下的 ReentrantLock\"></a><strong>独占模式下的 ReentrantLock</strong></h4><p><code>ReentrantLock</code> 是 AQS 的典型实现之一。在独占模式下，锁的获取和释放由 AQS 提供的方法来管理。</p>\n<ul>\n<li><strong>获取锁</strong>：<code>ReentrantLock.lock()</code> 方法调用 AQS 的 <code>acquire()</code>，该方法首先尝试通过 <code>tryAcquire()</code> 获取锁，如果失败，则将当前线程加入等待队列并进入阻塞状态。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> acquires)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">nextc</span> <span class=\"operator\">=</span> c + acquires;</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>释放锁</strong>：<code>ReentrantLock.unlock()</code> 方法调用 AQS 的 <code>release()</code>，该方法通过 <code>tryRelease()</code> 判断是否能够释放锁，并唤醒等待队列中的下一个线程。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> releases)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalMonitorStateException</span>();</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">free</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Condition-的实现\"><a href=\"#5-Condition-的实现\" class=\"headerlink\" title=\"5. Condition 的实现\"></a>5. <strong>Condition 的实现</strong></h3><p>AQS 还为每个锁提供了 <code>Condition</code> 支持，允许线程等待某个条件的发生。当线程调用 <code>Condition.await()</code> 时，线程会被放入<strong>条件队列</strong>，并在条件满足时由 <code>Condition.signal()</code> 唤醒。</p>\n<ul>\n<li>**await()**：线程调用 <code>await()</code> 后会释放锁并进入条件队列，挂起当前线程。</li>\n<li>**signal()**：唤醒等待队列中的一个线程，重新竞争锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> addConditionWaiter();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">savedState</span> <span class=\"operator\">=</span> fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    acquireQueued(node, savedState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-AQS-的优点\"><a href=\"#6-AQS-的优点\" class=\"headerlink\" title=\"6. AQS 的优点\"></a>6. <strong>AQS 的优点</strong></h3><ul>\n<li><strong>简化并发工具的开发</strong>：通过 AQS，开发者可以方便地实现复杂的同步工具（如自定义锁、信号量等），无需重复实现底层的同步机制。</li>\n<li><strong>可扩展性</strong>：AQS 提供了丰富的扩展点，允许开发者自定义锁的行为（独占或共享模式）。</li>\n<li><strong>高效的线程管理</strong>：AQS 通过队列管理等待线程，采用 <code>park()</code> 和 <code>unpark()</code> 提供了高效的线程阻塞与唤醒机制。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AQS 是 Java 并发框架中实现锁、信号量等同步工具的基础框架，通过维护同步状态、等待队列和提供独占与共享两种模式，实现了对线程的阻塞和唤醒控制。它极大简化了同步器的实现，使得 <code>ReentrantLock</code>、<code>Semaphore</code> 等工具类变得更加灵活和高效。</p>\n","cover":false,"excerpt":"","more":"<p><strong>AQS（AbstractQueuedSynchronizer）</strong> 是 Java 并发包（<code>java.util.concurrent</code>）中的核心类之一，作为构建锁和同步器的基础。很多 JUC 中的同步工具，如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReadWriteLock</code> 等，都是基于 AQS 实现的。AQS 通过维护一个<strong>FIFO（先进先出）的等待队列</strong>，来管理多个线程之间的同步操作。</p>\n<p>AQS 主要通过内部的<strong>状态（state）</strong>和<strong>队列</strong>来控制锁的获取和释放，线程的阻塞和唤醒。</p>\n<h3 id=\"1-AQS-的基本结构\"><a href=\"#1-AQS-的基本结构\" class=\"headerlink\" title=\"1. AQS 的基本结构\"></a>1. <strong>AQS 的基本结构</strong></h3><p>AQS 的核心由以下几个部分组成：</p>\n<ul>\n<li><strong>同步状态（state）</strong>：一个 <code>int</code> 类型的变量，用于表示同步状态。可以由子类实现锁的状态，如 <code>ReentrantLock</code> 使用 <code>state == 0</code> 表示锁未被持有，<code>state == 1</code> 表示锁被持有。</li>\n<li><strong>等待队列</strong>：AQS 内部维护一个 <strong>FIFO 队列</strong>（双向链表），所有无法获得锁的线程都会被加入到这个队列中，并且线程会被挂起，直到锁可用时被唤醒。</li>\n<li><strong>Node 节点</strong>：队列中的每个节点（<code>Node</code>）代表一个等待锁的线程，Node 包含了线程的状态、前驱和后继节点的引用。</li>\n</ul>\n<h3 id=\"2-AQS-的工作原理\"><a href=\"#2-AQS-的工作原理\" class=\"headerlink\" title=\"2. AQS 的工作原理\"></a>2. <strong>AQS 的工作原理</strong></h3><p>AQS 主要通过以下几种机制来实现线程的同步控制：</p>\n<h4 id=\"1-独占模式（Exclusive）\"><a href=\"#1-独占模式（Exclusive）\" class=\"headerlink\" title=\"1. 独占模式（Exclusive）\"></a>1. <strong>独占模式（Exclusive）</strong></h4><p>在独占模式下，只有一个线程可以获取到锁，其他线程需要等待。独占模式是 <code>ReentrantLock</code> 使用的模式。</p>\n<p><strong>工作流程</strong>：</p>\n<ul>\n<li>当线程尝试获取锁时，AQS 调用 <code>acquire()</code> 方法。</li>\n<li>如果锁被占用，线程会被加入到等待队列的尾部，并进入阻塞状态（通过调用 <code>LockSupport.park()</code> 挂起线程）。</li>\n<li>当持有锁的线程释放锁时，AQS 会唤醒等待队列中的第一个线程（通过 <code>LockSupport.unpark()</code> 唤醒线程）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>acquire()</code> 方法尝试获取锁，如果获取失败，线程将进入队列等待。<code>addWaiter(Node.EXCLUSIVE)</code> 方法会将线程以独占模式加入等待队列。</p>\n<h4 id=\"2-共享模式（Shared）\"><a href=\"#2-共享模式（Shared）\" class=\"headerlink\" title=\"2. 共享模式（Shared）\"></a>2. <strong>共享模式（Shared）</strong></h4><p>在共享模式下，多个线程可以同时获得锁，这种模式适用于 <code>Semaphore</code>、<code>CountDownLatch</code> 等允许多个线程共享资源的场景。</p>\n<p><strong>工作流程</strong>：</p>\n<ul>\n<li>在共享模式下，多个线程可以同时获取锁。</li>\n<li>AQS 中的 <code>acquireShared()</code> 方法会尝试获取共享锁，如果成功，多个线程会被唤醒并共享资源。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireShared</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-等待队列的管理\"><a href=\"#3-等待队列的管理\" class=\"headerlink\" title=\"3. 等待队列的管理\"></a>3. <strong>等待队列的管理</strong></h3><p>AQS 内部通过一个双向链表来维护阻塞线程的等待队列。等待队列的节点是 <code>Node</code>，每个 <code>Node</code> 包含了一个线程的引用和线程的状态：</p>\n<ul>\n<li><strong>Node 的状态</strong>：<ul>\n<li><code>CANCELLED</code>：表示线程等待超时或被中断，该节点被取消。</li>\n<li><code>SIGNAL</code>：表示当前节点的线程阻塞，需要被唤醒。</li>\n<li><code>CONDITION</code>：表示线程等待在某个 <code>Condition</code> 上。</li>\n<li><code>PROPAGATE</code>：用于共享模式，表示后续节点需要被唤醒。</li>\n</ul>\n</li>\n</ul>\n<p>当某个线程释放锁时，AQS 会从队列中唤醒下一个等待线程，唤醒时调用 <code>LockSupport.unpark(thread)</code>。</p>\n<h3 id=\"4-锁的实现\"><a href=\"#4-锁的实现\" class=\"headerlink\" title=\"4. 锁的实现\"></a>4. <strong>锁的实现</strong></h3><h4 id=\"独占模式下的-ReentrantLock\"><a href=\"#独占模式下的-ReentrantLock\" class=\"headerlink\" title=\"独占模式下的 ReentrantLock\"></a><strong>独占模式下的 ReentrantLock</strong></h4><p><code>ReentrantLock</code> 是 AQS 的典型实现之一。在独占模式下，锁的获取和释放由 AQS 提供的方法来管理。</p>\n<ul>\n<li><strong>获取锁</strong>：<code>ReentrantLock.lock()</code> 方法调用 AQS 的 <code>acquire()</code>，该方法首先尝试通过 <code>tryAcquire()</code> 获取锁，如果失败，则将当前线程加入等待队列并进入阻塞状态。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> acquires)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">nextc</span> <span class=\"operator\">=</span> c + acquires;</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>释放锁</strong>：<code>ReentrantLock.unlock()</code> 方法调用 AQS 的 <code>release()</code>，该方法通过 <code>tryRelease()</code> 判断是否能够释放锁，并唤醒等待队列中的下一个线程。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> releases)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalMonitorStateException</span>();</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">free</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Condition-的实现\"><a href=\"#5-Condition-的实现\" class=\"headerlink\" title=\"5. Condition 的实现\"></a>5. <strong>Condition 的实现</strong></h3><p>AQS 还为每个锁提供了 <code>Condition</code> 支持，允许线程等待某个条件的发生。当线程调用 <code>Condition.await()</code> 时，线程会被放入<strong>条件队列</strong>，并在条件满足时由 <code>Condition.signal()</code> 唤醒。</p>\n<ul>\n<li>**await()**：线程调用 <code>await()</code> 后会释放锁并进入条件队列，挂起当前线程。</li>\n<li>**signal()**：唤醒等待队列中的一个线程，重新竞争锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> addConditionWaiter();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">savedState</span> <span class=\"operator\">=</span> fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    acquireQueued(node, savedState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-AQS-的优点\"><a href=\"#6-AQS-的优点\" class=\"headerlink\" title=\"6. AQS 的优点\"></a>6. <strong>AQS 的优点</strong></h3><ul>\n<li><strong>简化并发工具的开发</strong>：通过 AQS，开发者可以方便地实现复杂的同步工具（如自定义锁、信号量等），无需重复实现底层的同步机制。</li>\n<li><strong>可扩展性</strong>：AQS 提供了丰富的扩展点，允许开发者自定义锁的行为（独占或共享模式）。</li>\n<li><strong>高效的线程管理</strong>：AQS 通过队列管理等待线程，采用 <code>park()</code> 和 <code>unpark()</code> 提供了高效的线程阻塞与唤醒机制。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>AQS 是 Java 并发框架中实现锁、信号量等同步工具的基础框架，通过维护同步状态、等待队列和提供独占与共享两种模式，实现了对线程的阻塞和唤醒控制。它极大简化了同步器的实现，使得 <code>ReentrantLock</code>、<code>Semaphore</code> 等工具类变得更加灵活和高效。</p>\n"},{"title":"ai语音合成项目中线程池优化ppt每一页任务执行","date":"2025-01-15T13:55:44.000Z","_content":"\n**在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。**\n\n这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。\n\n```java\npackage com.soundmentor.soundmentorweb.service.impl;\n\nimport com.alibaba.fastjson.JSON;\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.soundmentor.soundmentorbase.enums.TaskStatusEnum;\nimport com.soundmentor.soundmentorbase.enums.TaskTypeEnum;\nimport com.soundmentor.soundmentorbase.utils.PPTXUtil;\nimport com.soundmentor.soundmentorpojo.DO.TaskDO;\nimport com.soundmentor.soundmentorpojo.DO.UserPptDetailDO;\nimport com.soundmentor.soundmentorpojo.DO.UserPptRelDO;\nimport com.soundmentor.soundmentorpojo.DTO.ppt.PPTPageSummaryTaskDTO;\nimport com.soundmentor.soundmentorpojo.DTO.task.CreatePPTSummaryTaskParam;\nimport com.soundmentor.soundmentorweb.mapper.TaskMapper;\nimport com.soundmentor.soundmentorweb.mapper.UserPptDetailMapper;\nimport com.soundmentor.soundmentorweb.mapper.UserPptRelMapper;\nimport com.soundmentor.soundmentorweb.service.PPTService;\nimport com.soundmentor.soundmentorweb.service.UserInfoApi;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.poi.xslf.usermodel.XMLSlideShow;\nimport org.apache.poi.xslf.usermodel.XSLFSlide;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.dao.DuplicateKeyException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport javax.annotation.Resource;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.ThreadPoolExecutor;\n\n@Service\n@Slf4j\n\npublic class PPTServiceImpl implements PPTService {\n    @Resource\n    private  UserPptDetailMapper userPptDetailMapper;\n    @Resource\n    private  UserPptRelMapper userPptRelMapper;\n    @Resource\n    private  UserInfoApi userInfoApi;\n    @Resource(name = \"task-thread-pool-executor\")\n    private  ThreadPoolExecutor threadPoolExecutor;\n    @Autowired\n    private TaskMapper taskMapper;\n\n    @Override\n    public Integer createPPTSummary(CreatePPTSummaryTaskParam param) {\n        String pptUrl = param.getPptUrl();\n        XMLSlideShow xmlSlideShow = PPTXUtil.loadPPTX(pptUrl);\n        List<XSLFSlide> slides = xmlSlideShow.getSlides();\n        UserPptRelDO userPptRelDO = userPptRelMapper.selectOne(new LambdaQueryWrapper<UserPptRelDO>()\n                .eq(UserPptRelDO::getPptUrl, pptUrl)\n                .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));\n        if (Objects.isNull(userPptRelDO))\n        {\n            userPptRelDO = new UserPptRelDO();\n            userPptRelDO.setPptUrl(pptUrl);\n            userPptRelDO.setUserId(userInfoApi.getUser().getId());\n            userPptRelDO.setPageCount(slides.size());\n            userPptRelDO.setCreateTime(LocalDateTime.now());\n            userPptRelMapper.insert(userPptRelDO);\n        }\n        for (int i = 0; i < slides.size(); i++) {\n            Integer userPptId = userPptRelDO.getId();\n            Integer page = i;\n            XSLFSlide slide = slides.get(page);\n            threadPoolExecutor.execute(()->{\n                try {\n                    taskExec(userPptId,page,slide);\n                } catch (Exception e) {\n                    log.error(\"ppt{}的{}页任务执行失败,请重试\",userPptId,page);\n                }\n            });\n        }\n        return userPptRelDO.getId();\n    }\n\n    /**\n     * ppt页生成讲解任务执行\n     * @param userPptId ppt标识\n     * @param page 页码\n     * @param slide ppt页对象\n     */\n    @Transactional\n    public void taskExec(Integer userPptId, Integer page,XSLFSlide slide)\n    {\n        UserPptDetailDO userPptDetailDO = userPptDetailMapper.selectOne(new LambdaQueryWrapper<UserPptDetailDO>()\n                .eq(UserPptDetailDO::getUserPptId, userPptId)\n                .eq(UserPptDetailDO::getPptPage, page));\n        if(Objects.isNull(userPptDetailDO))\n        {\n            userPptDetailDO = new UserPptDetailDO();\n            userPptDetailDO.setUserPptId(userPptId);\n            userPptDetailDO.setPptPage(page);\n            userPptDetailDO.setCreateTime(LocalDateTime.now());\n            userPptDetailMapper.insert(userPptDetailDO);\n        }\n        TaskDO taskDO = new TaskDO();\n        PPTPageSummaryTaskDTO pptPageSummaryTaskDTO = new PPTPageSummaryTaskDTO();\n        pptPageSummaryTaskDTO.setUserPptId(userPptId);\n        pptPageSummaryTaskDTO.setPage(page);\n        pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));\n        taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));\n        taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());\n        taskDO.setUpdateTime(LocalDateTime.now());\n        taskDO.setCreateTime(LocalDateTime.now());\n        taskDO.setStatus(TaskStatusEnum.CREATED.getCode());\n        taskMapper.insert(taskDO);\n        //todo mq发消息调python\n        userPptDetailDO.setLastTaskId(taskDO.getId());\n        userPptDetailMapper.updateById(userPptDetailDO);\n    }\n}\n```\n\n在经过测试后，发现用线程池比直接串行提高了50%的响应速度\n\n![](C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-16-5c6007f39b59c4cbfc9145882bbfe6e.png)\n\n![](C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-07-eb8ebdc2c9b56dacd1150e7073ea2e6.png)\n\n> 线程池参数如下：\n\n```java\n\n```\n","source":"_posts/ai语音合成项目中线程池优化ppt每一页任务执行.md","raw":"---\ntitle: ai语音合成项目中线程池优化ppt每一页任务执行\ndate: 2025-01-15 21:55:44\ntags: 线程池\ncategories: 业务场景\n---\n\n**在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。**\n\n这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。\n\n```java\npackage com.soundmentor.soundmentorweb.service.impl;\n\nimport com.alibaba.fastjson.JSON;\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.soundmentor.soundmentorbase.enums.TaskStatusEnum;\nimport com.soundmentor.soundmentorbase.enums.TaskTypeEnum;\nimport com.soundmentor.soundmentorbase.utils.PPTXUtil;\nimport com.soundmentor.soundmentorpojo.DO.TaskDO;\nimport com.soundmentor.soundmentorpojo.DO.UserPptDetailDO;\nimport com.soundmentor.soundmentorpojo.DO.UserPptRelDO;\nimport com.soundmentor.soundmentorpojo.DTO.ppt.PPTPageSummaryTaskDTO;\nimport com.soundmentor.soundmentorpojo.DTO.task.CreatePPTSummaryTaskParam;\nimport com.soundmentor.soundmentorweb.mapper.TaskMapper;\nimport com.soundmentor.soundmentorweb.mapper.UserPptDetailMapper;\nimport com.soundmentor.soundmentorweb.mapper.UserPptRelMapper;\nimport com.soundmentor.soundmentorweb.service.PPTService;\nimport com.soundmentor.soundmentorweb.service.UserInfoApi;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.poi.xslf.usermodel.XMLSlideShow;\nimport org.apache.poi.xslf.usermodel.XSLFSlide;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.dao.DuplicateKeyException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport javax.annotation.Resource;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.ThreadPoolExecutor;\n\n@Service\n@Slf4j\n\npublic class PPTServiceImpl implements PPTService {\n    @Resource\n    private  UserPptDetailMapper userPptDetailMapper;\n    @Resource\n    private  UserPptRelMapper userPptRelMapper;\n    @Resource\n    private  UserInfoApi userInfoApi;\n    @Resource(name = \"task-thread-pool-executor\")\n    private  ThreadPoolExecutor threadPoolExecutor;\n    @Autowired\n    private TaskMapper taskMapper;\n\n    @Override\n    public Integer createPPTSummary(CreatePPTSummaryTaskParam param) {\n        String pptUrl = param.getPptUrl();\n        XMLSlideShow xmlSlideShow = PPTXUtil.loadPPTX(pptUrl);\n        List<XSLFSlide> slides = xmlSlideShow.getSlides();\n        UserPptRelDO userPptRelDO = userPptRelMapper.selectOne(new LambdaQueryWrapper<UserPptRelDO>()\n                .eq(UserPptRelDO::getPptUrl, pptUrl)\n                .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));\n        if (Objects.isNull(userPptRelDO))\n        {\n            userPptRelDO = new UserPptRelDO();\n            userPptRelDO.setPptUrl(pptUrl);\n            userPptRelDO.setUserId(userInfoApi.getUser().getId());\n            userPptRelDO.setPageCount(slides.size());\n            userPptRelDO.setCreateTime(LocalDateTime.now());\n            userPptRelMapper.insert(userPptRelDO);\n        }\n        for (int i = 0; i < slides.size(); i++) {\n            Integer userPptId = userPptRelDO.getId();\n            Integer page = i;\n            XSLFSlide slide = slides.get(page);\n            threadPoolExecutor.execute(()->{\n                try {\n                    taskExec(userPptId,page,slide);\n                } catch (Exception e) {\n                    log.error(\"ppt{}的{}页任务执行失败,请重试\",userPptId,page);\n                }\n            });\n        }\n        return userPptRelDO.getId();\n    }\n\n    /**\n     * ppt页生成讲解任务执行\n     * @param userPptId ppt标识\n     * @param page 页码\n     * @param slide ppt页对象\n     */\n    @Transactional\n    public void taskExec(Integer userPptId, Integer page,XSLFSlide slide)\n    {\n        UserPptDetailDO userPptDetailDO = userPptDetailMapper.selectOne(new LambdaQueryWrapper<UserPptDetailDO>()\n                .eq(UserPptDetailDO::getUserPptId, userPptId)\n                .eq(UserPptDetailDO::getPptPage, page));\n        if(Objects.isNull(userPptDetailDO))\n        {\n            userPptDetailDO = new UserPptDetailDO();\n            userPptDetailDO.setUserPptId(userPptId);\n            userPptDetailDO.setPptPage(page);\n            userPptDetailDO.setCreateTime(LocalDateTime.now());\n            userPptDetailMapper.insert(userPptDetailDO);\n        }\n        TaskDO taskDO = new TaskDO();\n        PPTPageSummaryTaskDTO pptPageSummaryTaskDTO = new PPTPageSummaryTaskDTO();\n        pptPageSummaryTaskDTO.setUserPptId(userPptId);\n        pptPageSummaryTaskDTO.setPage(page);\n        pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));\n        taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));\n        taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());\n        taskDO.setUpdateTime(LocalDateTime.now());\n        taskDO.setCreateTime(LocalDateTime.now());\n        taskDO.setStatus(TaskStatusEnum.CREATED.getCode());\n        taskMapper.insert(taskDO);\n        //todo mq发消息调python\n        userPptDetailDO.setLastTaskId(taskDO.getId());\n        userPptDetailMapper.updateById(userPptDetailDO);\n    }\n}\n```\n\n在经过测试后，发现用线程池比直接串行提高了50%的响应速度\n\n![](C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-16-5c6007f39b59c4cbfc9145882bbfe6e.png)\n\n![](C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-07-eb8ebdc2c9b56dacd1150e7073ea2e6.png)\n\n> 线程池参数如下：\n\n```java\n\n```\n","slug":"ai语音合成项目中线程池优化ppt每一页任务执行","published":1,"updated":"2025-01-16T12:41:27.907Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1q00053ga8f6vc3lf2","content":"<p><strong>在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。</strong></p>\n<p>这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.soundmentor.soundmentorweb.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorbase.enums.TaskStatusEnum;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorbase.enums.TaskTypeEnum;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorbase.utils.PPTXUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DO.TaskDO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DO.UserPptDetailDO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DO.UserPptRelDO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DTO.ppt.PPTPageSummaryTaskDTO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DTO.task.CreatePPTSummaryTaskParam;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.mapper.TaskMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.mapper.UserPptDetailMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.mapper.UserPptRelMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.service.PPTService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.service.UserInfoApi;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.poi.xslf.usermodel.XMLSlideShow;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.poi.xslf.usermodel.XSLFSlide;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.dao.DuplicateKeyException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDateTime;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PPTServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">PPTService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  UserPptDetailMapper userPptDetailMapper;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  UserPptRelMapper userPptRelMapper;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  UserInfoApi userInfoApi;</span><br><span class=\"line\">    <span class=\"meta\">@Resource(name = &quot;task-thread-pool-executor&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  ThreadPoolExecutor threadPoolExecutor;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TaskMapper taskMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">createPPTSummary</span><span class=\"params\">(CreatePPTSummaryTaskParam param)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">pptUrl</span> <span class=\"operator\">=</span> param.getPptUrl();</span><br><span class=\"line\">        <span class=\"type\">XMLSlideShow</span> <span class=\"variable\">xmlSlideShow</span> <span class=\"operator\">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class=\"line\">        List&lt;XSLFSlide&gt; slides = xmlSlideShow.getSlides();</span><br><span class=\"line\">        <span class=\"type\">UserPptRelDO</span> <span class=\"variable\">userPptRelDO</span> <span class=\"operator\">=</span> userPptRelMapper.selectOne(<span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryWrapper</span>&lt;UserPptRelDO&gt;()</span><br><span class=\"line\">                .eq(UserPptRelDO::getPptUrl, pptUrl)</span><br><span class=\"line\">                .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.isNull(userPptRelDO))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            userPptRelDO = <span class=\"keyword\">new</span> <span class=\"title class_\">UserPptRelDO</span>();</span><br><span class=\"line\">            userPptRelDO.setPptUrl(pptUrl);</span><br><span class=\"line\">            userPptRelDO.setUserId(userInfoApi.getUser().getId());</span><br><span class=\"line\">            userPptRelDO.setPageCount(slides.size());</span><br><span class=\"line\">            userPptRelDO.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">            userPptRelMapper.insert(userPptRelDO);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; slides.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Integer</span> <span class=\"variable\">userPptId</span> <span class=\"operator\">=</span> userPptRelDO.getId();</span><br><span class=\"line\">            <span class=\"type\">Integer</span> <span class=\"variable\">page</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"type\">XSLFSlide</span> <span class=\"variable\">slide</span> <span class=\"operator\">=</span> slides.get(page);</span><br><span class=\"line\">            threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    taskExec(userPptId,page,slide);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptId,page);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userPptRelDO.getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ppt页生成讲解任务执行</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userPptId ppt标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> page 页码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> slide ppt页对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">taskExec</span><span class=\"params\">(Integer userPptId, Integer page,XSLFSlide slide)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">UserPptDetailDO</span> <span class=\"variable\">userPptDetailDO</span> <span class=\"operator\">=</span> userPptDetailMapper.selectOne(<span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class=\"line\">                .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class=\"line\">                .eq(UserPptDetailDO::getPptPage, page));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Objects.isNull(userPptDetailDO))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            userPptDetailDO = <span class=\"keyword\">new</span> <span class=\"title class_\">UserPptDetailDO</span>();</span><br><span class=\"line\">            userPptDetailDO.setUserPptId(userPptId);</span><br><span class=\"line\">            userPptDetailDO.setPptPage(page);</span><br><span class=\"line\">            userPptDetailDO.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">            userPptDetailMapper.insert(userPptDetailDO);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TaskDO</span> <span class=\"variable\">taskDO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TaskDO</span>();</span><br><span class=\"line\">        <span class=\"type\">PPTPageSummaryTaskDTO</span> <span class=\"variable\">pptPageSummaryTaskDTO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PPTPageSummaryTaskDTO</span>();</span><br><span class=\"line\">        pptPageSummaryTaskDTO.setUserPptId(userPptId);</span><br><span class=\"line\">        pptPageSummaryTaskDTO.setPage(page);</span><br><span class=\"line\">        pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));</span><br><span class=\"line\">        taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));</span><br><span class=\"line\">        taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class=\"line\">        taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class=\"line\">        taskDO.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">        taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class=\"line\">        taskMapper.insert(taskDO);</span><br><span class=\"line\">        <span class=\"comment\">//todo mq发消息调python</span></span><br><span class=\"line\">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class=\"line\">        userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在经过测试后，发现用线程池比直接串行提高了50%的响应速度</p>\n<p><img src=\"C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-16-5c6007f39b59c4cbfc9145882bbfe6e.png\"></p>\n<p><img src=\"C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-07-eb8ebdc2c9b56dacd1150e7073ea2e6.png\"></p>\n<blockquote>\n<p>线程池参数如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","cover":false,"excerpt":"","more":"<p><strong>在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。</strong></p>\n<p>这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.soundmentor.soundmentorweb.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.fastjson.JSON;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorbase.enums.TaskStatusEnum;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorbase.enums.TaskTypeEnum;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorbase.utils.PPTXUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DO.TaskDO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DO.UserPptDetailDO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DO.UserPptRelDO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DTO.ppt.PPTPageSummaryTaskDTO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorpojo.DTO.task.CreatePPTSummaryTaskParam;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.mapper.TaskMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.mapper.UserPptDetailMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.mapper.UserPptRelMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.service.PPTService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.soundmentor.soundmentorweb.service.UserInfoApi;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.poi.xslf.usermodel.XMLSlideShow;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.poi.xslf.usermodel.XSLFSlide;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.dao.DuplicateKeyException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDateTime;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PPTServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">PPTService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  UserPptDetailMapper userPptDetailMapper;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  UserPptRelMapper userPptRelMapper;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  UserInfoApi userInfoApi;</span><br><span class=\"line\">    <span class=\"meta\">@Resource(name = &quot;task-thread-pool-executor&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  ThreadPoolExecutor threadPoolExecutor;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TaskMapper taskMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">createPPTSummary</span><span class=\"params\">(CreatePPTSummaryTaskParam param)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">pptUrl</span> <span class=\"operator\">=</span> param.getPptUrl();</span><br><span class=\"line\">        <span class=\"type\">XMLSlideShow</span> <span class=\"variable\">xmlSlideShow</span> <span class=\"operator\">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class=\"line\">        List&lt;XSLFSlide&gt; slides = xmlSlideShow.getSlides();</span><br><span class=\"line\">        <span class=\"type\">UserPptRelDO</span> <span class=\"variable\">userPptRelDO</span> <span class=\"operator\">=</span> userPptRelMapper.selectOne(<span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryWrapper</span>&lt;UserPptRelDO&gt;()</span><br><span class=\"line\">                .eq(UserPptRelDO::getPptUrl, pptUrl)</span><br><span class=\"line\">                .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.isNull(userPptRelDO))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            userPptRelDO = <span class=\"keyword\">new</span> <span class=\"title class_\">UserPptRelDO</span>();</span><br><span class=\"line\">            userPptRelDO.setPptUrl(pptUrl);</span><br><span class=\"line\">            userPptRelDO.setUserId(userInfoApi.getUser().getId());</span><br><span class=\"line\">            userPptRelDO.setPageCount(slides.size());</span><br><span class=\"line\">            userPptRelDO.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">            userPptRelMapper.insert(userPptRelDO);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; slides.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Integer</span> <span class=\"variable\">userPptId</span> <span class=\"operator\">=</span> userPptRelDO.getId();</span><br><span class=\"line\">            <span class=\"type\">Integer</span> <span class=\"variable\">page</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">            <span class=\"type\">XSLFSlide</span> <span class=\"variable\">slide</span> <span class=\"operator\">=</span> slides.get(page);</span><br><span class=\"line\">            threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    taskExec(userPptId,page,slide);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptId,page);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userPptRelDO.getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ppt页生成讲解任务执行</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userPptId ppt标识</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> page 页码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> slide ppt页对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">taskExec</span><span class=\"params\">(Integer userPptId, Integer page,XSLFSlide slide)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">UserPptDetailDO</span> <span class=\"variable\">userPptDetailDO</span> <span class=\"operator\">=</span> userPptDetailMapper.selectOne(<span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class=\"line\">                .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class=\"line\">                .eq(UserPptDetailDO::getPptPage, page));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Objects.isNull(userPptDetailDO))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            userPptDetailDO = <span class=\"keyword\">new</span> <span class=\"title class_\">UserPptDetailDO</span>();</span><br><span class=\"line\">            userPptDetailDO.setUserPptId(userPptId);</span><br><span class=\"line\">            userPptDetailDO.setPptPage(page);</span><br><span class=\"line\">            userPptDetailDO.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">            userPptDetailMapper.insert(userPptDetailDO);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TaskDO</span> <span class=\"variable\">taskDO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TaskDO</span>();</span><br><span class=\"line\">        <span class=\"type\">PPTPageSummaryTaskDTO</span> <span class=\"variable\">pptPageSummaryTaskDTO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PPTPageSummaryTaskDTO</span>();</span><br><span class=\"line\">        pptPageSummaryTaskDTO.setUserPptId(userPptId);</span><br><span class=\"line\">        pptPageSummaryTaskDTO.setPage(page);</span><br><span class=\"line\">        pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));</span><br><span class=\"line\">        taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));</span><br><span class=\"line\">        taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class=\"line\">        taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class=\"line\">        taskDO.setCreateTime(LocalDateTime.now());</span><br><span class=\"line\">        taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class=\"line\">        taskMapper.insert(taskDO);</span><br><span class=\"line\">        <span class=\"comment\">//todo mq发消息调python</span></span><br><span class=\"line\">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class=\"line\">        userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在经过测试后，发现用线程池比直接串行提高了50%的响应速度</p>\n<p><img src=\"C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-16-5c6007f39b59c4cbfc9145882bbfe6e.png\"></p>\n<p><img src=\"C:\\Users\\DELL\\AppData\\Roaming\\marktext\\images\\2025-01-15-22-14-07-eb8ebdc2c9b56dacd1150e7073ea2e6.png\"></p>\n<blockquote>\n<p>线程池参数如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"gradle构建java项目时乱码问题解决方案","date":"2024-10-11T14:25:16.000Z","_content":"\n# gradle构建java项目时乱码问题解决方案\n\n今天在公司接到了一个需求，项目是用gradle构建的，因为之前从来没用过gradle，第一次用发现在构建的时候一直输出乱码,并且构建失败,最后找到了解决方案。\n\n如果项目是用UTF-8编码编写的那么应该使用UTF-8编码构建项目。\n\n解决方法如下：\n\n1. idea点击帮助=>编辑自定义虚拟机选项\n\n2. 添加代码`-Dfile.encoding=UTF-8`\n\n3. 重启idea\n\n重新构建gradle项目观察日志输出没有乱码即可\n","source":"_posts/gradle构建java项目时乱码问题解决方案.md","raw":"---\ntitle: gradle构建java项目时乱码问题解决方案\ndate: 2024-10-11 22:25:16\ntags: gradle\ncategories: 业务场景 \n---\n\n# gradle构建java项目时乱码问题解决方案\n\n今天在公司接到了一个需求，项目是用gradle构建的，因为之前从来没用过gradle，第一次用发现在构建的时候一直输出乱码,并且构建失败,最后找到了解决方案。\n\n如果项目是用UTF-8编码编写的那么应该使用UTF-8编码构建项目。\n\n解决方法如下：\n\n1. idea点击帮助=>编辑自定义虚拟机选项\n\n2. 添加代码`-Dfile.encoding=UTF-8`\n\n3. 重启idea\n\n重新构建gradle项目观察日志输出没有乱码即可\n","slug":"gradle构建java项目时乱码问题解决方案","published":1,"updated":"2024-12-24T14:26:29.245Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1r00063ga80kmfhdaf","content":"<h1 id=\"gradle构建java项目时乱码问题解决方案\"><a href=\"#gradle构建java项目时乱码问题解决方案\" class=\"headerlink\" title=\"gradle构建java项目时乱码问题解决方案\"></a>gradle构建java项目时乱码问题解决方案</h1><p>今天在公司接到了一个需求，项目是用gradle构建的，因为之前从来没用过gradle，第一次用发现在构建的时候一直输出乱码,并且构建失败,最后找到了解决方案。</p>\n<p>如果项目是用UTF-8编码编写的那么应该使用UTF-8编码构建项目。</p>\n<p>解决方法如下：</p>\n<ol>\n<li><p>idea点击帮助&#x3D;&gt;编辑自定义虚拟机选项</p>\n</li>\n<li><p>添加代码<code>-Dfile.encoding=UTF-8</code></p>\n</li>\n<li><p>重启idea</p>\n</li>\n</ol>\n<p>重新构建gradle项目观察日志输出没有乱码即可</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"gradle构建java项目时乱码问题解决方案\"><a href=\"#gradle构建java项目时乱码问题解决方案\" class=\"headerlink\" title=\"gradle构建java项目时乱码问题解决方案\"></a>gradle构建java项目时乱码问题解决方案</h1><p>今天在公司接到了一个需求，项目是用gradle构建的，因为之前从来没用过gradle，第一次用发现在构建的时候一直输出乱码,并且构建失败,最后找到了解决方案。</p>\n<p>如果项目是用UTF-8编码编写的那么应该使用UTF-8编码构建项目。</p>\n<p>解决方法如下：</p>\n<ol>\n<li><p>idea点击帮助&#x3D;&gt;编辑自定义虚拟机选项</p>\n</li>\n<li><p>添加代码<code>-Dfile.encoding=UTF-8</code></p>\n</li>\n<li><p>重启idea</p>\n</li>\n</ol>\n<p>重新构建gradle项目观察日志输出没有乱码即可</p>\n"},{"title":"java中Atomic原子类型","date":"2024-10-15T06:19:12.000Z","_content":"\n​\n\n# Java中atomic原子类型\n\n原子类型是 Java 中用于支持多线程并发编程的类型，属于 `java.util.concurrent.atomic` 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。\n\n## 常见的原子类型：\n\n- `AtomicBoolean`\n\n- `AtomicInteger`\n\n- `AtomicLong`\n\n- `AtomicReference<T>`\n\n## 原子类型的特性：\n\n- 支持无锁的线程安全操作，避免使用 `synchronized` 或显式锁。\n- 提供了常见的原子操作，如 `get()`、`set()`、`compareAndSet()`、`incrementAndGet()` 等。\n\n## 以AtomicInteger为例，解析原子类型的特性：\n\n一些常见的 `AtomicInteger` 方法包括：\n\n1. `get()`：获取当前值。\n2. `set(int newValue)`：设置为指定值。\n3. `getAndIncrement()`：先获取当前值，然后递增。\n4. `incrementAndGet()`：先递增，然后获取当前值。\n5. `compareAndSet(int expect, int update)`：如果当前值等于 `expect`，则将值设置为 `update`。\n\n参考源码可知：\n\n通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。\n\n示例代码：\n\n```\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicIntegerExample {\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(0);\n\n        // 递增并获取值\n        System.out.println(atomicInteger.incrementAndGet()); // 输出 1\n\n        // 获取并递增值\n        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2\n\n        // 比较并设置值\n        boolean result = atomicInteger.compareAndSet(2, 5);\n        System.out.println(result); // 输出 true，因为当前值是 2\n        System.out.println(atomicInteger.get()); // 输出 5\n    }\n}\n```\n\n![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== \"点击并拖拽以移动\")\n\n通过 `AtomicInteger`，你可以避免使用 `synchronized` 关键字或手动管理锁，简化了多线程操作。\n\n​\n","source":"_posts/java中Atomic原子类型.md","raw":"---\ntitle: java中Atomic原子类型\ndate: 2024-10-15 14:19:12\ntags: java基础\ncategories: 八股文\n---\n\n​\n\n# Java中atomic原子类型\n\n原子类型是 Java 中用于支持多线程并发编程的类型，属于 `java.util.concurrent.atomic` 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。\n\n## 常见的原子类型：\n\n- `AtomicBoolean`\n\n- `AtomicInteger`\n\n- `AtomicLong`\n\n- `AtomicReference<T>`\n\n## 原子类型的特性：\n\n- 支持无锁的线程安全操作，避免使用 `synchronized` 或显式锁。\n- 提供了常见的原子操作，如 `get()`、`set()`、`compareAndSet()`、`incrementAndGet()` 等。\n\n## 以AtomicInteger为例，解析原子类型的特性：\n\n一些常见的 `AtomicInteger` 方法包括：\n\n1. `get()`：获取当前值。\n2. `set(int newValue)`：设置为指定值。\n3. `getAndIncrement()`：先获取当前值，然后递增。\n4. `incrementAndGet()`：先递增，然后获取当前值。\n5. `compareAndSet(int expect, int update)`：如果当前值等于 `expect`，则将值设置为 `update`。\n\n参考源码可知：\n\n通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。\n\n示例代码：\n\n```\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicIntegerExample {\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(0);\n\n        // 递增并获取值\n        System.out.println(atomicInteger.incrementAndGet()); // 输出 1\n\n        // 获取并递增值\n        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2\n\n        // 比较并设置值\n        boolean result = atomicInteger.compareAndSet(2, 5);\n        System.out.println(result); // 输出 true，因为当前值是 2\n        System.out.println(atomicInteger.get()); // 输出 5\n    }\n}\n```\n\n![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== \"点击并拖拽以移动\")\n\n通过 `AtomicInteger`，你可以避免使用 `synchronized` 关键字或手动管理锁，简化了多线程操作。\n\n​\n","slug":"java中Atomic原子类型","published":1,"updated":"2024-12-14T07:48:36.139Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1r00073ga889c915r6","content":"<p>​</p>\n<h1 id=\"Java中atomic原子类型\"><a href=\"#Java中atomic原子类型\" class=\"headerlink\" title=\"Java中atomic原子类型\"></a>Java中atomic原子类型</h1><p>原子类型是 Java 中用于支持多线程并发编程的类型，属于 <code>java.util.concurrent.atomic</code> 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。</p>\n<h2 id=\"常见的原子类型：\"><a href=\"#常见的原子类型：\" class=\"headerlink\" title=\"常见的原子类型：\"></a>常见的原子类型：</h2><ul>\n<li><p><code>AtomicBoolean</code></p>\n</li>\n<li><p><code>AtomicInteger</code></p>\n</li>\n<li><p><code>AtomicLong</code></p>\n</li>\n<li><p><code>AtomicReference&lt;T&gt;</code></p>\n</li>\n</ul>\n<h2 id=\"原子类型的特性：\"><a href=\"#原子类型的特性：\" class=\"headerlink\" title=\"原子类型的特性：\"></a>原子类型的特性：</h2><ul>\n<li>支持无锁的线程安全操作，避免使用 <code>synchronized</code> 或显式锁。</li>\n<li>提供了常见的原子操作，如 <code>get()</code>、<code>set()</code>、<code>compareAndSet()</code>、<code>incrementAndGet()</code> 等。</li>\n</ul>\n<h2 id=\"以AtomicInteger为例，解析原子类型的特性：\"><a href=\"#以AtomicInteger为例，解析原子类型的特性：\" class=\"headerlink\" title=\"以AtomicInteger为例，解析原子类型的特性：\"></a>以AtomicInteger为例，解析原子类型的特性：</h2><p>一些常见的 <code>AtomicInteger</code> 方法包括：</p>\n<ol>\n<li><code>get()</code>：获取当前值。</li>\n<li><code>set(int newValue)</code>：设置为指定值。</li>\n<li><code>getAndIncrement()</code>：先获取当前值，然后递增。</li>\n<li><code>incrementAndGet()</code>：先递增，然后获取当前值。</li>\n<li><code>compareAndSet(int expect, int update)</code>：如果当前值等于 <code>expect</code>，则将值设置为 <code>update</code>。</li>\n</ol>\n<p>参考源码可知：</p>\n<p>通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。</p>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AtomicIntegerExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 递增并获取值</span><br><span class=\"line\">        System.out.println(atomicInteger.incrementAndGet()); // 输出 1</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取并递增值</span><br><span class=\"line\">        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2</span><br><span class=\"line\"></span><br><span class=\"line\">        // 比较并设置值</span><br><span class=\"line\">        boolean result = atomicInteger.compareAndSet(2, 5);</span><br><span class=\"line\">        System.out.println(result); // 输出 true，因为当前值是 2</span><br><span class=\"line\">        System.out.println(atomicInteger.get()); // 输出 5</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\" title=\"点击并拖拽以移动\"></p>\n<p>通过 <code>AtomicInteger</code>，你可以避免使用 <code>synchronized</code> 关键字或手动管理锁，简化了多线程操作。</p>\n<p>​</p>\n","cover":false,"excerpt":"","more":"<p>​</p>\n<h1 id=\"Java中atomic原子类型\"><a href=\"#Java中atomic原子类型\" class=\"headerlink\" title=\"Java中atomic原子类型\"></a>Java中atomic原子类型</h1><p>原子类型是 Java 中用于支持多线程并发编程的类型，属于 <code>java.util.concurrent.atomic</code> 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。</p>\n<h2 id=\"常见的原子类型：\"><a href=\"#常见的原子类型：\" class=\"headerlink\" title=\"常见的原子类型：\"></a>常见的原子类型：</h2><ul>\n<li><p><code>AtomicBoolean</code></p>\n</li>\n<li><p><code>AtomicInteger</code></p>\n</li>\n<li><p><code>AtomicLong</code></p>\n</li>\n<li><p><code>AtomicReference&lt;T&gt;</code></p>\n</li>\n</ul>\n<h2 id=\"原子类型的特性：\"><a href=\"#原子类型的特性：\" class=\"headerlink\" title=\"原子类型的特性：\"></a>原子类型的特性：</h2><ul>\n<li>支持无锁的线程安全操作，避免使用 <code>synchronized</code> 或显式锁。</li>\n<li>提供了常见的原子操作，如 <code>get()</code>、<code>set()</code>、<code>compareAndSet()</code>、<code>incrementAndGet()</code> 等。</li>\n</ul>\n<h2 id=\"以AtomicInteger为例，解析原子类型的特性：\"><a href=\"#以AtomicInteger为例，解析原子类型的特性：\" class=\"headerlink\" title=\"以AtomicInteger为例，解析原子类型的特性：\"></a>以AtomicInteger为例，解析原子类型的特性：</h2><p>一些常见的 <code>AtomicInteger</code> 方法包括：</p>\n<ol>\n<li><code>get()</code>：获取当前值。</li>\n<li><code>set(int newValue)</code>：设置为指定值。</li>\n<li><code>getAndIncrement()</code>：先获取当前值，然后递增。</li>\n<li><code>incrementAndGet()</code>：先递增，然后获取当前值。</li>\n<li><code>compareAndSet(int expect, int update)</code>：如果当前值等于 <code>expect</code>，则将值设置为 <code>update</code>。</li>\n</ol>\n<p>参考源码可知：</p>\n<p>通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。</p>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AtomicIntegerExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 递增并获取值</span><br><span class=\"line\">        System.out.println(atomicInteger.incrementAndGet()); // 输出 1</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取并递增值</span><br><span class=\"line\">        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2</span><br><span class=\"line\"></span><br><span class=\"line\">        // 比较并设置值</span><br><span class=\"line\">        boolean result = atomicInteger.compareAndSet(2, 5);</span><br><span class=\"line\">        System.out.println(result); // 输出 true，因为当前值是 2</span><br><span class=\"line\">        System.out.println(atomicInteger.get()); // 输出 5</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\" title=\"点击并拖拽以移动\"></p>\n<p>通过 <code>AtomicInteger</code>，你可以避免使用 <code>synchronized</code> 关键字或手动管理锁，简化了多线程操作。</p>\n<p>​</p>\n"},{"title":"java的bigdecimal是怎么解决精度丢失的","date":"2025-01-14T06:48:38.000Z","_content":"\njava的bigdecimal是怎么解决精度丢失的\n\n在 Java 中，`BigDecimal` 是专门用来处理高精度计算的类，它可以避免像 `float` 和 `double` 这类浮点数在计算时可能产生的精度丢失问题。这是因为 `BigDecimal` 采用了 **定点数表示法**，而不是浮点数的近似计算方法。\n\n### 工作原理\n\n1. **使用字符串或整数表示数值：**\n   \n   - `BigDecimal` 内部通过一个 `BigInteger` 表示数值部分（即不带小数点的整数部分）。\n   - 小数点的位置通过一个 `int` 类型的标度（scale）来表示。\n   \n   例如：\n   \n   ```java\n   BigDecimal value = new BigDecimal(\"123.45\");\n   // 内部表示：\n   // 数值部分：12345（BigInteger）\n   // 标度：2（表示小数点后有2位小数）\n   ```\n\n2. **避免二进制浮点数的误差：**\n   \n   - 浮点数如 `double` 在底层以二进制存储，许多十进制的小数（如 0.1）无法用二进制精确表示，导致计算时可能出现误差。\n   - `BigDecimal` 避免了这种情况，因为它直接操作十进制的数值。\n\n3. **支持精确的数学运算：**\n   \n   - `BigDecimal` 的加、减、乘、除等操作都使用精确的算法进行计算。\n   - 在除法时，可以通过设置舍入模式（`RoundingMode`）来指定如何处理可能存在的无限小数。\n\n### 示例\n\n以下是 `BigDecimal` 避免精度丢失的一个简单例子：\n\n```java\npublic class BigDecimalExample {\n    public static void main(String[] args) {\n        // 浮点数精度丢失\n        double d1 = 0.1;\n        double d2 = 0.2;\n        System.out.println(d1 + d2); // 输出可能为 0.30000000000000004\n\n        // 使用 BigDecimal\n        BigDecimal bd1 = new BigDecimal(\"0.1\");\n        BigDecimal bd2 = new BigDecimal(\"0.2\");\n        BigDecimal result = bd1.add(bd2);\n        System.out.println(result); // 输出 0.3\n    }\n}\n```\n\n### 重要注意事项\n\n1. **不要直接使用 `double` 初始化：**\n   \n   ```java\n   BigDecimal bd = new BigDecimal(0.1); // 会引入浮点数的精度问题\n   ```\n   \n   推荐使用字符串或 `BigDecimal.valueOf(double)`：\n   \n   ```java\n   BigDecimal bd = new BigDecimal(\"0.1\");\n   // 或\n   BigDecimal bd = BigDecimal.valueOf(0.1);\n   ```\n\n2. **控制除法的精度：** 对于除法运算，可能会出现无限小数的情况，需要指定精度和舍入模式：\n   \n   ```java\n   BigDecimal bd1 = new BigDecimal(\"1\");\n   BigDecimal bd2 = new BigDecimal(\"3\");\n   BigDecimal result = bd1.divide(bd2, 5, RoundingMode.HALF_UP); // 保留5位小数\n   System.out.println(result); // 输出 0.33333\n   ```\n\n### 总结\n\n`BigDecimal` 的高精度计算是通过以字符串或整数形式存储数值和标度来实现的，避免了浮点数的二进制近似问题。在需要精确计算的场景（如金融、科学计算）中非常适用，但由于计算性能相对较低，在性能敏感的场景中需要慎用。\n","source":"_posts/java的bigdecimal是怎么解决精度丢失的.md","raw":"---\ntitle: java的bigdecimal是怎么解决精度丢失的\ndate: 2025-01-14 14:48:38\ntags: java\ncategories: 面试\n---\n\njava的bigdecimal是怎么解决精度丢失的\n\n在 Java 中，`BigDecimal` 是专门用来处理高精度计算的类，它可以避免像 `float` 和 `double` 这类浮点数在计算时可能产生的精度丢失问题。这是因为 `BigDecimal` 采用了 **定点数表示法**，而不是浮点数的近似计算方法。\n\n### 工作原理\n\n1. **使用字符串或整数表示数值：**\n   \n   - `BigDecimal` 内部通过一个 `BigInteger` 表示数值部分（即不带小数点的整数部分）。\n   - 小数点的位置通过一个 `int` 类型的标度（scale）来表示。\n   \n   例如：\n   \n   ```java\n   BigDecimal value = new BigDecimal(\"123.45\");\n   // 内部表示：\n   // 数值部分：12345（BigInteger）\n   // 标度：2（表示小数点后有2位小数）\n   ```\n\n2. **避免二进制浮点数的误差：**\n   \n   - 浮点数如 `double` 在底层以二进制存储，许多十进制的小数（如 0.1）无法用二进制精确表示，导致计算时可能出现误差。\n   - `BigDecimal` 避免了这种情况，因为它直接操作十进制的数值。\n\n3. **支持精确的数学运算：**\n   \n   - `BigDecimal` 的加、减、乘、除等操作都使用精确的算法进行计算。\n   - 在除法时，可以通过设置舍入模式（`RoundingMode`）来指定如何处理可能存在的无限小数。\n\n### 示例\n\n以下是 `BigDecimal` 避免精度丢失的一个简单例子：\n\n```java\npublic class BigDecimalExample {\n    public static void main(String[] args) {\n        // 浮点数精度丢失\n        double d1 = 0.1;\n        double d2 = 0.2;\n        System.out.println(d1 + d2); // 输出可能为 0.30000000000000004\n\n        // 使用 BigDecimal\n        BigDecimal bd1 = new BigDecimal(\"0.1\");\n        BigDecimal bd2 = new BigDecimal(\"0.2\");\n        BigDecimal result = bd1.add(bd2);\n        System.out.println(result); // 输出 0.3\n    }\n}\n```\n\n### 重要注意事项\n\n1. **不要直接使用 `double` 初始化：**\n   \n   ```java\n   BigDecimal bd = new BigDecimal(0.1); // 会引入浮点数的精度问题\n   ```\n   \n   推荐使用字符串或 `BigDecimal.valueOf(double)`：\n   \n   ```java\n   BigDecimal bd = new BigDecimal(\"0.1\");\n   // 或\n   BigDecimal bd = BigDecimal.valueOf(0.1);\n   ```\n\n2. **控制除法的精度：** 对于除法运算，可能会出现无限小数的情况，需要指定精度和舍入模式：\n   \n   ```java\n   BigDecimal bd1 = new BigDecimal(\"1\");\n   BigDecimal bd2 = new BigDecimal(\"3\");\n   BigDecimal result = bd1.divide(bd2, 5, RoundingMode.HALF_UP); // 保留5位小数\n   System.out.println(result); // 输出 0.33333\n   ```\n\n### 总结\n\n`BigDecimal` 的高精度计算是通过以字符串或整数形式存储数值和标度来实现的，避免了浮点数的二进制近似问题。在需要精确计算的场景（如金融、科学计算）中非常适用，但由于计算性能相对较低，在性能敏感的场景中需要慎用。\n","slug":"java的bigdecimal是怎么解决精度丢失的","published":1,"updated":"2025-01-14T06:50:53.466Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1s000b3ga8bou8emgg","content":"<p>java的bigdecimal是怎么解决精度丢失的</p>\n<p>在 Java 中，<code>BigDecimal</code> 是专门用来处理高精度计算的类，它可以避免像 <code>float</code> 和 <code>double</code> 这类浮点数在计算时可能产生的精度丢失问题。这是因为 <code>BigDecimal</code> 采用了 <strong>定点数表示法</strong>，而不是浮点数的近似计算方法。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ol>\n<li><p><strong>使用字符串或整数表示数值：</strong></p>\n<ul>\n<li><code>BigDecimal</code> 内部通过一个 <code>BigInteger</code> 表示数值部分（即不带小数点的整数部分）。</li>\n<li>小数点的位置通过一个 <code>int</code> 类型的标度（scale）来表示。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;123.45&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 内部表示：</span></span><br><span class=\"line\"><span class=\"comment\">// 数值部分：12345（BigInteger）</span></span><br><span class=\"line\"><span class=\"comment\">// 标度：2（表示小数点后有2位小数）</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>避免二进制浮点数的误差：</strong></p>\n<ul>\n<li>浮点数如 <code>double</code> 在底层以二进制存储，许多十进制的小数（如 0.1）无法用二进制精确表示，导致计算时可能出现误差。</li>\n<li><code>BigDecimal</code> 避免了这种情况，因为它直接操作十进制的数值。</li>\n</ul>\n</li>\n<li><p><strong>支持精确的数学运算：</strong></p>\n<ul>\n<li><code>BigDecimal</code> 的加、减、乘、除等操作都使用精确的算法进行计算。</li>\n<li>在除法时，可以通过设置舍入模式（<code>RoundingMode</code>）来指定如何处理可能存在的无限小数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>以下是 <code>BigDecimal</code> 避免精度丢失的一个简单例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BigDecimalExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 浮点数精度丢失</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"number\">0.1</span>;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">d2</span> <span class=\"operator\">=</span> <span class=\"number\">0.2</span>;</span><br><span class=\"line\">        System.out.println(d1 + d2); <span class=\"comment\">// 输出可能为 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 BigDecimal</span></span><br><span class=\"line\">        <span class=\"type\">BigDecimal</span> <span class=\"variable\">bd1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.1&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">BigDecimal</span> <span class=\"variable\">bd2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">BigDecimal</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> bd1.add(bd2);</span><br><span class=\"line\">        System.out.println(result); <span class=\"comment\">// 输出 0.3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重要注意事项\"><a href=\"#重要注意事项\" class=\"headerlink\" title=\"重要注意事项\"></a>重要注意事项</h3><ol>\n<li><p><strong>不要直接使用 <code>double</code> 初始化：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"number\">0.1</span>); <span class=\"comment\">// 会引入浮点数的精度问题</span></span><br></pre></td></tr></table></figure>\n\n<p>推荐使用字符串或 <code>BigDecimal.valueOf(double)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.1&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd</span> <span class=\"operator\">=</span> BigDecimal.valueOf(<span class=\"number\">0.1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>控制除法的精度：</strong> 对于除法运算，可能会出现无限小数的情况，需要指定精度和舍入模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> bd1.divide(bd2, <span class=\"number\">5</span>, RoundingMode.HALF_UP); <span class=\"comment\">// 保留5位小数</span></span><br><span class=\"line\">System.out.println(result); <span class=\"comment\">// 输出 0.33333</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>BigDecimal</code> 的高精度计算是通过以字符串或整数形式存储数值和标度来实现的，避免了浮点数的二进制近似问题。在需要精确计算的场景（如金融、科学计算）中非常适用，但由于计算性能相对较低，在性能敏感的场景中需要慎用。</p>\n","cover":false,"excerpt":"","more":"<p>java的bigdecimal是怎么解决精度丢失的</p>\n<p>在 Java 中，<code>BigDecimal</code> 是专门用来处理高精度计算的类，它可以避免像 <code>float</code> 和 <code>double</code> 这类浮点数在计算时可能产生的精度丢失问题。这是因为 <code>BigDecimal</code> 采用了 <strong>定点数表示法</strong>，而不是浮点数的近似计算方法。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ol>\n<li><p><strong>使用字符串或整数表示数值：</strong></p>\n<ul>\n<li><code>BigDecimal</code> 内部通过一个 <code>BigInteger</code> 表示数值部分（即不带小数点的整数部分）。</li>\n<li>小数点的位置通过一个 <code>int</code> 类型的标度（scale）来表示。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;123.45&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 内部表示：</span></span><br><span class=\"line\"><span class=\"comment\">// 数值部分：12345（BigInteger）</span></span><br><span class=\"line\"><span class=\"comment\">// 标度：2（表示小数点后有2位小数）</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>避免二进制浮点数的误差：</strong></p>\n<ul>\n<li>浮点数如 <code>double</code> 在底层以二进制存储，许多十进制的小数（如 0.1）无法用二进制精确表示，导致计算时可能出现误差。</li>\n<li><code>BigDecimal</code> 避免了这种情况，因为它直接操作十进制的数值。</li>\n</ul>\n</li>\n<li><p><strong>支持精确的数学运算：</strong></p>\n<ul>\n<li><code>BigDecimal</code> 的加、减、乘、除等操作都使用精确的算法进行计算。</li>\n<li>在除法时，可以通过设置舍入模式（<code>RoundingMode</code>）来指定如何处理可能存在的无限小数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>以下是 <code>BigDecimal</code> 避免精度丢失的一个简单例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BigDecimalExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 浮点数精度丢失</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"number\">0.1</span>;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">d2</span> <span class=\"operator\">=</span> <span class=\"number\">0.2</span>;</span><br><span class=\"line\">        System.out.println(d1 + d2); <span class=\"comment\">// 输出可能为 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 BigDecimal</span></span><br><span class=\"line\">        <span class=\"type\">BigDecimal</span> <span class=\"variable\">bd1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.1&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">BigDecimal</span> <span class=\"variable\">bd2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">BigDecimal</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> bd1.add(bd2);</span><br><span class=\"line\">        System.out.println(result); <span class=\"comment\">// 输出 0.3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重要注意事项\"><a href=\"#重要注意事项\" class=\"headerlink\" title=\"重要注意事项\"></a>重要注意事项</h3><ol>\n<li><p><strong>不要直接使用 <code>double</code> 初始化：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"number\">0.1</span>); <span class=\"comment\">// 会引入浮点数的精度问题</span></span><br></pre></td></tr></table></figure>\n\n<p>推荐使用字符串或 <code>BigDecimal.valueOf(double)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;0.1&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd</span> <span class=\"operator\">=</span> BigDecimal.valueOf(<span class=\"number\">0.1</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>控制除法的精度：</strong> 对于除法运算，可能会出现无限小数的情况，需要指定精度和舍入模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bd2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> bd1.divide(bd2, <span class=\"number\">5</span>, RoundingMode.HALF_UP); <span class=\"comment\">// 保留5位小数</span></span><br><span class=\"line\">System.out.println(result); <span class=\"comment\">// 输出 0.33333</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>BigDecimal</code> 的高精度计算是通过以字符串或整数形式存储数值和标度来实现的，避免了浮点数的二进制近似问题。在需要精确计算的场景（如金融、科学计算）中非常适用，但由于计算性能相对较低，在性能敏感的场景中需要慎用。</p>\n"},{"title":"leetcode第31题解","date":"2024-12-14T07:07:39.000Z","_content":"\n# [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)\n\n整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 修改，只允许使用额外常数空间。\n\n**示例 1：**\n\n**输入：**nums = [1,2,3]\n**输出：**[1,3,2]\n\n**示例 2：**\n\n**输入：**nums = [3,2,1]\n**输出：**[1,2,3]\n\n**示例 3：**\n\n**输入：**nums = [1,1,5]\n**输出：**[1,5,1]\n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`\n\n\n\n\n\n# 思路：\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。\n\n\n\n\n\n# 代码\n\n```java\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i=0;\n        int j=0;\n        outerloop:\n        for(i=nums.length-2;i>=0;i--)//i从后往前找\n        {\n            int min=1000;\n            int minj=-1;\n            for(j=i+1;j<nums.length;j++)//找到i后比i大的最小数\n            {\n               if(nums[i]<nums[j]&&nums[j]<min)\n               {\n                    min=nums[j];\n                    minj=j;\n               }\n            }\n            if(minj!=-1)//找到并交换跳出两重循环\n            {\n                int temp=nums[i];\n                nums[i]=nums[minj];\n                nums[minj]=temp;\n                break outerloop;\n            }\n        }\n        Arrays.sort(nums,i+1,nums.length);//排序i后元素\n    }\n}\n```\n","source":"_posts/leetcode第31题解.md","raw":"---\ntitle: leetcode第31题解\ndate: 2024-12-14 15:07:39\ntags: leetcode\ncategories: 算法\n---\n\n# [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)\n\n整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 修改，只允许使用额外常数空间。\n\n**示例 1：**\n\n**输入：**nums = [1,2,3]\n**输出：**[1,3,2]\n\n**示例 2：**\n\n**输入：**nums = [3,2,1]\n**输出：**[1,2,3]\n\n**示例 3：**\n\n**输入：**nums = [1,1,5]\n**输出：**[1,5,1]\n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`\n\n\n\n\n\n# 思路：\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。\n\n\n\n\n\n# 代码\n\n```java\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i=0;\n        int j=0;\n        outerloop:\n        for(i=nums.length-2;i>=0;i--)//i从后往前找\n        {\n            int min=1000;\n            int minj=-1;\n            for(j=i+1;j<nums.length;j++)//找到i后比i大的最小数\n            {\n               if(nums[i]<nums[j]&&nums[j]<min)\n               {\n                    min=nums[j];\n                    minj=j;\n               }\n            }\n            if(minj!=-1)//找到并交换跳出两重循环\n            {\n                int temp=nums[i];\n                nums[i]=nums[minj];\n                nums[minj]=temp;\n                break outerloop;\n            }\n        }\n        Arrays.sort(nums,i+1,nums.length);//排序i后元素\n    }\n}\n```\n","slug":"leetcode第31题解","published":1,"updated":"2024-12-14T08:09:33.135Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1t000c3ga8dlcg5mha","content":"<h1 id=\"31-下一个排列\"><a href=\"#31-下一个排列\" class=\"headerlink\" title=\"31. 下一个排列\"></a><a href=\"https://leetcode.cn/problems/next-permutation/\">31. 下一个排列</a></h1><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>\n</ul>\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>\n<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>\n<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>\n<p>必须 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 修改，只允许使用额外常数空间。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,2,3]<br><strong>输出：</strong>[1,3,2]</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [3,2,1]<br><strong>输出：</strong>[1,2,3]</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,1,5]<br><strong>输出：</strong>[1,5,1]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<h1 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h1><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nextPermutation</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        outerloop:</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=nums.length-<span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;i--)<span class=\"comment\">//i从后往前找</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> min=<span class=\"number\">1000</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> minj=-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;nums.length;j++)<span class=\"comment\">//找到i后比i大的最小数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(nums[i]&lt;nums[j]&amp;&amp;nums[j]&lt;min)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                    min=nums[j];</span><br><span class=\"line\">                    minj=j;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minj!=-<span class=\"number\">1</span>)<span class=\"comment\">//找到并交换跳出两重循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> temp=nums[i];</span><br><span class=\"line\">                nums[i]=nums[minj];</span><br><span class=\"line\">                nums[minj]=temp;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> outerloop;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(nums,i+<span class=\"number\">1</span>,nums.length);<span class=\"comment\">//排序i后元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","cover":false,"excerpt":"","more":"<h1 id=\"31-下一个排列\"><a href=\"#31-下一个排列\" class=\"headerlink\" title=\"31. 下一个排列\"></a><a href=\"https://leetcode.cn/problems/next-permutation/\">31. 下一个排列</a></h1><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>\n</ul>\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>\n<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>\n<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>\n<p>必须 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 修改，只允许使用额外常数空间。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,2,3]<br><strong>输出：</strong>[1,3,2]</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [3,2,1]<br><strong>输出：</strong>[1,2,3]</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,1,5]<br><strong>输出：</strong>[1,5,1]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<h1 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h1><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nextPermutation</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        outerloop:</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=nums.length-<span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;i--)<span class=\"comment\">//i从后往前找</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> min=<span class=\"number\">1000</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> minj=-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;nums.length;j++)<span class=\"comment\">//找到i后比i大的最小数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(nums[i]&lt;nums[j]&amp;&amp;nums[j]&lt;min)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                    min=nums[j];</span><br><span class=\"line\">                    minj=j;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minj!=-<span class=\"number\">1</span>)<span class=\"comment\">//找到并交换跳出两重循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> temp=nums[i];</span><br><span class=\"line\">                nums[i]=nums[minj];</span><br><span class=\"line\">                nums[minj]=temp;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> outerloop;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(nums,i+<span class=\"number\">1</span>,nums.length);<span class=\"comment\">//排序i后元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"438.找到字符串中所有字母异位词","date":"2025-01-17T15:45:30.000Z","_content":"\n# 题目\n\n[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 \n\n**异位词**\n\n 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n**示例 1:**\n\n**输入:** s = \"cbaebabacd\", p = \"abc\"\n**输出:** [0,6]\n**解释:**\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n\n **示例 2:**\n\n**输入:** s = \"abab\", p = \"ab\"\n**输出:** [0,1,2]\n**解释:**\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n\n**提示:**\n\n- `1 <= s.length, p.length <= 3 * 104`\n- `s` 和 `p` 仅包含小写字母\n\n# 题解\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>(); \n        int[] pnums = new int[26];\n        int[] snums = new int[26];\n        if(s.length()<p.length())\n        {\n            return new ArrayList<>();\n        }\n        for(int i=0;i<p.length();i++)\n        {\n            pnums[p.charAt(i)-'a']++;\n            snums[s.charAt(i)-'a']++;\n        }\n        int i;\n        for(i=0;i<s.length()-p.length();i++)\n        {\n            if(Arrays.equals(pnums,snums))\n            {\n                result.add(i);\n            }\n            snums[s.charAt(i)-'a']--;\n            snums[s.charAt(i+p.length())-'a']++;\n        }\n        if(Arrays.equals(pnums,snums))\n            {\n                result.add(i);\n            }\n        return result;\n    }\n}\n```\n\n# 思路\n\n- 判断是否为字母异位词，要判断两个字符串是否字母数量相同，所以这里维护两个字母数量数组\n\n- 通过滑动窗口来动态维护窗口的数量数组，如果窗口的数量数组等于p的数量数组说明是一个字母异位词\n","source":"_posts/438-找到字符串中所有字母异位词.md","raw":"---\ntitle: 438.找到字符串中所有字母异位词\ndate: 2025-01-17 23:45:30\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 \n\n**异位词**\n\n 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n**示例 1:**\n\n**输入:** s = \"cbaebabacd\", p = \"abc\"\n**输出:** [0,6]\n**解释:**\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n\n **示例 2:**\n\n**输入:** s = \"abab\", p = \"ab\"\n**输出:** [0,1,2]\n**解释:**\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n\n**提示:**\n\n- `1 <= s.length, p.length <= 3 * 104`\n- `s` 和 `p` 仅包含小写字母\n\n# 题解\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>(); \n        int[] pnums = new int[26];\n        int[] snums = new int[26];\n        if(s.length()<p.length())\n        {\n            return new ArrayList<>();\n        }\n        for(int i=0;i<p.length();i++)\n        {\n            pnums[p.charAt(i)-'a']++;\n            snums[s.charAt(i)-'a']++;\n        }\n        int i;\n        for(i=0;i<s.length()-p.length();i++)\n        {\n            if(Arrays.equals(pnums,snums))\n            {\n                result.add(i);\n            }\n            snums[s.charAt(i)-'a']--;\n            snums[s.charAt(i+p.length())-'a']++;\n        }\n        if(Arrays.equals(pnums,snums))\n            {\n                result.add(i);\n            }\n        return result;\n    }\n}\n```\n\n# 思路\n\n- 判断是否为字母异位词，要判断两个字符串是否字母数量相同，所以这里维护两个字母数量数组\n\n- 通过滑动窗口来动态维护窗口的数量数组，如果窗口的数量数组等于p的数量数组说明是一个字母异位词\n","slug":"438-找到字符串中所有字母异位词","published":1,"updated":"2025-01-17T15:54:23.535Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1u000g3ga800zpbz2u","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 </p>\n<p><strong>异位词</strong></p>\n<p> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n<p><strong>示例 1:</strong></p>\n<p><strong>输入:</strong> s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br><strong>输出:</strong> [0,6]<br><strong>解释:</strong><br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>\n<p> <strong>示例 2:</strong></p>\n<p><strong>输入:</strong> s &#x3D; “abab”, p &#x3D; “ab”<br><strong>输出:</strong> [0,1,2]<br><strong>解释:</strong><br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>\n<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">findAnagrams</span><span class=\"params\">(String s, String p)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(); </span><br><span class=\"line\">        <span class=\"type\">int</span>[] pnums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] snums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()&lt;p.length())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;p.length();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pnums[p.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">            snums[s.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;s.length()-p.length();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Arrays.equals(pnums,snums))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            snums[s.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">            snums[s.charAt(i+p.length())-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Arrays.equals(pnums,snums))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>判断是否为字母异位词，要判断两个字符串是否字母数量相同，所以这里维护两个字母数量数组</p>\n</li>\n<li><p>通过滑动窗口来动态维护窗口的数量数组，如果窗口的数量数组等于p的数量数组说明是一个字母异位词</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 </p>\n<p><strong>异位词</strong></p>\n<p> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n<p><strong>示例 1:</strong></p>\n<p><strong>输入:</strong> s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br><strong>输出:</strong> [0,6]<br><strong>解释:</strong><br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>\n<p> <strong>示例 2:</strong></p>\n<p><strong>输入:</strong> s &#x3D; “abab”, p &#x3D; “ab”<br><strong>输出:</strong> [0,1,2]<br><strong>解释:</strong><br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>\n<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">findAnagrams</span><span class=\"params\">(String s, String p)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(); </span><br><span class=\"line\">        <span class=\"type\">int</span>[] pnums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] snums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length()&lt;p.length())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;p.length();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pnums[p.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">            snums[s.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;s.length()-p.length();i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Arrays.equals(pnums,snums))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            snums[s.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">            snums[s.charAt(i+p.length())-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Arrays.equals(pnums,snums))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>判断是否为字母异位词，要判断两个字符串是否字母数量相同，所以这里维护两个字母数量数组</p>\n</li>\n<li><p>通过滑动窗口来动态维护窗口的数量数组，如果窗口的数量数组等于p的数量数组说明是一个字母异位词</p>\n</li>\n</ul>\n"},{"title":"localCache实现expire过期原理","date":"2024-12-17T03:52:42.000Z","_content":"\n我们首先来定义一下接口。\n\n主要有两个：一个是多久之后过期，一个是在什么时候过期。\n\n```java\npublic interface ICache<K, V> extends Map<K, V> {\n\n    /**\n     * 设置过期时间\n     * （1）如果 key 不存在，则什么都不做。\n     * （2）暂时不提供新建 key 指定过期时间的方式，会破坏原来的方法。\n     *\n     * 会做什么：\n     * 类似于 redis\n     * （1）惰性删除。\n     * 在执行下面的方法时，如果过期则进行删除。\n     * {@link ICache#get(Object)} 获取\n     * {@link ICache#values()} 获取所有值\n     * {@link ICache#entrySet()} 获取所有明细\n     *\n     * 【数据的不一致性】\n     * 调用其他方法，可能得到的不是使用者的预期结果，因为此时的 expire 信息可能没有被及时更新。\n     * 比如\n     * {@link ICache#isEmpty()} 是否为空\n     * {@link ICache#size()} 当前大小\n     * 同时会导致以 size() 作为过期条件的问题。\n     *\n     * 解决方案：考虑添加 refresh 等方法，暂时不做一致性的考虑。\n     * 对于实际的使用，我们更关心 K/V 的信息。\n     *\n     * （2）定时删除\n     * 启动一个定时任务。每次随机选择指定大小的 key 进行是否过期判断。\n     * 类似于 redis，为了简化，可以考虑设定超时时间，频率与超时时间成反比。\n     *\n     * 其他拓展性考虑：\n     * 后期考虑提供原子性操作，保证事务性。暂时不做考虑。\n     * 此处默认使用 TTL 作为比较的基准，暂时不想支持 LastAccessTime 的淘汰策略。会增加复杂度。\n     * 如果增加 lastAccessTime 过期，本方法可以不做修改。\n     *\n     * @param key         key\n     * @param timeInMills 毫秒时间之后过期\n     * @return this\n     * @since 0.0.3\n     */\n    ICache<K, V> expire(final K key, final long timeInMills);\n\n    /**\n     * 在指定的时间过期\n     * @param key key\n     * @param timeInMills 时间戳\n     * @return this\n     * @since 0.0.3\n     */\n    ICache<K, V> expireAt(final K key, final long timeInMills);\n\n}\n```\n\n为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。\n\n核心的代码，主要还是看 cacheExpire 接口。\n\n```java\n@Override\npublic ICache<K, V> expire(K key, long timeInMills) {\n    long expireTime = System.currentTimeMillis() + timeInMills;\n    return this.expireAt(key, expireTime);\n}\n\n@Override\npublic ICache<K, V> expireAt(K key, long timeInMills) {\n    this.cacheExpire.expire(key, timeInMills);\n    return this;\n}\n```\n\n在CacheBs构建cache对象的时候会初始化cache指定expire过期策略\n\n```java\n public ICache<K,V> build() {\n        Cache<K,V> cache = new Cache<>();\n        cache.map(map);\n        cache.evict(evict);\n        cache.sizeLimit(size);\n        cache.removeListeners(removeListeners);\n        cache.load(load);\n        cache.persist(persist);\n        cache.slowListeners(slowListeners);\n\n        // 初始化\n        cache.init();\n        return CacheProxy.getProxy(cache);\n    }\n```\n\n```java\n    /**\n     * 初始化\n     * @since 0.0.7\n     */\n    public void init() {\n        this.expire = new CacheExpire<>(this);\n        this.load.load(this);\n\n        // 初始化持久化\n        if(this.persist != null) {\n            new InnerCachePersist<>(this, persist);\n        }\n    }\n```\n\ncache使用的是CacheExpire过期策略并将cache对象传入策略中实现过期删除，当调用expire方法时，key和过期时间会存入到expireMap，在实例化CacheExpire对象时初始化会启动一个单线程定时轮询执行器singleThreadScheduledExecutor，每过100ms调度一次，每次去expireMap中处理100个可能过期的key实现过期删除\n\n```java\npackage com.github.houbb.cache.core.support.expire;\n\nimport com.github.houbb.cache.api.ICache;\nimport com.github.houbb.cache.api.ICacheExpire;\nimport com.github.houbb.cache.api.ICacheRemoveListener;\nimport com.github.houbb.cache.api.ICacheRemoveListenerContext;\nimport com.github.houbb.cache.core.constant.enums.CacheRemoveType;\nimport com.github.houbb.cache.core.support.listener.remove.CacheRemoveListenerContext;\nimport com.github.houbb.heaven.util.util.CollectionUtil;\nimport com.github.houbb.heaven.util.util.MapUtil;\n\nimport java.util.*;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 缓存过期-普通策略\n *\n * @author binbin.hou\n * @since 0.0.3\n * @param <K> key\n * @param <V> value\n */\npublic class CacheExpire<K,V> implements ICacheExpire<K,V> {\n\n    /**\n     * 单次清空的数量限制\n     * @since 0.0.3\n     */\n    private static final int LIMIT = 100;\n\n    /**\n     * 过期 map\n     *\n     * 空间换时间\n     * @since 0.0.3\n     */\n    private final Map<K, Long> expireMap = new HashMap<>();\n\n    /**\n     * 缓存实现\n     * @since 0.0.3\n     */\n    private final ICache<K,V> cache;\n\n    /**\n     * 线程执行类\n     * @since 0.0.3\n     */\n    private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();\n\n    public CacheExpire(ICache<K, V> cache) {\n        this.cache = cache;\n        this.init();\n    }\n\n    /**\n     * 初始化任务\n     * @since 0.0.3\n     */\n    private void init() {\n        EXECUTOR_SERVICE.scheduleAtFixedRate(new ExpireThread(), 100, 100, TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * 定时执行任务\n     * @since 0.0.3\n     */\n    private class ExpireThread implements Runnable {\n        @Override\n        public void run() {\n            //1.判断是否为空\n            if(MapUtil.isEmpty(expireMap)) {\n                return;\n            }\n\n            //2. 获取 key 进行处理\n            int count = 0;\n            for(Map.Entry<K, Long> entry : expireMap.entrySet()) {\n                if(count >= LIMIT) {\n                    return;\n                }\n\n                expireKey(entry.getKey(), entry.getValue());\n                count++;\n            }\n        }\n    }\n\n    @Override\n    public void expire(K key, long expireAt) {\n        expireMap.put(key, expireAt);\n    }\n\n    @Override\n    public void refreshExpire(Collection<K> keyList) {\n        if(CollectionUtil.isEmpty(keyList)) {\n            return;\n        }\n\n        // 判断大小，小的作为外循环。一般都是过期的 keys 比较小。\n        if(keyList.size() <= expireMap.size()) {\n            for(K key : keyList) {\n                Long expireAt = expireMap.get(key);\n                expireKey(key, expireAt);\n            }\n        } else {\n            for(Map.Entry<K, Long> entry : expireMap.entrySet()) {\n                this.expireKey(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    @Override\n    public Long expireTime(K key) {\n        return expireMap.get(key);\n    }\n\n    /**\n     * 过期处理 key\n     * @param key key\n     * @param expireAt 过期时间\n     * @since 0.0.3\n     */\n    private void expireKey(final K key, final Long expireAt) {\n        if(expireAt == null) {\n            return;\n        }\n\n        long currentTime = System.currentTimeMillis();\n        if(currentTime >= expireAt) {\n            expireMap.remove(key);\n            // 再移除缓存，后续可以通过惰性删除做补偿\n            V removeValue = cache.remove(key);\n            // 执行淘汰监听器\n            ICacheRemoveListenerContext<K,V> removeListenerContext = CacheRemoveListenerContext.<K,V>newInstance().key(key).value(removeValue).type(CacheRemoveType.EXPIRE.code());\n            for(ICacheRemoveListener<K,V> listener : cache.removeListeners()) {\n                listener.listen(removeListenerContext);\n            }\n        }\n    }\n\n}\n\n```\n\n\n\n类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。\n\n那当我们查询时，可能获取到到是脏数据。\n\n于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。\n\n算是一种折中方案。\n\n一般就是各种查询方法，比如我们获取 key 对应的值时\n\n```java\n    @Override\n    @CacheInterceptor(evict = true)\n    @SuppressWarnings(\"unchecked\")\n    public V get(Object key) {\n        //1. 刷新所有过期信息\n        K genericKey = (K) key;\n        this.expire.refreshExpire(Collections.singletonList(genericKey));\n\n        return map.get(key);\n    }\n```\n\n我们在获取之前，先做一次数据的刷新。\n\n\n\n实现原理也非常简单，就是一个循环，然后作删除即可。\n\n这里加了一个小的优化：选择数量少的作为外循环。\n\n循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);\n\n```java\n\n```\n","source":"_posts/localCache实现expire过期原理.md","raw":"---\ntitle: localCache实现expire过期原理\ndate: 2024-12-17 11:52:42\ntags: localCache\ncategories: 项目\n---\n\n我们首先来定义一下接口。\n\n主要有两个：一个是多久之后过期，一个是在什么时候过期。\n\n```java\npublic interface ICache<K, V> extends Map<K, V> {\n\n    /**\n     * 设置过期时间\n     * （1）如果 key 不存在，则什么都不做。\n     * （2）暂时不提供新建 key 指定过期时间的方式，会破坏原来的方法。\n     *\n     * 会做什么：\n     * 类似于 redis\n     * （1）惰性删除。\n     * 在执行下面的方法时，如果过期则进行删除。\n     * {@link ICache#get(Object)} 获取\n     * {@link ICache#values()} 获取所有值\n     * {@link ICache#entrySet()} 获取所有明细\n     *\n     * 【数据的不一致性】\n     * 调用其他方法，可能得到的不是使用者的预期结果，因为此时的 expire 信息可能没有被及时更新。\n     * 比如\n     * {@link ICache#isEmpty()} 是否为空\n     * {@link ICache#size()} 当前大小\n     * 同时会导致以 size() 作为过期条件的问题。\n     *\n     * 解决方案：考虑添加 refresh 等方法，暂时不做一致性的考虑。\n     * 对于实际的使用，我们更关心 K/V 的信息。\n     *\n     * （2）定时删除\n     * 启动一个定时任务。每次随机选择指定大小的 key 进行是否过期判断。\n     * 类似于 redis，为了简化，可以考虑设定超时时间，频率与超时时间成反比。\n     *\n     * 其他拓展性考虑：\n     * 后期考虑提供原子性操作，保证事务性。暂时不做考虑。\n     * 此处默认使用 TTL 作为比较的基准，暂时不想支持 LastAccessTime 的淘汰策略。会增加复杂度。\n     * 如果增加 lastAccessTime 过期，本方法可以不做修改。\n     *\n     * @param key         key\n     * @param timeInMills 毫秒时间之后过期\n     * @return this\n     * @since 0.0.3\n     */\n    ICache<K, V> expire(final K key, final long timeInMills);\n\n    /**\n     * 在指定的时间过期\n     * @param key key\n     * @param timeInMills 时间戳\n     * @return this\n     * @since 0.0.3\n     */\n    ICache<K, V> expireAt(final K key, final long timeInMills);\n\n}\n```\n\n为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。\n\n核心的代码，主要还是看 cacheExpire 接口。\n\n```java\n@Override\npublic ICache<K, V> expire(K key, long timeInMills) {\n    long expireTime = System.currentTimeMillis() + timeInMills;\n    return this.expireAt(key, expireTime);\n}\n\n@Override\npublic ICache<K, V> expireAt(K key, long timeInMills) {\n    this.cacheExpire.expire(key, timeInMills);\n    return this;\n}\n```\n\n在CacheBs构建cache对象的时候会初始化cache指定expire过期策略\n\n```java\n public ICache<K,V> build() {\n        Cache<K,V> cache = new Cache<>();\n        cache.map(map);\n        cache.evict(evict);\n        cache.sizeLimit(size);\n        cache.removeListeners(removeListeners);\n        cache.load(load);\n        cache.persist(persist);\n        cache.slowListeners(slowListeners);\n\n        // 初始化\n        cache.init();\n        return CacheProxy.getProxy(cache);\n    }\n```\n\n```java\n    /**\n     * 初始化\n     * @since 0.0.7\n     */\n    public void init() {\n        this.expire = new CacheExpire<>(this);\n        this.load.load(this);\n\n        // 初始化持久化\n        if(this.persist != null) {\n            new InnerCachePersist<>(this, persist);\n        }\n    }\n```\n\ncache使用的是CacheExpire过期策略并将cache对象传入策略中实现过期删除，当调用expire方法时，key和过期时间会存入到expireMap，在实例化CacheExpire对象时初始化会启动一个单线程定时轮询执行器singleThreadScheduledExecutor，每过100ms调度一次，每次去expireMap中处理100个可能过期的key实现过期删除\n\n```java\npackage com.github.houbb.cache.core.support.expire;\n\nimport com.github.houbb.cache.api.ICache;\nimport com.github.houbb.cache.api.ICacheExpire;\nimport com.github.houbb.cache.api.ICacheRemoveListener;\nimport com.github.houbb.cache.api.ICacheRemoveListenerContext;\nimport com.github.houbb.cache.core.constant.enums.CacheRemoveType;\nimport com.github.houbb.cache.core.support.listener.remove.CacheRemoveListenerContext;\nimport com.github.houbb.heaven.util.util.CollectionUtil;\nimport com.github.houbb.heaven.util.util.MapUtil;\n\nimport java.util.*;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 缓存过期-普通策略\n *\n * @author binbin.hou\n * @since 0.0.3\n * @param <K> key\n * @param <V> value\n */\npublic class CacheExpire<K,V> implements ICacheExpire<K,V> {\n\n    /**\n     * 单次清空的数量限制\n     * @since 0.0.3\n     */\n    private static final int LIMIT = 100;\n\n    /**\n     * 过期 map\n     *\n     * 空间换时间\n     * @since 0.0.3\n     */\n    private final Map<K, Long> expireMap = new HashMap<>();\n\n    /**\n     * 缓存实现\n     * @since 0.0.3\n     */\n    private final ICache<K,V> cache;\n\n    /**\n     * 线程执行类\n     * @since 0.0.3\n     */\n    private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();\n\n    public CacheExpire(ICache<K, V> cache) {\n        this.cache = cache;\n        this.init();\n    }\n\n    /**\n     * 初始化任务\n     * @since 0.0.3\n     */\n    private void init() {\n        EXECUTOR_SERVICE.scheduleAtFixedRate(new ExpireThread(), 100, 100, TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * 定时执行任务\n     * @since 0.0.3\n     */\n    private class ExpireThread implements Runnable {\n        @Override\n        public void run() {\n            //1.判断是否为空\n            if(MapUtil.isEmpty(expireMap)) {\n                return;\n            }\n\n            //2. 获取 key 进行处理\n            int count = 0;\n            for(Map.Entry<K, Long> entry : expireMap.entrySet()) {\n                if(count >= LIMIT) {\n                    return;\n                }\n\n                expireKey(entry.getKey(), entry.getValue());\n                count++;\n            }\n        }\n    }\n\n    @Override\n    public void expire(K key, long expireAt) {\n        expireMap.put(key, expireAt);\n    }\n\n    @Override\n    public void refreshExpire(Collection<K> keyList) {\n        if(CollectionUtil.isEmpty(keyList)) {\n            return;\n        }\n\n        // 判断大小，小的作为外循环。一般都是过期的 keys 比较小。\n        if(keyList.size() <= expireMap.size()) {\n            for(K key : keyList) {\n                Long expireAt = expireMap.get(key);\n                expireKey(key, expireAt);\n            }\n        } else {\n            for(Map.Entry<K, Long> entry : expireMap.entrySet()) {\n                this.expireKey(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    @Override\n    public Long expireTime(K key) {\n        return expireMap.get(key);\n    }\n\n    /**\n     * 过期处理 key\n     * @param key key\n     * @param expireAt 过期时间\n     * @since 0.0.3\n     */\n    private void expireKey(final K key, final Long expireAt) {\n        if(expireAt == null) {\n            return;\n        }\n\n        long currentTime = System.currentTimeMillis();\n        if(currentTime >= expireAt) {\n            expireMap.remove(key);\n            // 再移除缓存，后续可以通过惰性删除做补偿\n            V removeValue = cache.remove(key);\n            // 执行淘汰监听器\n            ICacheRemoveListenerContext<K,V> removeListenerContext = CacheRemoveListenerContext.<K,V>newInstance().key(key).value(removeValue).type(CacheRemoveType.EXPIRE.code());\n            for(ICacheRemoveListener<K,V> listener : cache.removeListeners()) {\n                listener.listen(removeListenerContext);\n            }\n        }\n    }\n\n}\n\n```\n\n\n\n类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。\n\n那当我们查询时，可能获取到到是脏数据。\n\n于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。\n\n算是一种折中方案。\n\n一般就是各种查询方法，比如我们获取 key 对应的值时\n\n```java\n    @Override\n    @CacheInterceptor(evict = true)\n    @SuppressWarnings(\"unchecked\")\n    public V get(Object key) {\n        //1. 刷新所有过期信息\n        K genericKey = (K) key;\n        this.expire.refreshExpire(Collections.singletonList(genericKey));\n\n        return map.get(key);\n    }\n```\n\n我们在获取之前，先做一次数据的刷新。\n\n\n\n实现原理也非常简单，就是一个循环，然后作删除即可。\n\n这里加了一个小的优化：选择数量少的作为外循环。\n\n循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);\n\n```java\n\n```\n","slug":"localCache实现expire过期原理","published":1,"updated":"2024-12-17T04:39:32.926Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1v000i3ga85ydta824","content":"<p>我们首先来定义一下接口。</p>\n<p>主要有两个：一个是多久之后过期，一个是在什么时候过期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Map</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * （1）如果 key 不存在，则什么都不做。</span></span><br><span class=\"line\"><span class=\"comment\">     * （2）暂时不提供新建 key 指定过期时间的方式，会破坏原来的方法。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 会做什么：</span></span><br><span class=\"line\"><span class=\"comment\">     * 类似于 redis</span></span><br><span class=\"line\"><span class=\"comment\">     * （1）惰性删除。</span></span><br><span class=\"line\"><span class=\"comment\">     * 在执行下面的方法时，如果过期则进行删除。</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#get(Object)&#125; 获取</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#values()&#125; 获取所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#entrySet()&#125; 获取所有明细</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 【数据的不一致性】</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用其他方法，可能得到的不是使用者的预期结果，因为此时的 expire 信息可能没有被及时更新。</span></span><br><span class=\"line\"><span class=\"comment\">     * 比如</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#isEmpty()&#125; 是否为空</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#size()&#125; 当前大小</span></span><br><span class=\"line\"><span class=\"comment\">     * 同时会导致以 size() 作为过期条件的问题。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 解决方案：考虑添加 refresh 等方法，暂时不做一致性的考虑。</span></span><br><span class=\"line\"><span class=\"comment\">     * 对于实际的使用，我们更关心 K/V 的信息。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * （2）定时删除</span></span><br><span class=\"line\"><span class=\"comment\">     * 启动一个定时任务。每次随机选择指定大小的 key 进行是否过期判断。</span></span><br><span class=\"line\"><span class=\"comment\">     * 类似于 redis，为了简化，可以考虑设定超时时间，频率与超时时间成反比。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 其他拓展性考虑：</span></span><br><span class=\"line\"><span class=\"comment\">     * 后期考虑提供原子性操作，保证事务性。暂时不做考虑。</span></span><br><span class=\"line\"><span class=\"comment\">     * 此处默认使用 TTL 作为比较的基准，暂时不想支持 LastAccessTime 的淘汰策略。会增加复杂度。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果增加 lastAccessTime 过期，本方法可以不做修改。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key         key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ICache&lt;K, V&gt; <span class=\"title function_\">expire</span><span class=\"params\">(<span class=\"keyword\">final</span> K key, <span class=\"keyword\">final</span> <span class=\"type\">long</span> timeInMills)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在指定的时间过期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeInMills 时间戳</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ICache&lt;K, V&gt; <span class=\"title function_\">expireAt</span><span class=\"params\">(<span class=\"keyword\">final</span> K key, <span class=\"keyword\">final</span> <span class=\"type\">long</span> timeInMills)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。</p>\n<p>核心的代码，主要还是看 cacheExpire 接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ICache&lt;K, V&gt; <span class=\"title function_\">expire</span><span class=\"params\">(K key, <span class=\"type\">long</span> timeInMills)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> System.currentTimeMillis() + timeInMills;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.expireAt(key, expireTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ICache&lt;K, V&gt; <span class=\"title function_\">expireAt</span><span class=\"params\">(K key, <span class=\"type\">long</span> timeInMills)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cacheExpire.expire(key, timeInMills);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在CacheBs构建cache对象的时候会初始化cache指定expire过期策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ICache&lt;K,V&gt; <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       Cache&lt;K,V&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">Cache</span>&lt;&gt;();</span><br><span class=\"line\">       cache.map(map);</span><br><span class=\"line\">       cache.evict(evict);</span><br><span class=\"line\">       cache.sizeLimit(size);</span><br><span class=\"line\">       cache.removeListeners(removeListeners);</span><br><span class=\"line\">       cache.load(load);</span><br><span class=\"line\">       cache.persist(persist);</span><br><span class=\"line\">       cache.slowListeners(slowListeners);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">       cache.init();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> CacheProxy.getProxy(cache);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.expire = <span class=\"keyword\">new</span> <span class=\"title class_\">CacheExpire</span>&lt;&gt;(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.load.load(<span class=\"built_in\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化持久化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.persist != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">InnerCachePersist</span>&lt;&gt;(<span class=\"built_in\">this</span>, persist);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>cache使用的是CacheExpire过期策略并将cache对象传入策略中实现过期删除，当调用expire方法时，key和过期时间会存入到expireMap，在实例化CacheExpire对象时初始化会启动一个单线程定时轮询执行器singleThreadScheduledExecutor，每过100ms调度一次，每次去expireMap中处理100个可能过期的key实现过期删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.houbb.cache.core.support.expire;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheExpire;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheRemoveListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheRemoveListenerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.constant.enums.CacheRemoveType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.listener.remove.CacheRemoveListenerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.heaven.util.util.CollectionUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.heaven.util.util.MapUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存过期-普通策略</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;K&gt; key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;V&gt; value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheExpire</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">ICacheExpire</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单次清空的数量限制</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">LIMIT</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 过期 map</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 空间换时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K, Long&gt; expireMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程执行类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">EXECUTOR_SERVICE</span> <span class=\"operator\">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CacheExpire</span><span class=\"params\">(ICache&lt;K, V&gt; cache)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cache = cache;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化任务</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class=\"keyword\">new</span> <span class=\"title class_\">ExpireThread</span>(), <span class=\"number\">100</span>, <span class=\"number\">100</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定时执行任务</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExpireThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//1.判断是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MapUtil.isEmpty(expireMap)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//2. 获取 key 进行处理</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(count &gt;= LIMIT) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                expireKey(entry.getKey(), entry.getValue());</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expire</span><span class=\"params\">(K key, <span class=\"type\">long</span> expireAt)</span> &#123;</span><br><span class=\"line\">        expireMap.put(key, expireAt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refreshExpire</span><span class=\"params\">(Collection&lt;K&gt; keyList)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断大小，小的作为外循环。一般都是过期的 keys 比较小。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(keyList.size() &lt;= expireMap.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(K key : keyList) &#123;</span><br><span class=\"line\">                <span class=\"type\">Long</span> <span class=\"variable\">expireAt</span> <span class=\"operator\">=</span> expireMap.get(key);</span><br><span class=\"line\">                expireKey(key, expireAt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.expireKey(entry.getKey(), entry.getValue());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">expireTime</span><span class=\"params\">(K key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> expireMap.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 过期处理 key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireAt 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expireKey</span><span class=\"params\">(<span class=\"keyword\">final</span> K key, <span class=\"keyword\">final</span> Long expireAt)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(expireAt == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class=\"line\">            expireMap.remove(key);</span><br><span class=\"line\">            <span class=\"comment\">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">removeValue</span> <span class=\"operator\">=</span> cache.remove(key);</span><br><span class=\"line\">            <span class=\"comment\">// 执行淘汰监听器</span></span><br><span class=\"line\">            ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(removeValue).type(CacheRemoveType.EXPIRE.code());</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(ICacheRemoveListener&lt;K,V&gt; listener : cache.removeListeners()) &#123;</span><br><span class=\"line\">                listener.listen(removeListenerContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。</p>\n<p>那当我们查询时，可能获取到到是脏数据。</p>\n<p>于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。</p>\n<p>算是一种折中方案。</p>\n<p>一般就是各种查询方法，比如我们获取 key 对应的值时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@CacheInterceptor(evict = true)</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 刷新所有过期信息</span></span><br><span class=\"line\">    <span class=\"type\">K</span> <span class=\"variable\">genericKey</span> <span class=\"operator\">=</span> (K) key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.expire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在获取之前，先做一次数据的刷新。</p>\n<p>实现原理也非常简单，就是一个循环，然后作删除即可。</p>\n<p>这里加了一个小的优化：选择数量少的作为外循环。</p>\n<p>循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","cover":false,"excerpt":"","more":"<p>我们首先来定义一下接口。</p>\n<p>主要有两个：一个是多久之后过期，一个是在什么时候过期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Map</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * （1）如果 key 不存在，则什么都不做。</span></span><br><span class=\"line\"><span class=\"comment\">     * （2）暂时不提供新建 key 指定过期时间的方式，会破坏原来的方法。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 会做什么：</span></span><br><span class=\"line\"><span class=\"comment\">     * 类似于 redis</span></span><br><span class=\"line\"><span class=\"comment\">     * （1）惰性删除。</span></span><br><span class=\"line\"><span class=\"comment\">     * 在执行下面的方法时，如果过期则进行删除。</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#get(Object)&#125; 获取</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#values()&#125; 获取所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#entrySet()&#125; 获取所有明细</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 【数据的不一致性】</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用其他方法，可能得到的不是使用者的预期结果，因为此时的 expire 信息可能没有被及时更新。</span></span><br><span class=\"line\"><span class=\"comment\">     * 比如</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#isEmpty()&#125; 是否为空</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> ICache#size()&#125; 当前大小</span></span><br><span class=\"line\"><span class=\"comment\">     * 同时会导致以 size() 作为过期条件的问题。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 解决方案：考虑添加 refresh 等方法，暂时不做一致性的考虑。</span></span><br><span class=\"line\"><span class=\"comment\">     * 对于实际的使用，我们更关心 K/V 的信息。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * （2）定时删除</span></span><br><span class=\"line\"><span class=\"comment\">     * 启动一个定时任务。每次随机选择指定大小的 key 进行是否过期判断。</span></span><br><span class=\"line\"><span class=\"comment\">     * 类似于 redis，为了简化，可以考虑设定超时时间，频率与超时时间成反比。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 其他拓展性考虑：</span></span><br><span class=\"line\"><span class=\"comment\">     * 后期考虑提供原子性操作，保证事务性。暂时不做考虑。</span></span><br><span class=\"line\"><span class=\"comment\">     * 此处默认使用 TTL 作为比较的基准，暂时不想支持 LastAccessTime 的淘汰策略。会增加复杂度。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果增加 lastAccessTime 过期，本方法可以不做修改。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key         key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeInMills 毫秒时间之后过期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ICache&lt;K, V&gt; <span class=\"title function_\">expire</span><span class=\"params\">(<span class=\"keyword\">final</span> K key, <span class=\"keyword\">final</span> <span class=\"type\">long</span> timeInMills)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在指定的时间过期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timeInMills 时间戳</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ICache&lt;K, V&gt; <span class=\"title function_\">expireAt</span><span class=\"params\">(<span class=\"keyword\">final</span> K key, <span class=\"keyword\">final</span> <span class=\"type\">long</span> timeInMills)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了便于处理，我们将多久之后过期，进行计算。将两个问题变成同一个问题，在什么时候过期的问题。</p>\n<p>核心的代码，主要还是看 cacheExpire 接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ICache&lt;K, V&gt; <span class=\"title function_\">expire</span><span class=\"params\">(K key, <span class=\"type\">long</span> timeInMills)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> System.currentTimeMillis() + timeInMills;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.expireAt(key, expireTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ICache&lt;K, V&gt; <span class=\"title function_\">expireAt</span><span class=\"params\">(K key, <span class=\"type\">long</span> timeInMills)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cacheExpire.expire(key, timeInMills);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在CacheBs构建cache对象的时候会初始化cache指定expire过期策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ICache&lt;K,V&gt; <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       Cache&lt;K,V&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">Cache</span>&lt;&gt;();</span><br><span class=\"line\">       cache.map(map);</span><br><span class=\"line\">       cache.evict(evict);</span><br><span class=\"line\">       cache.sizeLimit(size);</span><br><span class=\"line\">       cache.removeListeners(removeListeners);</span><br><span class=\"line\">       cache.load(load);</span><br><span class=\"line\">       cache.persist(persist);</span><br><span class=\"line\">       cache.slowListeners(slowListeners);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">       cache.init();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> CacheProxy.getProxy(cache);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.expire = <span class=\"keyword\">new</span> <span class=\"title class_\">CacheExpire</span>&lt;&gt;(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.load.load(<span class=\"built_in\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化持久化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.persist != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">InnerCachePersist</span>&lt;&gt;(<span class=\"built_in\">this</span>, persist);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>cache使用的是CacheExpire过期策略并将cache对象传入策略中实现过期删除，当调用expire方法时，key和过期时间会存入到expireMap，在实例化CacheExpire对象时初始化会启动一个单线程定时轮询执行器singleThreadScheduledExecutor，每过100ms调度一次，每次去expireMap中处理100个可能过期的key实现过期删除</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.houbb.cache.core.support.expire;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheExpire;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheRemoveListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheRemoveListenerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.constant.enums.CacheRemoveType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.listener.remove.CacheRemoveListenerContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.heaven.util.util.CollectionUtil;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.heaven.util.util.MapUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存过期-普通策略</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;K&gt; key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;V&gt; value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheExpire</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">ICacheExpire</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单次清空的数量限制</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">LIMIT</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 过期 map</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 空间换时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K, Long&gt; expireMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程执行类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">EXECUTOR_SERVICE</span> <span class=\"operator\">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CacheExpire</span><span class=\"params\">(ICache&lt;K, V&gt; cache)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cache = cache;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化任务</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class=\"keyword\">new</span> <span class=\"title class_\">ExpireThread</span>(), <span class=\"number\">100</span>, <span class=\"number\">100</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定时执行任务</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExpireThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//1.判断是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MapUtil.isEmpty(expireMap)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//2. 获取 key 进行处理</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(count &gt;= LIMIT) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                expireKey(entry.getKey(), entry.getValue());</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expire</span><span class=\"params\">(K key, <span class=\"type\">long</span> expireAt)</span> &#123;</span><br><span class=\"line\">        expireMap.put(key, expireAt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refreshExpire</span><span class=\"params\">(Collection&lt;K&gt; keyList)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CollectionUtil.isEmpty(keyList)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断大小，小的作为外循环。一般都是过期的 keys 比较小。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(keyList.size() &lt;= expireMap.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(K key : keyList) &#123;</span><br><span class=\"line\">                <span class=\"type\">Long</span> <span class=\"variable\">expireAt</span> <span class=\"operator\">=</span> expireMap.get(key);</span><br><span class=\"line\">                expireKey(key, expireAt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Map.Entry&lt;K, Long&gt; entry : expireMap.entrySet()) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.expireKey(entry.getKey(), entry.getValue());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">expireTime</span><span class=\"params\">(K key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> expireMap.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 过期处理 key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> expireAt 过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">expireKey</span><span class=\"params\">(<span class=\"keyword\">final</span> K key, <span class=\"keyword\">final</span> Long expireAt)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(expireAt == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(currentTime &gt;= expireAt) &#123;</span><br><span class=\"line\">            expireMap.remove(key);</span><br><span class=\"line\">            <span class=\"comment\">// 再移除缓存，后续可以通过惰性删除做补偿</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">removeValue</span> <span class=\"operator\">=</span> cache.remove(key);</span><br><span class=\"line\">            <span class=\"comment\">// 执行淘汰监听器</span></span><br><span class=\"line\">            ICacheRemoveListenerContext&lt;K,V&gt; removeListenerContext = CacheRemoveListenerContext.&lt;K,V&gt;newInstance().key(key).value(removeValue).type(CacheRemoveType.EXPIRE.code());</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(ICacheRemoveListener&lt;K,V&gt; listener : cache.removeListeners()) &#123;</span><br><span class=\"line\">                listener.listen(removeListenerContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>类似于 redis，我们采用定时删除的方案，就有一个问题：可能数据清理的不及时。</p>\n<p>那当我们查询时，可能获取到到是脏数据。</p>\n<p>于是就有一些人就想了，当我们关心某些数据时，才对数据做对应的删除判断操作，这样压力会小很多。</p>\n<p>算是一种折中方案。</p>\n<p>一般就是各种查询方法，比如我们获取 key 对应的值时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@CacheInterceptor(evict = true)</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1. 刷新所有过期信息</span></span><br><span class=\"line\">    <span class=\"type\">K</span> <span class=\"variable\">genericKey</span> <span class=\"operator\">=</span> (K) key;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.expire.refreshExpire(Collections.singletonList(genericKey));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在获取之前，先做一次数据的刷新。</p>\n<p>实现原理也非常简单，就是一个循环，然后作删除即可。</p>\n<p>这里加了一个小的优化：选择数量少的作为外循环。</p>\n<p>循环集合的时间复杂度是 O(n), map.get() 的时间复杂度是 O(1);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"54.螺旋矩阵","date":"2025-01-24T15:38:25.000Z","_content":"\n# 题目\n\n[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n提示\n\n给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n\n**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]\n**输出：**[1,2,3,6,9,8,7,4,5]\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n\n**输入：**matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n**输出：**[1,2,3,4,8,12,11,10,9,5,6,7]\n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 10`\n- `-100 <= matrix[i][j] <= 100`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        int m=matrix.length;\n        int n=matrix[0].length;\n        double num=Math.ceil(((double)Math.min(m,n))/2);\n        for(int i=0;i<num;i++)\n        {\n            for(int j=i;j<n-i;j++)\n            {\n                if(result.size()<m*n)\n                {\n                    result.add(matrix[i][j]);\n                }\n                \n            }\n            for(int j=i+1;j<m-i-1;j++)\n            {\n                if(result.size()<m*n)\n                {\n                    result.add(matrix[j][n-i-1]);\n                }\n                \n            }\n            for(int j=n-i-1;j>=i;j--)\n            {\n                if(result.size()<m*n)\n                {\n                    result.add(matrix[m-1-i][j]);\n                }\n                \n            }\n            for(int j=m-i-2;j>=i+1;j--)\n            {\n                if(result.size()<m*n)\n                {\n                     result.add(matrix[j][i]);\n                }\n               \n            }\n        }\n        return result;\n    }\n}\n```\n\n# 思路\n\n这个题是让螺旋记录矩阵，用模拟画圈法就行，如果是m*n的矩阵，画的圈数就是小的那个除二向上取余，每次画圈就是四个方向，如果没记录完就把他记录到结果中。时间复杂度O(m*n)\n","source":"_posts/54-螺旋矩阵.md","raw":"---\ntitle: 54.螺旋矩阵\ndate: 2025-01-24 23:38:25\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n提示\n\n给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n\n**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]\n**输出：**[1,2,3,6,9,8,7,4,5]\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n\n**输入：**matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n**输出：**[1,2,3,4,8,12,11,10,9,5,6,7]\n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 10`\n- `-100 <= matrix[i][j] <= 100`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        int m=matrix.length;\n        int n=matrix[0].length;\n        double num=Math.ceil(((double)Math.min(m,n))/2);\n        for(int i=0;i<num;i++)\n        {\n            for(int j=i;j<n-i;j++)\n            {\n                if(result.size()<m*n)\n                {\n                    result.add(matrix[i][j]);\n                }\n                \n            }\n            for(int j=i+1;j<m-i-1;j++)\n            {\n                if(result.size()<m*n)\n                {\n                    result.add(matrix[j][n-i-1]);\n                }\n                \n            }\n            for(int j=n-i-1;j>=i;j--)\n            {\n                if(result.size()<m*n)\n                {\n                    result.add(matrix[m-1-i][j]);\n                }\n                \n            }\n            for(int j=m-i-2;j>=i+1;j--)\n            {\n                if(result.size()<m*n)\n                {\n                     result.add(matrix[j][i]);\n                }\n               \n            }\n        }\n        return result;\n    }\n}\n```\n\n# 思路\n\n这个题是让螺旋记录矩阵，用模拟画圈法就行，如果是m*n的矩阵，画的圈数就是小的那个除二向上取余，每次画圈就是四个方向，如果没记录完就把他记录到结果中。时间复杂度O(m*n)\n","slug":"54-螺旋矩阵","published":1,"updated":"2025-01-24T15:47:18.146Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1x000n3ga8fkumff1o","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/spiral-matrix/\">54. 螺旋矩阵</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>提示</p>\n<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[1,2,3,6,9,8,7,4,5]</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br><strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 10</code></li>\n<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">spiralOrder</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> m=matrix.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> n=matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">double</span> num=Math.ceil(((<span class=\"type\">double</span>)Math.min(m,n))/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;num;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j&lt;n-i;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.add(matrix[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;m-i-<span class=\"number\">1</span>;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.add(matrix[j][n-i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=n-i-<span class=\"number\">1</span>;j&gt;=i;j--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.add(matrix[m-<span class=\"number\">1</span>-i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=m-i-<span class=\"number\">2</span>;j&gt;=i+<span class=\"number\">1</span>;j--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                     result.add(matrix[j][i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>这个题是让螺旋记录矩阵，用模拟画圈法就行，如果是m<em>n的矩阵，画的圈数就是小的那个除二向上取余，每次画圈就是四个方向，如果没记录完就把他记录到结果中。时间复杂度O(m</em>n)</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/spiral-matrix/\">54. 螺旋矩阵</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>提示</p>\n<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[1,2,3,6,9,8,7,4,5]</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br><strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 10</code></li>\n<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">spiralOrder</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> m=matrix.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> n=matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">double</span> num=Math.ceil(((<span class=\"type\">double</span>)Math.min(m,n))/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;num;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j&lt;n-i;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.add(matrix[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;m-i-<span class=\"number\">1</span>;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.add(matrix[j][n-i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=n-i-<span class=\"number\">1</span>;j&gt;=i;j--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result.add(matrix[m-<span class=\"number\">1</span>-i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=m-i-<span class=\"number\">2</span>;j&gt;=i+<span class=\"number\">1</span>;j--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(result.size()&lt;m*n)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                     result.add(matrix[j][i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>这个题是让螺旋记录矩阵，用模拟画圈法就行，如果是m<em>n的矩阵，画的圈数就是小的那个除二向上取余，每次画圈就是四个方向，如果没记录完就把他记录到结果中。时间复杂度O(m</em>n)</p>\n"},{"title":"localCache持久化和加载的实现","date":"2024-12-22T08:45:19.000Z","_content":"\n## 持久化的目的\n\n我们存储的信息都是直接放在内存中的，如果断电或者应用重启，那么内容就全部丢失了。\n\n有时候我们希望这些信息重启之后还在，就像 redis 重启一样。\n\n\n\nload 加载  \n\n## 说明\n\n在实现持久化之前，我们来看一下一个简单的需求：\n\n如何在缓存启动的时候，指定初始化加载的信息。\n\n## 实现思路\n\n这个也不难，我们在 cache 初始化的时候，直接设置对应的信息即可。\n\n## api\n\n为了便于后期拓展，定义 ICacheLoad 接口。\n\n```java\npublic interface ICacheLoad<K, V> {\n\n    /**\n     * 加载缓存信息\n     * @param cache 缓存\n     * @since 0.0.7\n     */\n    void load(final ICache<K,V> cache);\n\n}\n```\n\n## 自定义初始化策略\n\n我们在初始化的时候，放入 2 个固定的信息。\n\n```java\npublic class MyCacheLoad implements ICacheLoad<String,String> {\n\n    @Override\n    public void load(ICache<String, String> cache) {\n        cache.put(\"1\", \"1\");\n        cache.put(\"2\", \"2\");\n    }\n\n}\n```\n\n## 测试\n\n只需要在缓存初始化的时候，指定对应的加载实现类即可。\n\n```java\nICache<String, String> cache = CacheBs.<String,String>newInstance()\n        .load(new MyCacheLoad())\n        .build();\n\nAssert.assertEquals(2, cache.size());\n```\n\n# 持久化\n\n## 说明\n\n上面先介绍初始化加载，其实已经完成了 cache 持久化的一半。\n\n我们要做的另一件事，就是将 cache 的内容持久化到文件或者数据库，便于初始化的时候加载。\n\n## 接口定义\n\n为了便于灵活替换，我们定义一个持久化的接口。\n\n```java\npublic interface ICachePersist<K, V> {\n\n    /**\n     * 持久化缓存信息\n     * @param cache 缓存\n     * @since 0.0.7\n     */\n    void persist(final ICache<K, V> cache);\n\n}\n```\n\n## 简单实现\n\n我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。\n\n```java\npublic class CachePersistDbJson<K,V> implements ICachePersist<K,V> {\n\n    /**\n     * 数据库路径\n     * @since 0.0.8\n     */\n    private final String dbPath;\n\n    public CachePersistDbJson(String dbPath) {\n        this.dbPath = dbPath;\n    }\n\n    /**\n     * 持久化\n     * key长度 key+value\n     * 第一个空格，获取 key 的长度，然后截取\n     * @param cache 缓存\n     */\n    @Override\n    public void persist(ICache<K, V> cache) {\n        Set<Map.Entry<K,V>> entrySet = cache.entrySet();\n\n        // 创建文件\n        FileUtil.createFile(dbPath);\n        // 清空文件\n        FileUtil.truncate(dbPath);\n\n        for(Map.Entry<K,V> entry : entrySet) {\n            K key = entry.getKey();\n            Long expireTime = cache.expire().expireTime(key);\n            PersistEntry<K,V> persistEntry = new PersistEntry<>();\n            persistEntry.setKey(key);\n            persistEntry.setValue(entry.getValue());\n            persistEntry.setExpire(expireTime);\n\n            String line = JSON.toJSONString(persistEntry);\n            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);\n        }\n    }\n\n}\n```\n\n## 定时执行\n\n上面定义好了一种持久化的策略，但是没有提供对应的触发方式。\n\n我们就采用对用户透明的设计方式：定时执行。\n\n```java\npublic class InnerCachePersist<K,V> {\n\n    private static final Log log = LogFactory.getLog(InnerCachePersist.class);\n\n    /**\n     * 缓存信息\n     * @since 0.0.8\n     */\n    private final ICache<K,V> cache;\n\n    /**\n     * 缓存持久化策略\n     * @since 0.0.8\n     */\n    private final ICachePersist<K,V> persist;\n\n    /**\n     * 线程执行类\n     * @since 0.0.3\n     */\n    private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();\n\n    public InnerCachePersist(ICache<K, V> cache, ICachePersist<K, V> persist) {\n        this.cache = cache;\n        this.persist = persist;\n\n        // 初始化\n        this.init();\n    }\n\n    /**\n     * 初始化\n     * @since 0.0.8\n     */\n    private void init() {\n        EXECUTOR_SERVICE.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    log.info(\"开始持久化缓存信息\");\n                    persist.persist(cache);\n                    log.info(\"完成持久化缓存信息\");\n                } catch (Exception exception) {\n                    log.error(\"文件持久化异常\", exception);\n                }\n            }\n        }, 0, 10, TimeUnit.MINUTES);\n    }\n\n}enOption.APPEND);\n        }\n    }\n\n}\n```\n\n定时执行的时间间隔为 10min。\n\n## 测试\n\n我们只需要在创建 cache 时，指定我们的持久化策略即可。\n\n```java\nICache<String, String> cache = CacheBs.<String,String>newInstance()\n        .load(new MyCacheLoad())\n        .persist(CachePersists.<String, String>dbJson(\"1.rdb\"))\n        .build();\nAssert.assertEquals(2, cache.size());\nTimeUnit.SECONDS.sleep(5);\n```\n\n为了确保文件持久化完成，我们沉睡了一会儿。\n\n### 文件效果\n\n- 1.rdb\n\n生成的文件内容如下：\n\n```json\n{\"key\":\"2\",\"value\":\"2\"}\n{\"key\":\"1\",\"value\":\"1\"}\n```\n\n## 对应的缓存加载\n\n我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。\n\n```java\n/**\n * 加载策略-文件路径\n * @author binbin.hou\n * @since 0.0.8\n */\npublic class CacheLoadDbJson<K,V> implements ICacheLoad<K,V> {\n\n    private static final Log log = LogFactory.getLog(CacheLoadDbJson.class);\n\n    /**\n     * 文件路径\n     * @since 0.0.8\n     */\n    private final String dbPath;\n\n    public CacheLoadDbJson(String dbPath) {\n        this.dbPath = dbPath;\n    }\n\n    @Override\n    public void load(ICache<K, V> cache) {\n        List<String> lines = FileUtil.readAllLines(dbPath);\n        log.info(\"[load] 开始处理 path: {}\", dbPath);\n        if(CollectionUtil.isEmpty(lines)) {\n            log.info(\"[load] path: {} 文件内容为空，直接返回\", dbPath);\n            return;\n        }\n\n        for(String line : lines) {\n            if(StringUtil.isEmpty(line)) {\n                continue;\n            }\n\n            // 执行\n            // 简单的类型还行，复杂的这种反序列化会失败\n            PersistEntry<K,V> entry = JSON.parseObject(line, PersistEntry.class);\n\n            K key = entry.getKey();\n            V value = entry.getValue();\n            Long expire = entry.getExpire();\n\n            cache.put(key, value);\n            if(ObjectUtil.isNotNull(expire)) {\n                cache.expireAt(key, expire);\n            }\n        }\n        //nothing...\n    }\n}\n```\n\n然后在初始化时使用即可。\n","source":"_posts/localCache持久化和加载的实现.md","raw":"---\ntitle: localCache持久化和加载的实现\ndate: 2024-12-22 16:45:19\ntags: localCache\ncategories: 项目\n---\n\n## 持久化的目的\n\n我们存储的信息都是直接放在内存中的，如果断电或者应用重启，那么内容就全部丢失了。\n\n有时候我们希望这些信息重启之后还在，就像 redis 重启一样。\n\n\n\nload 加载  \n\n## 说明\n\n在实现持久化之前，我们来看一下一个简单的需求：\n\n如何在缓存启动的时候，指定初始化加载的信息。\n\n## 实现思路\n\n这个也不难，我们在 cache 初始化的时候，直接设置对应的信息即可。\n\n## api\n\n为了便于后期拓展，定义 ICacheLoad 接口。\n\n```java\npublic interface ICacheLoad<K, V> {\n\n    /**\n     * 加载缓存信息\n     * @param cache 缓存\n     * @since 0.0.7\n     */\n    void load(final ICache<K,V> cache);\n\n}\n```\n\n## 自定义初始化策略\n\n我们在初始化的时候，放入 2 个固定的信息。\n\n```java\npublic class MyCacheLoad implements ICacheLoad<String,String> {\n\n    @Override\n    public void load(ICache<String, String> cache) {\n        cache.put(\"1\", \"1\");\n        cache.put(\"2\", \"2\");\n    }\n\n}\n```\n\n## 测试\n\n只需要在缓存初始化的时候，指定对应的加载实现类即可。\n\n```java\nICache<String, String> cache = CacheBs.<String,String>newInstance()\n        .load(new MyCacheLoad())\n        .build();\n\nAssert.assertEquals(2, cache.size());\n```\n\n# 持久化\n\n## 说明\n\n上面先介绍初始化加载，其实已经完成了 cache 持久化的一半。\n\n我们要做的另一件事，就是将 cache 的内容持久化到文件或者数据库，便于初始化的时候加载。\n\n## 接口定义\n\n为了便于灵活替换，我们定义一个持久化的接口。\n\n```java\npublic interface ICachePersist<K, V> {\n\n    /**\n     * 持久化缓存信息\n     * @param cache 缓存\n     * @since 0.0.7\n     */\n    void persist(final ICache<K, V> cache);\n\n}\n```\n\n## 简单实现\n\n我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。\n\n```java\npublic class CachePersistDbJson<K,V> implements ICachePersist<K,V> {\n\n    /**\n     * 数据库路径\n     * @since 0.0.8\n     */\n    private final String dbPath;\n\n    public CachePersistDbJson(String dbPath) {\n        this.dbPath = dbPath;\n    }\n\n    /**\n     * 持久化\n     * key长度 key+value\n     * 第一个空格，获取 key 的长度，然后截取\n     * @param cache 缓存\n     */\n    @Override\n    public void persist(ICache<K, V> cache) {\n        Set<Map.Entry<K,V>> entrySet = cache.entrySet();\n\n        // 创建文件\n        FileUtil.createFile(dbPath);\n        // 清空文件\n        FileUtil.truncate(dbPath);\n\n        for(Map.Entry<K,V> entry : entrySet) {\n            K key = entry.getKey();\n            Long expireTime = cache.expire().expireTime(key);\n            PersistEntry<K,V> persistEntry = new PersistEntry<>();\n            persistEntry.setKey(key);\n            persistEntry.setValue(entry.getValue());\n            persistEntry.setExpire(expireTime);\n\n            String line = JSON.toJSONString(persistEntry);\n            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);\n        }\n    }\n\n}\n```\n\n## 定时执行\n\n上面定义好了一种持久化的策略，但是没有提供对应的触发方式。\n\n我们就采用对用户透明的设计方式：定时执行。\n\n```java\npublic class InnerCachePersist<K,V> {\n\n    private static final Log log = LogFactory.getLog(InnerCachePersist.class);\n\n    /**\n     * 缓存信息\n     * @since 0.0.8\n     */\n    private final ICache<K,V> cache;\n\n    /**\n     * 缓存持久化策略\n     * @since 0.0.8\n     */\n    private final ICachePersist<K,V> persist;\n\n    /**\n     * 线程执行类\n     * @since 0.0.3\n     */\n    private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();\n\n    public InnerCachePersist(ICache<K, V> cache, ICachePersist<K, V> persist) {\n        this.cache = cache;\n        this.persist = persist;\n\n        // 初始化\n        this.init();\n    }\n\n    /**\n     * 初始化\n     * @since 0.0.8\n     */\n    private void init() {\n        EXECUTOR_SERVICE.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    log.info(\"开始持久化缓存信息\");\n                    persist.persist(cache);\n                    log.info(\"完成持久化缓存信息\");\n                } catch (Exception exception) {\n                    log.error(\"文件持久化异常\", exception);\n                }\n            }\n        }, 0, 10, TimeUnit.MINUTES);\n    }\n\n}enOption.APPEND);\n        }\n    }\n\n}\n```\n\n定时执行的时间间隔为 10min。\n\n## 测试\n\n我们只需要在创建 cache 时，指定我们的持久化策略即可。\n\n```java\nICache<String, String> cache = CacheBs.<String,String>newInstance()\n        .load(new MyCacheLoad())\n        .persist(CachePersists.<String, String>dbJson(\"1.rdb\"))\n        .build();\nAssert.assertEquals(2, cache.size());\nTimeUnit.SECONDS.sleep(5);\n```\n\n为了确保文件持久化完成，我们沉睡了一会儿。\n\n### 文件效果\n\n- 1.rdb\n\n生成的文件内容如下：\n\n```json\n{\"key\":\"2\",\"value\":\"2\"}\n{\"key\":\"1\",\"value\":\"1\"}\n```\n\n## 对应的缓存加载\n\n我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。\n\n```java\n/**\n * 加载策略-文件路径\n * @author binbin.hou\n * @since 0.0.8\n */\npublic class CacheLoadDbJson<K,V> implements ICacheLoad<K,V> {\n\n    private static final Log log = LogFactory.getLog(CacheLoadDbJson.class);\n\n    /**\n     * 文件路径\n     * @since 0.0.8\n     */\n    private final String dbPath;\n\n    public CacheLoadDbJson(String dbPath) {\n        this.dbPath = dbPath;\n    }\n\n    @Override\n    public void load(ICache<K, V> cache) {\n        List<String> lines = FileUtil.readAllLines(dbPath);\n        log.info(\"[load] 开始处理 path: {}\", dbPath);\n        if(CollectionUtil.isEmpty(lines)) {\n            log.info(\"[load] path: {} 文件内容为空，直接返回\", dbPath);\n            return;\n        }\n\n        for(String line : lines) {\n            if(StringUtil.isEmpty(line)) {\n                continue;\n            }\n\n            // 执行\n            // 简单的类型还行，复杂的这种反序列化会失败\n            PersistEntry<K,V> entry = JSON.parseObject(line, PersistEntry.class);\n\n            K key = entry.getKey();\n            V value = entry.getValue();\n            Long expire = entry.getExpire();\n\n            cache.put(key, value);\n            if(ObjectUtil.isNotNull(expire)) {\n                cache.expireAt(key, expire);\n            }\n        }\n        //nothing...\n    }\n}\n```\n\n然后在初始化时使用即可。\n","slug":"localCache持久化和加载的实现","published":1,"updated":"2024-12-22T09:20:39.240Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1y000q3ga85gbx1539","content":"<h2 id=\"持久化的目的\"><a href=\"#持久化的目的\" class=\"headerlink\" title=\"持久化的目的\"></a>持久化的目的</h2><p>我们存储的信息都是直接放在内存中的，如果断电或者应用重启，那么内容就全部丢失了。</p>\n<p>有时候我们希望这些信息重启之后还在，就像 redis 重启一样。</p>\n<p>load 加载  </p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>在实现持久化之前，我们来看一下一个简单的需求：</p>\n<p>如何在缓存启动的时候，指定初始化加载的信息。</p>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>这个也不难，我们在 cache 初始化的时候，直接设置对应的信息即可。</p>\n<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><p>为了便于后期拓展，定义 ICacheLoad 接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICacheLoad</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cache 缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(<span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义初始化策略\"><a href=\"#自定义初始化策略\" class=\"headerlink\" title=\"自定义初始化策略\"></a>自定义初始化策略</h2><p>我们在初始化的时候，放入 2 个固定的信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCacheLoad</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ICacheLoad</span>&lt;String,String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(ICache&lt;String, String&gt; cache)</span> &#123;</span><br><span class=\"line\">        cache.put(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        cache.put(<span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>只需要在缓存初始化的时候，指定对应的加载实现类即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class=\"line\">        .load(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCacheLoad</span>())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Assert.assertEquals(<span class=\"number\">2</span>, cache.size());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><h2 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>上面先介绍初始化加载，其实已经完成了 cache 持久化的一半。</p>\n<p>我们要做的另一件事，就是将 cache 的内容持久化到文件或者数据库，便于初始化的时候加载。</p>\n<h2 id=\"接口定义\"><a href=\"#接口定义\" class=\"headerlink\" title=\"接口定义\"></a>接口定义</h2><p>为了便于灵活替换，我们定义一个持久化的接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICachePersist</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 持久化缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cache 缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">persist</span><span class=\"params\">(<span class=\"keyword\">final</span> ICache&lt;K, V&gt; cache)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><p>我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CachePersistDbJson</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">ICachePersist</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数据库路径</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String dbPath;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CachePersistDbJson</span><span class=\"params\">(String dbPath)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dbPath = dbPath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 持久化</span></span><br><span class=\"line\"><span class=\"comment\">     * key长度 key+value</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cache 缓存</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">persist</span><span class=\"params\">(ICache&lt;K, V&gt; cache)</span> &#123;</span><br><span class=\"line\">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = cache.entrySet();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建文件</span></span><br><span class=\"line\">        FileUtil.createFile(dbPath);</span><br><span class=\"line\">        <span class=\"comment\">// 清空文件</span></span><br><span class=\"line\">        FileUtil.truncate(dbPath);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Map.Entry&lt;K,V&gt; entry : entrySet) &#123;</span><br><span class=\"line\">            <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> cache.expire().expireTime(key);</span><br><span class=\"line\">            PersistEntry&lt;K,V&gt; persistEntry = <span class=\"keyword\">new</span> <span class=\"title class_\">PersistEntry</span>&lt;&gt;();</span><br><span class=\"line\">            persistEntry.setKey(key);</span><br><span class=\"line\">            persistEntry.setValue(entry.getValue());</span><br><span class=\"line\">            persistEntry.setExpire(expireTime);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> JSON.toJSONString(persistEntry);</span><br><span class=\"line\">            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时执行\"><a href=\"#定时执行\" class=\"headerlink\" title=\"定时执行\"></a>定时执行</h2><p>上面定义好了一种持久化的策略，但是没有提供对应的触发方式。</p>\n<p>我们就采用对用户透明的设计方式：定时执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerCachePersist</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Log</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LogFactory.getLog(InnerCachePersist.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存持久化策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ICachePersist&lt;K,V&gt; persist;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程执行类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">EXECUTOR_SERVICE</span> <span class=\"operator\">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">InnerCachePersist</span><span class=\"params\">(ICache&lt;K, V&gt; cache, ICachePersist&lt;K, V&gt; persist)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cache = cache;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.persist = persist;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;开始持久化缓存信息&quot;</span>);</span><br><span class=\"line\">                    persist.persist(cache);</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;完成持久化缓存信息&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;文件持久化异常&quot;</span>, exception);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>, <span class=\"number\">10</span>, TimeUnit.MINUTES);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;enOption.APPEND);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定时执行的时间间隔为 10min。</p>\n<h2 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>我们只需要在创建 cache 时，指定我们的持久化策略即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class=\"line\">        .load(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCacheLoad</span>())</span><br><span class=\"line\">        .persist(CachePersists.&lt;String, String&gt;dbJson(<span class=\"string\">&quot;1.rdb&quot;</span>))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">Assert.assertEquals(<span class=\"number\">2</span>, cache.size());</span><br><span class=\"line\">TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>为了确保文件持久化完成，我们沉睡了一会儿。</p>\n<h3 id=\"文件效果\"><a href=\"#文件效果\" class=\"headerlink\" title=\"文件效果\"></a>文件效果</h3><ul>\n<li>1.rdb</li>\n</ul>\n<p>生成的文件内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;key&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;key&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对应的缓存加载\"><a href=\"#对应的缓存加载\" class=\"headerlink\" title=\"对应的缓存加载\"></a>对应的缓存加载</h2><p>我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 加载策略-文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheLoadDbJson</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">ICacheLoad</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Log</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LogFactory.getLog(CacheLoadDbJson.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 文件路径</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String dbPath;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CacheLoadDbJson</span><span class=\"params\">(String dbPath)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dbPath = dbPath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(ICache&lt;K, V&gt; cache)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String line : lines) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class=\"line\">            PersistEntry&lt;K,V&gt; entry = JSON.parseObject(line, PersistEntry.class);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> entry.getValue();</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">expire</span> <span class=\"operator\">=</span> entry.getExpire();</span><br><span class=\"line\"></span><br><span class=\"line\">            cache.put(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ObjectUtil.isNotNull(expire)) &#123;</span><br><span class=\"line\">                cache.expireAt(key, expire);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//nothing...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在初始化时使用即可。</p>\n","cover":false,"excerpt":"","more":"<h2 id=\"持久化的目的\"><a href=\"#持久化的目的\" class=\"headerlink\" title=\"持久化的目的\"></a>持久化的目的</h2><p>我们存储的信息都是直接放在内存中的，如果断电或者应用重启，那么内容就全部丢失了。</p>\n<p>有时候我们希望这些信息重启之后还在，就像 redis 重启一样。</p>\n<p>load 加载  </p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>在实现持久化之前，我们来看一下一个简单的需求：</p>\n<p>如何在缓存启动的时候，指定初始化加载的信息。</p>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>这个也不难，我们在 cache 初始化的时候，直接设置对应的信息即可。</p>\n<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><p>为了便于后期拓展，定义 ICacheLoad 接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICacheLoad</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cache 缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(<span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义初始化策略\"><a href=\"#自定义初始化策略\" class=\"headerlink\" title=\"自定义初始化策略\"></a>自定义初始化策略</h2><p>我们在初始化的时候，放入 2 个固定的信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCacheLoad</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ICacheLoad</span>&lt;String,String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(ICache&lt;String, String&gt; cache)</span> &#123;</span><br><span class=\"line\">        cache.put(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        cache.put(<span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>只需要在缓存初始化的时候，指定对应的加载实现类即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class=\"line\">        .load(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCacheLoad</span>())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Assert.assertEquals(<span class=\"number\">2</span>, cache.size());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><h2 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>上面先介绍初始化加载，其实已经完成了 cache 持久化的一半。</p>\n<p>我们要做的另一件事，就是将 cache 的内容持久化到文件或者数据库，便于初始化的时候加载。</p>\n<h2 id=\"接口定义\"><a href=\"#接口定义\" class=\"headerlink\" title=\"接口定义\"></a>接口定义</h2><p>为了便于灵活替换，我们定义一个持久化的接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICachePersist</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 持久化缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cache 缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">persist</span><span class=\"params\">(<span class=\"keyword\">final</span> ICache&lt;K, V&gt; cache)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><p>我们实现一个最简单的基于 json 的持久化，当然后期可以添加类似于 AOF 的持久化模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CachePersistDbJson</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">ICachePersist</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数据库路径</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String dbPath;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CachePersistDbJson</span><span class=\"params\">(String dbPath)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dbPath = dbPath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 持久化</span></span><br><span class=\"line\"><span class=\"comment\">     * key长度 key+value</span></span><br><span class=\"line\"><span class=\"comment\">     * 第一个空格，获取 key 的长度，然后截取</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cache 缓存</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">persist</span><span class=\"params\">(ICache&lt;K, V&gt; cache)</span> &#123;</span><br><span class=\"line\">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = cache.entrySet();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建文件</span></span><br><span class=\"line\">        FileUtil.createFile(dbPath);</span><br><span class=\"line\">        <span class=\"comment\">// 清空文件</span></span><br><span class=\"line\">        FileUtil.truncate(dbPath);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Map.Entry&lt;K,V&gt; entry : entrySet) &#123;</span><br><span class=\"line\">            <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">expireTime</span> <span class=\"operator\">=</span> cache.expire().expireTime(key);</span><br><span class=\"line\">            PersistEntry&lt;K,V&gt; persistEntry = <span class=\"keyword\">new</span> <span class=\"title class_\">PersistEntry</span>&lt;&gt;();</span><br><span class=\"line\">            persistEntry.setKey(key);</span><br><span class=\"line\">            persistEntry.setValue(entry.getValue());</span><br><span class=\"line\">            persistEntry.setExpire(expireTime);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> JSON.toJSONString(persistEntry);</span><br><span class=\"line\">            FileUtil.write(dbPath, line, StandardOpenOption.APPEND);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时执行\"><a href=\"#定时执行\" class=\"headerlink\" title=\"定时执行\"></a>定时执行</h2><p>上面定义好了一种持久化的策略，但是没有提供对应的触发方式。</p>\n<p>我们就采用对用户透明的设计方式：定时执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerCachePersist</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Log</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LogFactory.getLog(InnerCachePersist.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存持久化策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ICachePersist&lt;K,V&gt; persist;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 线程执行类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ScheduledExecutorService</span> <span class=\"variable\">EXECUTOR_SERVICE</span> <span class=\"operator\">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">InnerCachePersist</span><span class=\"params\">(ICache&lt;K, V&gt; cache, ICachePersist&lt;K, V&gt; persist)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cache = cache;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.persist = persist;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        EXECUTOR_SERVICE.scheduleAtFixedRate(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;开始持久化缓存信息&quot;</span>);</span><br><span class=\"line\">                    persist.persist(cache);</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;完成持久化缓存信息&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;文件持久化异常&quot;</span>, exception);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>, <span class=\"number\">10</span>, TimeUnit.MINUTES);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;enOption.APPEND);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定时执行的时间间隔为 10min。</p>\n<h2 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>我们只需要在创建 cache 时，指定我们的持久化策略即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ICache&lt;String, String&gt; cache = CacheBs.&lt;String,String&gt;newInstance()</span><br><span class=\"line\">        .load(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCacheLoad</span>())</span><br><span class=\"line\">        .persist(CachePersists.&lt;String, String&gt;dbJson(<span class=\"string\">&quot;1.rdb&quot;</span>))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">Assert.assertEquals(<span class=\"number\">2</span>, cache.size());</span><br><span class=\"line\">TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>为了确保文件持久化完成，我们沉睡了一会儿。</p>\n<h3 id=\"文件效果\"><a href=\"#文件效果\" class=\"headerlink\" title=\"文件效果\"></a>文件效果</h3><ul>\n<li>1.rdb</li>\n</ul>\n<p>生成的文件内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;key&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;2&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;key&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对应的缓存加载\"><a href=\"#对应的缓存加载\" class=\"headerlink\" title=\"对应的缓存加载\"></a>对应的缓存加载</h2><p>我们只需要实现以下对应的加载即可，解析文件，然后初始化 cache。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 加载策略-文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheLoadDbJson</span>&lt;K,V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">ICacheLoad</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Log</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LogFactory.getLog(CacheLoadDbJson.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 文件路径</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String dbPath;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CacheLoadDbJson</span><span class=\"params\">(String dbPath)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dbPath = dbPath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(ICache&lt;K, V&gt; cache)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; lines = FileUtil.readAllLines(dbPath);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;[load] 开始处理 path: &#123;&#125;&quot;</span>, dbPath);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CollectionUtil.isEmpty(lines)) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;[load] path: &#123;&#125; 文件内容为空，直接返回&quot;</span>, dbPath);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String line : lines) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(StringUtil.isEmpty(line)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 简单的类型还行，复杂的这种反序列化会失败</span></span><br><span class=\"line\">            PersistEntry&lt;K,V&gt; entry = JSON.parseObject(line, PersistEntry.class);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> entry.getKey();</span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> entry.getValue();</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">expire</span> <span class=\"operator\">=</span> entry.getExpire();</span><br><span class=\"line\"></span><br><span class=\"line\">            cache.put(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ObjectUtil.isNotNull(expire)) &#123;</span><br><span class=\"line\">                cache.expireAt(key, expire);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//nothing...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在初始化时使用即可。</p>\n"},{"title":"java中的代理","date":"2024-12-14T03:43:38.000Z","_content":"\n在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：**静态代理**和**动态代理**。\n\n### 1. **静态代理**\n\n静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。\n\n#### 示例：\n\n```java\n// 目标类\npublic class RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\n// 代理类\npublic class ProxySubject implements Subject {\n    private RealSubject realSubject;\n\n    public ProxySubject(RealSubject realSubject) {\n        this.realSubject = realSubject;\n    }\n\n    @Override\n    public void request() {\n        System.out.println(\"ProxySubject before request.\");\n        realSubject.request();\n        System.out.println(\"ProxySubject after request.\");\n    }\n}\n\n// 接口\npublic interface Subject {\n    void request();\n}\n\n// 使用代理\npublic class Main {\n    public static void main(String[] args) {\n        Subject subject = new ProxySubject(new RealSubject());\n        subject.request();\n    }\n}\n```\n\n输出：\n\n```\nProxySubject before request.\nRealSubject request.\nProxySubject after request.\n```\n\n### 2. **动态代理**\n\n动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 `java.lang.reflect.Proxy` 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。\n\nJava 动态代理需要以下几个组成部分：\n\n- **接口**：被代理的类或接口。\n- **InvocationHandler**：代理类的处理器，实现了 `invoke` 方法，负责代理行为。\n\n#### 示例：\n\n```java\nimport java.lang.reflect.*;\n\ninterface Subject {\n    void request();\n}\n\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\nclass ProxyHandler implements InvocationHandler {\n    private Object target;\n\n    public ProxyHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before invoking \" + method.getName());\n        Object result = method.invoke(target, args);  // 调用真实方法\n        System.out.println(\"After invoking \" + method.getName());\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        RealSubject realSubject = new RealSubject();\n        Subject proxySubject = (Subject) Proxy.newProxyInstance(\n            RealSubject.class.getClassLoader(),\n            new Class[]{Subject.class},\n            new ProxyHandler(realSubject)\n        );\n\n        proxySubject.request();\n    }\n}\n```\n\n输出：\n\n```\nBefore invoking request\nRealSubject request.\nAfter invoking request\n```\n\n### 3. **CGLIB 代理**\n\n除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。\n\n### 4. **代理的应用场景**\n\n- **日志记录**：在方法调用前后记录日志。\n- **性能监控**：在方法调用前后记录时间。\n- **权限控制**：在方法调用前检查用户权限。\n- **缓存**：使用代理实现方法的缓存。\n- **事务管理**：在方法调用前开启事务，调用后提交或回滚事务。\n\n### 总结\n\nJava 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。\n","source":"_posts/java中的代理.md","raw":"---\ntitle: java中的代理\ndate: 2024-12-14 11:43:38\ntags: java基础\ncategories: 八股文\n---\n\n在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：**静态代理**和**动态代理**。\n\n### 1. **静态代理**\n\n静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。\n\n#### 示例：\n\n```java\n// 目标类\npublic class RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\n// 代理类\npublic class ProxySubject implements Subject {\n    private RealSubject realSubject;\n\n    public ProxySubject(RealSubject realSubject) {\n        this.realSubject = realSubject;\n    }\n\n    @Override\n    public void request() {\n        System.out.println(\"ProxySubject before request.\");\n        realSubject.request();\n        System.out.println(\"ProxySubject after request.\");\n    }\n}\n\n// 接口\npublic interface Subject {\n    void request();\n}\n\n// 使用代理\npublic class Main {\n    public static void main(String[] args) {\n        Subject subject = new ProxySubject(new RealSubject());\n        subject.request();\n    }\n}\n```\n\n输出：\n\n```\nProxySubject before request.\nRealSubject request.\nProxySubject after request.\n```\n\n### 2. **动态代理**\n\n动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 `java.lang.reflect.Proxy` 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。\n\nJava 动态代理需要以下几个组成部分：\n\n- **接口**：被代理的类或接口。\n- **InvocationHandler**：代理类的处理器，实现了 `invoke` 方法，负责代理行为。\n\n#### 示例：\n\n```java\nimport java.lang.reflect.*;\n\ninterface Subject {\n    void request();\n}\n\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\nclass ProxyHandler implements InvocationHandler {\n    private Object target;\n\n    public ProxyHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before invoking \" + method.getName());\n        Object result = method.invoke(target, args);  // 调用真实方法\n        System.out.println(\"After invoking \" + method.getName());\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        RealSubject realSubject = new RealSubject();\n        Subject proxySubject = (Subject) Proxy.newProxyInstance(\n            RealSubject.class.getClassLoader(),\n            new Class[]{Subject.class},\n            new ProxyHandler(realSubject)\n        );\n\n        proxySubject.request();\n    }\n}\n```\n\n输出：\n\n```\nBefore invoking request\nRealSubject request.\nAfter invoking request\n```\n\n### 3. **CGLIB 代理**\n\n除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。\n\n### 4. **代理的应用场景**\n\n- **日志记录**：在方法调用前后记录日志。\n- **性能监控**：在方法调用前后记录时间。\n- **权限控制**：在方法调用前检查用户权限。\n- **缓存**：使用代理实现方法的缓存。\n- **事务管理**：在方法调用前开启事务，调用后提交或回滚事务。\n\n### 总结\n\nJava 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。\n","slug":"java中的代理","published":1,"updated":"2024-12-14T07:50:14.235Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1z000v3ga8e77mfpkb","content":"<p>在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：<strong>静态代理</strong>和<strong>动态代理</strong>。</p>\n<h3 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. <strong>静态代理</strong></h3><p>静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxySubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealSubject realSubject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxySubject</span><span class=\"params\">(RealSubject realSubject)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.realSubject = realSubject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject before request.&quot;</span>);</span><br><span class=\"line\">        realSubject.request();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject after request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxySubject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>());</span><br><span class=\"line\">        subject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxySubject before request.</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">ProxySubject after request.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. <strong>动态代理</strong></h3><p>动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 <code>java.lang.reflect.Proxy</code> 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。</p>\n<p>Java 动态代理需要以下几个组成部分：</p>\n<ul>\n<li><strong>接口</strong>：被代理的类或接口。</li>\n<li><strong>InvocationHandler</strong>：代理类的处理器，实现了 <code>invoke</code> 方法，负责代理行为。</li>\n</ul>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);  <span class=\"comment\">// 调用真实方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RealSubject</span> <span class=\"variable\">realSubject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>();</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">proxySubject</span> <span class=\"operator\">=</span> (Subject) Proxy.newProxyInstance(</span><br><span class=\"line\">            RealSubject.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;Subject.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyHandler</span>(realSubject)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        proxySubject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before invoking request</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">After invoking request</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-CGLIB-代理\"><a href=\"#3-CGLIB-代理\" class=\"headerlink\" title=\"3. CGLIB 代理\"></a>3. <strong>CGLIB 代理</strong></h3><p>除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。</p>\n<h3 id=\"4-代理的应用场景\"><a href=\"#4-代理的应用场景\" class=\"headerlink\" title=\"4. 代理的应用场景\"></a>4. <strong>代理的应用场景</strong></h3><ul>\n<li><strong>日志记录</strong>：在方法调用前后记录日志。</li>\n<li><strong>性能监控</strong>：在方法调用前后记录时间。</li>\n<li><strong>权限控制</strong>：在方法调用前检查用户权限。</li>\n<li><strong>缓存</strong>：使用代理实现方法的缓存。</li>\n<li><strong>事务管理</strong>：在方法调用前开启事务，调用后提交或回滚事务。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。</p>\n","cover":false,"excerpt":"","more":"<p>在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：<strong>静态代理</strong>和<strong>动态代理</strong>。</p>\n<h3 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. <strong>静态代理</strong></h3><p>静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxySubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealSubject realSubject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxySubject</span><span class=\"params\">(RealSubject realSubject)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.realSubject = realSubject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject before request.&quot;</span>);</span><br><span class=\"line\">        realSubject.request();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject after request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxySubject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>());</span><br><span class=\"line\">        subject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxySubject before request.</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">ProxySubject after request.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. <strong>动态代理</strong></h3><p>动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 <code>java.lang.reflect.Proxy</code> 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。</p>\n<p>Java 动态代理需要以下几个组成部分：</p>\n<ul>\n<li><strong>接口</strong>：被代理的类或接口。</li>\n<li><strong>InvocationHandler</strong>：代理类的处理器，实现了 <code>invoke</code> 方法，负责代理行为。</li>\n</ul>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);  <span class=\"comment\">// 调用真实方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RealSubject</span> <span class=\"variable\">realSubject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>();</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">proxySubject</span> <span class=\"operator\">=</span> (Subject) Proxy.newProxyInstance(</span><br><span class=\"line\">            RealSubject.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;Subject.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyHandler</span>(realSubject)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        proxySubject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before invoking request</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">After invoking request</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-CGLIB-代理\"><a href=\"#3-CGLIB-代理\" class=\"headerlink\" title=\"3. CGLIB 代理\"></a>3. <strong>CGLIB 代理</strong></h3><p>除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。</p>\n<h3 id=\"4-代理的应用场景\"><a href=\"#4-代理的应用场景\" class=\"headerlink\" title=\"4. 代理的应用场景\"></a>4. <strong>代理的应用场景</strong></h3><ul>\n<li><strong>日志记录</strong>：在方法调用前后记录日志。</li>\n<li><strong>性能监控</strong>：在方法调用前后记录时间。</li>\n<li><strong>权限控制</strong>：在方法调用前检查用户权限。</li>\n<li><strong>缓存</strong>：使用代理实现方法的缓存。</li>\n<li><strong>事务管理</strong>：在方法调用前开启事务，调用后提交或回滚事务。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。</p>\n"},{"title":"mysql列的联合索引什么时候生效","date":"2025-01-14T11:00:21.000Z","_content":"\n**联合索引（Composite Index）** 是指在数据库中为多个列创建的索引，它可以提高查询性能，尤其是在涉及多个列的条件查询时。然而，联合索引的生效与使用条件有关。以下是几个常见的情况，说明联合索引何时生效：\n\n### **1. 查询条件中涉及索引的前缀列**\n\n联合索引生效的关键在于查询中是否使用了索引的前缀列（即联合索引中左侧的列）。联合索引按列顺序存储数据，因此，只有当查询条件涉及到联合索引的前缀部分时，索引才能生效。\n\n例如，假设有以下联合索引：\n\nsql\n\n复制代码\n\n`CREATE INDEX idx_name ON table_name (col1, col2, col3);`\n\n在此例中，`(col1, col2, col3)` 是联合索引。\n\n#### **生效情况：**\n\n- **使用前缀列：** 只要查询条件中包含索引的**前缀部分**，索引都会生效。\n  - 例如，查询 `col1` 或 `col1, col2`，联合索引都会生效。\n  - 查询条件 `col1 = ?` 或 `col1 = ? AND col2 = ?`，索引会生效。\n  - 查询条件 `col1 = ? AND col2 = ? AND col3 = ?`，索引会生效。\n\n#### **不生效情况：**\n\n- **缺少前缀列：** 如果查询条件中没有涉及联合索引的前缀列，则联合索引不会生效。\n  \n  - 例如，查询 `col2 = ?` 或 `col3 = ?`，联合索引就不会生效，虽然索引中的后续列（`col2` 和 `col3`）参与了查询。\n  \n  - **注意：** 只有索引中的前缀列 `col1` 能影响查询是否命中联合索引。\n\n### **2. 查询顺序是否匹配索引顺序**\n\n联合索引的列顺序对索引的使用至关重要。查询中的列顺序必须与联合索引中定义的列顺序匹配或前缀列匹配，才能充分利用联合索引。\n\n例如，假设有联合索引 `(col1, col2)`，而查询中使用的是 `col2, col1` 顺序：\n\nsql\n\n复制代码\n\n`SELECT * FROM table_name WHERE col2 = ? AND col1 = ?;`\n\n此查询不会使用索引，因为索引中的列顺序是 `(col1, col2)`，而查询的顺序是 `(col2, col1)`，它不符合索引顺序。\n\n### **3. 使用 LIKE、BETWEEN、IN 等查询操作**\n\n联合索引在处理 **`LIKE`**、**`BETWEEN`** 和 **`IN`** 等条件时也会生效，但具体情况取决于操作的使用。\n\n- **LIKE 查询：**\n  \n  - 如果 `LIKE` 查询的模式以固定字符开头，索引通常会生效。\n  - 例如：`WHERE col1 LIKE 'abc%'` 会利用 `(col1, col2)` 索引。\n  - 如果 `LIKE` 查询以 `%` 开头，索引一般不会生效，因为无法通过前缀匹配。\n\n- **BETWEEN 查询：**\n  \n  - `BETWEEN` 查询通常能使用联合索引，前提是查询的列符合索引前缀。\n  \n  例如，`WHERE col1 BETWEEN 1 AND 10 AND col2 = ?` 会利用 `(col1, col2)` 索引。\n\n- **IN 查询：**\n  \n  - `IN` 操作符能利用联合索引，只要它的列顺序符合联合索引中的顺序。\n  \n  例如，`WHERE col1 IN (1, 2, 3) AND col2 = ?` 会利用 `(col1, col2)` 索引。\n\n### **4. 使用范围查询**\n\n- 当查询条件中有范围操作（如 `>`, `<`, `BETWEEN`, `!=`），联合索引通常能在范围查询列之前部分生效，但范围查询后面的列可能会失效。\n  \n  例如，`WHERE col1 = ? AND col2 > ?` 会使用 `(col1, col2)` 索引，但 `col2` 的范围查询后，索引可能不再生效。\n\n### **5. 全表扫描 vs. 索引扫描**\n\n- 如果联合索引的列没有有效地匹配查询条件，数据库优化器可能会选择放弃使用索引，转而执行全表扫描，尤其是在索引选择性不高的情况下。\n\n### **总结**\n\n联合索引生效的条件主要有：\n\n1. 查询条件中涉及联合索引的前缀列（即索引中的左侧列）。\n2. 查询条件的列顺序与联合索引的列顺序一致。\n3. 使用范围查询时，索引可能只在前缀列生效。\n4. LIKE、IN、BETWEEN 等操作符可以在特定情况下利用联合索引，但要满足顺序和前缀的条件。\n\n因此，在设计和使用联合索引时，最好按照查询的实际需求来调整索引的列顺序和使用方式。\n","source":"_posts/mysql列的联合索引什么时候生效.md","raw":"---\ntitle: mysql列的联合索引什么时候生效\ndate: 2025-01-14 19:00:21\ntags: mysql\ncategories: 八股文\n---\n\n**联合索引（Composite Index）** 是指在数据库中为多个列创建的索引，它可以提高查询性能，尤其是在涉及多个列的条件查询时。然而，联合索引的生效与使用条件有关。以下是几个常见的情况，说明联合索引何时生效：\n\n### **1. 查询条件中涉及索引的前缀列**\n\n联合索引生效的关键在于查询中是否使用了索引的前缀列（即联合索引中左侧的列）。联合索引按列顺序存储数据，因此，只有当查询条件涉及到联合索引的前缀部分时，索引才能生效。\n\n例如，假设有以下联合索引：\n\nsql\n\n复制代码\n\n`CREATE INDEX idx_name ON table_name (col1, col2, col3);`\n\n在此例中，`(col1, col2, col3)` 是联合索引。\n\n#### **生效情况：**\n\n- **使用前缀列：** 只要查询条件中包含索引的**前缀部分**，索引都会生效。\n  - 例如，查询 `col1` 或 `col1, col2`，联合索引都会生效。\n  - 查询条件 `col1 = ?` 或 `col1 = ? AND col2 = ?`，索引会生效。\n  - 查询条件 `col1 = ? AND col2 = ? AND col3 = ?`，索引会生效。\n\n#### **不生效情况：**\n\n- **缺少前缀列：** 如果查询条件中没有涉及联合索引的前缀列，则联合索引不会生效。\n  \n  - 例如，查询 `col2 = ?` 或 `col3 = ?`，联合索引就不会生效，虽然索引中的后续列（`col2` 和 `col3`）参与了查询。\n  \n  - **注意：** 只有索引中的前缀列 `col1` 能影响查询是否命中联合索引。\n\n### **2. 查询顺序是否匹配索引顺序**\n\n联合索引的列顺序对索引的使用至关重要。查询中的列顺序必须与联合索引中定义的列顺序匹配或前缀列匹配，才能充分利用联合索引。\n\n例如，假设有联合索引 `(col1, col2)`，而查询中使用的是 `col2, col1` 顺序：\n\nsql\n\n复制代码\n\n`SELECT * FROM table_name WHERE col2 = ? AND col1 = ?;`\n\n此查询不会使用索引，因为索引中的列顺序是 `(col1, col2)`，而查询的顺序是 `(col2, col1)`，它不符合索引顺序。\n\n### **3. 使用 LIKE、BETWEEN、IN 等查询操作**\n\n联合索引在处理 **`LIKE`**、**`BETWEEN`** 和 **`IN`** 等条件时也会生效，但具体情况取决于操作的使用。\n\n- **LIKE 查询：**\n  \n  - 如果 `LIKE` 查询的模式以固定字符开头，索引通常会生效。\n  - 例如：`WHERE col1 LIKE 'abc%'` 会利用 `(col1, col2)` 索引。\n  - 如果 `LIKE` 查询以 `%` 开头，索引一般不会生效，因为无法通过前缀匹配。\n\n- **BETWEEN 查询：**\n  \n  - `BETWEEN` 查询通常能使用联合索引，前提是查询的列符合索引前缀。\n  \n  例如，`WHERE col1 BETWEEN 1 AND 10 AND col2 = ?` 会利用 `(col1, col2)` 索引。\n\n- **IN 查询：**\n  \n  - `IN` 操作符能利用联合索引，只要它的列顺序符合联合索引中的顺序。\n  \n  例如，`WHERE col1 IN (1, 2, 3) AND col2 = ?` 会利用 `(col1, col2)` 索引。\n\n### **4. 使用范围查询**\n\n- 当查询条件中有范围操作（如 `>`, `<`, `BETWEEN`, `!=`），联合索引通常能在范围查询列之前部分生效，但范围查询后面的列可能会失效。\n  \n  例如，`WHERE col1 = ? AND col2 > ?` 会使用 `(col1, col2)` 索引，但 `col2` 的范围查询后，索引可能不再生效。\n\n### **5. 全表扫描 vs. 索引扫描**\n\n- 如果联合索引的列没有有效地匹配查询条件，数据库优化器可能会选择放弃使用索引，转而执行全表扫描，尤其是在索引选择性不高的情况下。\n\n### **总结**\n\n联合索引生效的条件主要有：\n\n1. 查询条件中涉及联合索引的前缀列（即索引中的左侧列）。\n2. 查询条件的列顺序与联合索引的列顺序一致。\n3. 使用范围查询时，索引可能只在前缀列生效。\n4. LIKE、IN、BETWEEN 等操作符可以在特定情况下利用联合索引，但要满足顺序和前缀的条件。\n\n因此，在设计和使用联合索引时，最好按照查询的实际需求来调整索引的列顺序和使用方式。\n","slug":"mysql列的联合索引什么时候生效","published":1,"updated":"2025-01-14T11:06:55.925Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd1z000y3ga86ruw5hu0","content":"<p><strong>联合索引（Composite Index）</strong> 是指在数据库中为多个列创建的索引，它可以提高查询性能，尤其是在涉及多个列的条件查询时。然而，联合索引的生效与使用条件有关。以下是几个常见的情况，说明联合索引何时生效：</p>\n<h3 id=\"1-查询条件中涉及索引的前缀列\"><a href=\"#1-查询条件中涉及索引的前缀列\" class=\"headerlink\" title=\"1. 查询条件中涉及索引的前缀列\"></a><strong>1. 查询条件中涉及索引的前缀列</strong></h3><p>联合索引生效的关键在于查询中是否使用了索引的前缀列（即联合索引中左侧的列）。联合索引按列顺序存储数据，因此，只有当查询条件涉及到联合索引的前缀部分时，索引才能生效。</p>\n<p>例如，假设有以下联合索引：</p>\n<p>sql</p>\n<p>复制代码</p>\n<p><code>CREATE INDEX idx_name ON table_name (col1, col2, col3);</code></p>\n<p>在此例中，<code>(col1, col2, col3)</code> 是联合索引。</p>\n<h4 id=\"生效情况：\"><a href=\"#生效情况：\" class=\"headerlink\" title=\"生效情况：\"></a><strong>生效情况：</strong></h4><ul>\n<li><strong>使用前缀列：</strong> 只要查询条件中包含索引的<strong>前缀部分</strong>，索引都会生效。<ul>\n<li>例如，查询 <code>col1</code> 或 <code>col1, col2</code>，联合索引都会生效。</li>\n<li>查询条件 <code>col1 = ?</code> 或 <code>col1 = ? AND col2 = ?</code>，索引会生效。</li>\n<li>查询条件 <code>col1 = ? AND col2 = ? AND col3 = ?</code>，索引会生效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"不生效情况：\"><a href=\"#不生效情况：\" class=\"headerlink\" title=\"不生效情况：\"></a><strong>不生效情况：</strong></h4><ul>\n<li><p><strong>缺少前缀列：</strong> 如果查询条件中没有涉及联合索引的前缀列，则联合索引不会生效。</p>\n<ul>\n<li><p>例如，查询 <code>col2 = ?</code> 或 <code>col3 = ?</code>，联合索引就不会生效，虽然索引中的后续列（<code>col2</code> 和 <code>col3</code>）参与了查询。</p>\n</li>\n<li><p><strong>注意：</strong> 只有索引中的前缀列 <code>col1</code> 能影响查询是否命中联合索引。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-查询顺序是否匹配索引顺序\"><a href=\"#2-查询顺序是否匹配索引顺序\" class=\"headerlink\" title=\"2. 查询顺序是否匹配索引顺序\"></a><strong>2. 查询顺序是否匹配索引顺序</strong></h3><p>联合索引的列顺序对索引的使用至关重要。查询中的列顺序必须与联合索引中定义的列顺序匹配或前缀列匹配，才能充分利用联合索引。</p>\n<p>例如，假设有联合索引 <code>(col1, col2)</code>，而查询中使用的是 <code>col2, col1</code> 顺序：</p>\n<p>sql</p>\n<p>复制代码</p>\n<p><code>SELECT * FROM table_name WHERE col2 = ? AND col1 = ?;</code></p>\n<p>此查询不会使用索引，因为索引中的列顺序是 <code>(col1, col2)</code>，而查询的顺序是 <code>(col2, col1)</code>，它不符合索引顺序。</p>\n<h3 id=\"3-使用-LIKE、BETWEEN、IN-等查询操作\"><a href=\"#3-使用-LIKE、BETWEEN、IN-等查询操作\" class=\"headerlink\" title=\"3. 使用 LIKE、BETWEEN、IN 等查询操作\"></a><strong>3. 使用 LIKE、BETWEEN、IN 等查询操作</strong></h3><p>联合索引在处理 <strong><code>LIKE</code><strong>、</strong><code>BETWEEN</code></strong> 和 <strong><code>IN</code></strong> 等条件时也会生效，但具体情况取决于操作的使用。</p>\n<ul>\n<li><p><strong>LIKE 查询：</strong></p>\n<ul>\n<li>如果 <code>LIKE</code> 查询的模式以固定字符开头，索引通常会生效。</li>\n<li>例如：<code>WHERE col1 LIKE &#39;abc%&#39;</code> 会利用 <code>(col1, col2)</code> 索引。</li>\n<li>如果 <code>LIKE</code> 查询以 <code>%</code> 开头，索引一般不会生效，因为无法通过前缀匹配。</li>\n</ul>\n</li>\n<li><p><strong>BETWEEN 查询：</strong></p>\n<ul>\n<li><code>BETWEEN</code> 查询通常能使用联合索引，前提是查询的列符合索引前缀。</li>\n</ul>\n<p>例如，<code>WHERE col1 BETWEEN 1 AND 10 AND col2 = ?</code> 会利用 <code>(col1, col2)</code> 索引。</p>\n</li>\n<li><p><strong>IN 查询：</strong></p>\n<ul>\n<li><code>IN</code> 操作符能利用联合索引，只要它的列顺序符合联合索引中的顺序。</li>\n</ul>\n<p>例如，<code>WHERE col1 IN (1, 2, 3) AND col2 = ?</code> 会利用 <code>(col1, col2)</code> 索引。</p>\n</li>\n</ul>\n<h3 id=\"4-使用范围查询\"><a href=\"#4-使用范围查询\" class=\"headerlink\" title=\"4. 使用范围查询\"></a><strong>4. 使用范围查询</strong></h3><ul>\n<li><p>当查询条件中有范围操作（如 <code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>, <code>!=</code>），联合索引通常能在范围查询列之前部分生效，但范围查询后面的列可能会失效。</p>\n<p>例如，<code>WHERE col1 = ? AND col2 &gt; ?</code> 会使用 <code>(col1, col2)</code> 索引，但 <code>col2</code> 的范围查询后，索引可能不再生效。</p>\n</li>\n</ul>\n<h3 id=\"5-全表扫描-vs-索引扫描\"><a href=\"#5-全表扫描-vs-索引扫描\" class=\"headerlink\" title=\"5. 全表扫描 vs. 索引扫描\"></a><strong>5. 全表扫描 vs. 索引扫描</strong></h3><ul>\n<li>如果联合索引的列没有有效地匹配查询条件，数据库优化器可能会选择放弃使用索引，转而执行全表扫描，尤其是在索引选择性不高的情况下。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>联合索引生效的条件主要有：</p>\n<ol>\n<li>查询条件中涉及联合索引的前缀列（即索引中的左侧列）。</li>\n<li>查询条件的列顺序与联合索引的列顺序一致。</li>\n<li>使用范围查询时，索引可能只在前缀列生效。</li>\n<li>LIKE、IN、BETWEEN 等操作符可以在特定情况下利用联合索引，但要满足顺序和前缀的条件。</li>\n</ol>\n<p>因此，在设计和使用联合索引时，最好按照查询的实际需求来调整索引的列顺序和使用方式。</p>\n","cover":false,"excerpt":"","more":"<p><strong>联合索引（Composite Index）</strong> 是指在数据库中为多个列创建的索引，它可以提高查询性能，尤其是在涉及多个列的条件查询时。然而，联合索引的生效与使用条件有关。以下是几个常见的情况，说明联合索引何时生效：</p>\n<h3 id=\"1-查询条件中涉及索引的前缀列\"><a href=\"#1-查询条件中涉及索引的前缀列\" class=\"headerlink\" title=\"1. 查询条件中涉及索引的前缀列\"></a><strong>1. 查询条件中涉及索引的前缀列</strong></h3><p>联合索引生效的关键在于查询中是否使用了索引的前缀列（即联合索引中左侧的列）。联合索引按列顺序存储数据，因此，只有当查询条件涉及到联合索引的前缀部分时，索引才能生效。</p>\n<p>例如，假设有以下联合索引：</p>\n<p>sql</p>\n<p>复制代码</p>\n<p><code>CREATE INDEX idx_name ON table_name (col1, col2, col3);</code></p>\n<p>在此例中，<code>(col1, col2, col3)</code> 是联合索引。</p>\n<h4 id=\"生效情况：\"><a href=\"#生效情况：\" class=\"headerlink\" title=\"生效情况：\"></a><strong>生效情况：</strong></h4><ul>\n<li><strong>使用前缀列：</strong> 只要查询条件中包含索引的<strong>前缀部分</strong>，索引都会生效。<ul>\n<li>例如，查询 <code>col1</code> 或 <code>col1, col2</code>，联合索引都会生效。</li>\n<li>查询条件 <code>col1 = ?</code> 或 <code>col1 = ? AND col2 = ?</code>，索引会生效。</li>\n<li>查询条件 <code>col1 = ? AND col2 = ? AND col3 = ?</code>，索引会生效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"不生效情况：\"><a href=\"#不生效情况：\" class=\"headerlink\" title=\"不生效情况：\"></a><strong>不生效情况：</strong></h4><ul>\n<li><p><strong>缺少前缀列：</strong> 如果查询条件中没有涉及联合索引的前缀列，则联合索引不会生效。</p>\n<ul>\n<li><p>例如，查询 <code>col2 = ?</code> 或 <code>col3 = ?</code>，联合索引就不会生效，虽然索引中的后续列（<code>col2</code> 和 <code>col3</code>）参与了查询。</p>\n</li>\n<li><p><strong>注意：</strong> 只有索引中的前缀列 <code>col1</code> 能影响查询是否命中联合索引。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-查询顺序是否匹配索引顺序\"><a href=\"#2-查询顺序是否匹配索引顺序\" class=\"headerlink\" title=\"2. 查询顺序是否匹配索引顺序\"></a><strong>2. 查询顺序是否匹配索引顺序</strong></h3><p>联合索引的列顺序对索引的使用至关重要。查询中的列顺序必须与联合索引中定义的列顺序匹配或前缀列匹配，才能充分利用联合索引。</p>\n<p>例如，假设有联合索引 <code>(col1, col2)</code>，而查询中使用的是 <code>col2, col1</code> 顺序：</p>\n<p>sql</p>\n<p>复制代码</p>\n<p><code>SELECT * FROM table_name WHERE col2 = ? AND col1 = ?;</code></p>\n<p>此查询不会使用索引，因为索引中的列顺序是 <code>(col1, col2)</code>，而查询的顺序是 <code>(col2, col1)</code>，它不符合索引顺序。</p>\n<h3 id=\"3-使用-LIKE、BETWEEN、IN-等查询操作\"><a href=\"#3-使用-LIKE、BETWEEN、IN-等查询操作\" class=\"headerlink\" title=\"3. 使用 LIKE、BETWEEN、IN 等查询操作\"></a><strong>3. 使用 LIKE、BETWEEN、IN 等查询操作</strong></h3><p>联合索引在处理 <strong><code>LIKE</code><strong>、</strong><code>BETWEEN</code></strong> 和 <strong><code>IN</code></strong> 等条件时也会生效，但具体情况取决于操作的使用。</p>\n<ul>\n<li><p><strong>LIKE 查询：</strong></p>\n<ul>\n<li>如果 <code>LIKE</code> 查询的模式以固定字符开头，索引通常会生效。</li>\n<li>例如：<code>WHERE col1 LIKE &#39;abc%&#39;</code> 会利用 <code>(col1, col2)</code> 索引。</li>\n<li>如果 <code>LIKE</code> 查询以 <code>%</code> 开头，索引一般不会生效，因为无法通过前缀匹配。</li>\n</ul>\n</li>\n<li><p><strong>BETWEEN 查询：</strong></p>\n<ul>\n<li><code>BETWEEN</code> 查询通常能使用联合索引，前提是查询的列符合索引前缀。</li>\n</ul>\n<p>例如，<code>WHERE col1 BETWEEN 1 AND 10 AND col2 = ?</code> 会利用 <code>(col1, col2)</code> 索引。</p>\n</li>\n<li><p><strong>IN 查询：</strong></p>\n<ul>\n<li><code>IN</code> 操作符能利用联合索引，只要它的列顺序符合联合索引中的顺序。</li>\n</ul>\n<p>例如，<code>WHERE col1 IN (1, 2, 3) AND col2 = ?</code> 会利用 <code>(col1, col2)</code> 索引。</p>\n</li>\n</ul>\n<h3 id=\"4-使用范围查询\"><a href=\"#4-使用范围查询\" class=\"headerlink\" title=\"4. 使用范围查询\"></a><strong>4. 使用范围查询</strong></h3><ul>\n<li><p>当查询条件中有范围操作（如 <code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>, <code>!=</code>），联合索引通常能在范围查询列之前部分生效，但范围查询后面的列可能会失效。</p>\n<p>例如，<code>WHERE col1 = ? AND col2 &gt; ?</code> 会使用 <code>(col1, col2)</code> 索引，但 <code>col2</code> 的范围查询后，索引可能不再生效。</p>\n</li>\n</ul>\n<h3 id=\"5-全表扫描-vs-索引扫描\"><a href=\"#5-全表扫描-vs-索引扫描\" class=\"headerlink\" title=\"5. 全表扫描 vs. 索引扫描\"></a><strong>5. 全表扫描 vs. 索引扫描</strong></h3><ul>\n<li>如果联合索引的列没有有效地匹配查询条件，数据库优化器可能会选择放弃使用索引，转而执行全表扫描，尤其是在索引选择性不高的情况下。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>联合索引生效的条件主要有：</p>\n<ol>\n<li>查询条件中涉及联合索引的前缀列（即索引中的左侧列）。</li>\n<li>查询条件的列顺序与联合索引的列顺序一致。</li>\n<li>使用范围查询时，索引可能只在前缀列生效。</li>\n<li>LIKE、IN、BETWEEN 等操作符可以在特定情况下利用联合索引，但要满足顺序和前缀的条件。</li>\n</ol>\n<p>因此，在设计和使用联合索引时，最好按照查询的实际需求来调整索引的列顺序和使用方式。</p>\n"},{"title":"mysql数据库索引分类及其底层数据结构","date":"2024-10-15T06:17:49.000Z","catigories":"八股文","_content":"\n数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：\n\n## 一、数据库索引的分类\n\n### 1. **主键索引（Primary Key Index）**\n\n- **分类**：唯一性索引的一种特殊形式。\n- **特点**：对主键列创建的索引，保证唯一性且不能为空。\n- **底层结构**：B+树。\n\n### 2. **唯一索引（Unique Index）**\n\n- **分类**：确保列中的值唯一，但可以包含空值。\n- **特点**：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。\n- **底层结构**：B+树。\n\n### 3. **普通索引（Non-Unique Index）**\n\n- **分类**：不对列的唯一性做要求，最常见的索引类型。\n- **特点**：支持常规的查询加速，允许重复值。\n- **底层结构**：B+树。\n\n### 4. **复合索引（Composite Index）**\n\n- **分类**：在多个列上创建的索引。\n- **特点**：按指定列顺序建立，遵循“最左前缀原则”。\n- **底层结构**：B+树。\n\n### 5. **全文索引（Full-Text Index）**\n\n- **分类**：专门用于大文本字段搜索的索引。\n- **特点**：基于分词进行全文检索，支持复杂的文本查询。\n- **底层结构**：倒排索引（Inverted Index）。\n\n### 6. **空间索引（Spatial Index）**\n\n- **分类**：用于地理空间数据（如坐标、地图位置）的索引。\n- **特点**：支持多维数据的范围查询。\n- **底层结构**：R树（R-Tree）。\n\n### 7. **聚集索引（Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序一致的索引。\n- **特点**：通常用于主键索引，每个表只能有一个聚集索引。\n- **底层结构**：B+树。\n\n### 8. **非聚集索引（Non-Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序无关的索引。\n- **特点**：每个表可以有多个非聚集索引，独立于数据存储。\n- **底层结构**：B+树。\n\n### 9. **哈希索引（Hash Index）**\n\n- **分类**：基于哈希函数的索引。\n- **特点**：等值查询效率极高，但不支持范围查询。\n- **底层结构**：哈希表。\n\n### 10. **位图索引（Bitmap Index）**\n\n- **分类**：通过位图表示数据的索引。\n- **特点**：适合低基数列，适用于组合查询，但不适合频繁更新的场景。\n- **底层结构**：位图（Bitmap）。\n\n---\n\n## 二、数据库索引的底层数据结构\n\n### 1. **B+树（B+ Tree）**\n\n- **用途**：最常用于主键索引、唯一索引、普通索引和复合索引。\n- **结构特点**：\n  - **多路平衡树**：节点包含多个键值，树高度低，磁盘I/O次数少。\n  - **叶子节点链表**：所有数据存储在叶子节点，并通过链表连接，支持范围查询。\n  - **顺序访问效率高**：适合范围查询和排序操作。\n\n### 2. **哈希表（Hash Table）**\n\n- **用途**：用于哈希索引，主要针对等值查询场景。\n- **结构特点**：\n  - **哈希函数映射**：通过哈希函数将键值映射到哈希表中的桶（bucket）。\n  - **不支持范围查询**：哈希表只能快速处理等值查询，对于范围查询无效。\n\n### 3. **倒排索引（Inverted Index）**\n\n- **用途**：主要用于全文索引。\n- **结构特点**：\n  - **关键词映射**：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。\n  - **分词处理**：适用于大文本数据，通过词语的匹配加速查询。\n  - **高效全文搜索**：特别适合搜索引擎和文本数据中的关键词查找。\n\n### 4. **R树（R-Tree）**\n\n- **用途**：用于空间索引，主要处理二维或多维的空间数据。\n- **结构特点**：\n  - **范围查询**：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。\n  - **分层结构**：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。\n\n### 5. **位图（Bitmap）**\n\n- **用途**：主要用于位图索引，适用于低基数（如性别、状态等）的列。\n- **结构特点**：\n  - **位数组表示**：使用位数组来表示数据的位置，适合数据重复较多的场景。\n  - **组合查询高效**：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。\n  - **不适合频繁更新**：因为每次修改需要更新整个位图，频繁更新时效率较低。\n\n### 6. **跳表（Skip List）**\n\n- **用途**：Redis等轻量级存储中常用的索引结构。\n- **结构特点**：\n  - **多层链表结构**：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。\n  - **范围查询**：跳表支持快速的范围查找，且实现简单。\n\n---\n\n### 三、总结\n\n1. **常见索引结构**：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。\n2. **其他结构**：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。\n3. **性能权衡**：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。\n","source":"_posts/mysql数据库索引分类及其底层数据结构.md","raw":"---\ntitle: mysql数据库索引分类及其底层数据结构\ndate: 2024-10-15 14:17:49\ntags: mysql\ncatigories: 八股文\n---\n\n数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：\n\n## 一、数据库索引的分类\n\n### 1. **主键索引（Primary Key Index）**\n\n- **分类**：唯一性索引的一种特殊形式。\n- **特点**：对主键列创建的索引，保证唯一性且不能为空。\n- **底层结构**：B+树。\n\n### 2. **唯一索引（Unique Index）**\n\n- **分类**：确保列中的值唯一，但可以包含空值。\n- **特点**：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。\n- **底层结构**：B+树。\n\n### 3. **普通索引（Non-Unique Index）**\n\n- **分类**：不对列的唯一性做要求，最常见的索引类型。\n- **特点**：支持常规的查询加速，允许重复值。\n- **底层结构**：B+树。\n\n### 4. **复合索引（Composite Index）**\n\n- **分类**：在多个列上创建的索引。\n- **特点**：按指定列顺序建立，遵循“最左前缀原则”。\n- **底层结构**：B+树。\n\n### 5. **全文索引（Full-Text Index）**\n\n- **分类**：专门用于大文本字段搜索的索引。\n- **特点**：基于分词进行全文检索，支持复杂的文本查询。\n- **底层结构**：倒排索引（Inverted Index）。\n\n### 6. **空间索引（Spatial Index）**\n\n- **分类**：用于地理空间数据（如坐标、地图位置）的索引。\n- **特点**：支持多维数据的范围查询。\n- **底层结构**：R树（R-Tree）。\n\n### 7. **聚集索引（Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序一致的索引。\n- **特点**：通常用于主键索引，每个表只能有一个聚集索引。\n- **底层结构**：B+树。\n\n### 8. **非聚集索引（Non-Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序无关的索引。\n- **特点**：每个表可以有多个非聚集索引，独立于数据存储。\n- **底层结构**：B+树。\n\n### 9. **哈希索引（Hash Index）**\n\n- **分类**：基于哈希函数的索引。\n- **特点**：等值查询效率极高，但不支持范围查询。\n- **底层结构**：哈希表。\n\n### 10. **位图索引（Bitmap Index）**\n\n- **分类**：通过位图表示数据的索引。\n- **特点**：适合低基数列，适用于组合查询，但不适合频繁更新的场景。\n- **底层结构**：位图（Bitmap）。\n\n---\n\n## 二、数据库索引的底层数据结构\n\n### 1. **B+树（B+ Tree）**\n\n- **用途**：最常用于主键索引、唯一索引、普通索引和复合索引。\n- **结构特点**：\n  - **多路平衡树**：节点包含多个键值，树高度低，磁盘I/O次数少。\n  - **叶子节点链表**：所有数据存储在叶子节点，并通过链表连接，支持范围查询。\n  - **顺序访问效率高**：适合范围查询和排序操作。\n\n### 2. **哈希表（Hash Table）**\n\n- **用途**：用于哈希索引，主要针对等值查询场景。\n- **结构特点**：\n  - **哈希函数映射**：通过哈希函数将键值映射到哈希表中的桶（bucket）。\n  - **不支持范围查询**：哈希表只能快速处理等值查询，对于范围查询无效。\n\n### 3. **倒排索引（Inverted Index）**\n\n- **用途**：主要用于全文索引。\n- **结构特点**：\n  - **关键词映射**：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。\n  - **分词处理**：适用于大文本数据，通过词语的匹配加速查询。\n  - **高效全文搜索**：特别适合搜索引擎和文本数据中的关键词查找。\n\n### 4. **R树（R-Tree）**\n\n- **用途**：用于空间索引，主要处理二维或多维的空间数据。\n- **结构特点**：\n  - **范围查询**：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。\n  - **分层结构**：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。\n\n### 5. **位图（Bitmap）**\n\n- **用途**：主要用于位图索引，适用于低基数（如性别、状态等）的列。\n- **结构特点**：\n  - **位数组表示**：使用位数组来表示数据的位置，适合数据重复较多的场景。\n  - **组合查询高效**：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。\n  - **不适合频繁更新**：因为每次修改需要更新整个位图，频繁更新时效率较低。\n\n### 6. **跳表（Skip List）**\n\n- **用途**：Redis等轻量级存储中常用的索引结构。\n- **结构特点**：\n  - **多层链表结构**：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。\n  - **范围查询**：跳表支持快速的范围查找，且实现简单。\n\n---\n\n### 三、总结\n\n1. **常见索引结构**：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。\n2. **其他结构**：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。\n3. **性能权衡**：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。\n","slug":"mysql数据库索引分类及其底层数据结构","published":1,"updated":"2024-12-14T07:51:45.874Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2000123ga850ky6mrd","content":"<p>数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：</p>\n<h2 id=\"一、数据库索引的分类\"><a href=\"#一、数据库索引的分类\" class=\"headerlink\" title=\"一、数据库索引的分类\"></a>一、数据库索引的分类</h2><h3 id=\"1-主键索引（Primary-Key-Index）\"><a href=\"#1-主键索引（Primary-Key-Index）\" class=\"headerlink\" title=\"1. 主键索引（Primary Key Index）\"></a>1. <strong>主键索引（Primary Key Index）</strong></h3><ul>\n<li><strong>分类</strong>：唯一性索引的一种特殊形式。</li>\n<li><strong>特点</strong>：对主键列创建的索引，保证唯一性且不能为空。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"2-唯一索引（Unique-Index）\"><a href=\"#2-唯一索引（Unique-Index）\" class=\"headerlink\" title=\"2. 唯一索引（Unique Index）\"></a>2. <strong>唯一索引（Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：确保列中的值唯一，但可以包含空值。</li>\n<li><strong>特点</strong>：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"3-普通索引（Non-Unique-Index）\"><a href=\"#3-普通索引（Non-Unique-Index）\" class=\"headerlink\" title=\"3. 普通索引（Non-Unique Index）\"></a>3. <strong>普通索引（Non-Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：不对列的唯一性做要求，最常见的索引类型。</li>\n<li><strong>特点</strong>：支持常规的查询加速，允许重复值。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"4-复合索引（Composite-Index）\"><a href=\"#4-复合索引（Composite-Index）\" class=\"headerlink\" title=\"4. 复合索引（Composite Index）\"></a>4. <strong>复合索引（Composite Index）</strong></h3><ul>\n<li><strong>分类</strong>：在多个列上创建的索引。</li>\n<li><strong>特点</strong>：按指定列顺序建立，遵循“最左前缀原则”。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"5-全文索引（Full-Text-Index）\"><a href=\"#5-全文索引（Full-Text-Index）\" class=\"headerlink\" title=\"5. 全文索引（Full-Text Index）\"></a>5. <strong>全文索引（Full-Text Index）</strong></h3><ul>\n<li><strong>分类</strong>：专门用于大文本字段搜索的索引。</li>\n<li><strong>特点</strong>：基于分词进行全文检索，支持复杂的文本查询。</li>\n<li><strong>底层结构</strong>：倒排索引（Inverted Index）。</li>\n</ul>\n<h3 id=\"6-空间索引（Spatial-Index）\"><a href=\"#6-空间索引（Spatial-Index）\" class=\"headerlink\" title=\"6. 空间索引（Spatial Index）\"></a>6. <strong>空间索引（Spatial Index）</strong></h3><ul>\n<li><strong>分类</strong>：用于地理空间数据（如坐标、地图位置）的索引。</li>\n<li><strong>特点</strong>：支持多维数据的范围查询。</li>\n<li><strong>底层结构</strong>：R树（R-Tree）。</li>\n</ul>\n<h3 id=\"7-聚集索引（Clustered-Index）\"><a href=\"#7-聚集索引（Clustered-Index）\" class=\"headerlink\" title=\"7. 聚集索引（Clustered Index）\"></a>7. <strong>聚集索引（Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序一致的索引。</li>\n<li><strong>特点</strong>：通常用于主键索引，每个表只能有一个聚集索引。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"8-非聚集索引（Non-Clustered-Index）\"><a href=\"#8-非聚集索引（Non-Clustered-Index）\" class=\"headerlink\" title=\"8. 非聚集索引（Non-Clustered Index）\"></a>8. <strong>非聚集索引（Non-Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序无关的索引。</li>\n<li><strong>特点</strong>：每个表可以有多个非聚集索引，独立于数据存储。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"9-哈希索引（Hash-Index）\"><a href=\"#9-哈希索引（Hash-Index）\" class=\"headerlink\" title=\"9. 哈希索引（Hash Index）\"></a>9. <strong>哈希索引（Hash Index）</strong></h3><ul>\n<li><strong>分类</strong>：基于哈希函数的索引。</li>\n<li><strong>特点</strong>：等值查询效率极高，但不支持范围查询。</li>\n<li><strong>底层结构</strong>：哈希表。</li>\n</ul>\n<h3 id=\"10-位图索引（Bitmap-Index）\"><a href=\"#10-位图索引（Bitmap-Index）\" class=\"headerlink\" title=\"10. 位图索引（Bitmap Index）\"></a>10. <strong>位图索引（Bitmap Index）</strong></h3><ul>\n<li><strong>分类</strong>：通过位图表示数据的索引。</li>\n<li><strong>特点</strong>：适合低基数列，适用于组合查询，但不适合频繁更新的场景。</li>\n<li><strong>底层结构</strong>：位图（Bitmap）。</li>\n</ul>\n<hr>\n<h2 id=\"二、数据库索引的底层数据结构\"><a href=\"#二、数据库索引的底层数据结构\" class=\"headerlink\" title=\"二、数据库索引的底层数据结构\"></a>二、数据库索引的底层数据结构</h2><h3 id=\"1-B-树（B-Tree）\"><a href=\"#1-B-树（B-Tree）\" class=\"headerlink\" title=\"1. B+树（B+ Tree）\"></a>1. <strong>B+树（B+ Tree）</strong></h3><ul>\n<li><strong>用途</strong>：最常用于主键索引、唯一索引、普通索引和复合索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多路平衡树</strong>：节点包含多个键值，树高度低，磁盘I&#x2F;O次数少。</li>\n<li><strong>叶子节点链表</strong>：所有数据存储在叶子节点，并通过链表连接，支持范围查询。</li>\n<li><strong>顺序访问效率高</strong>：适合范围查询和排序操作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-哈希表（Hash-Table）\"><a href=\"#2-哈希表（Hash-Table）\" class=\"headerlink\" title=\"2. 哈希表（Hash Table）\"></a>2. <strong>哈希表（Hash Table）</strong></h3><ul>\n<li><strong>用途</strong>：用于哈希索引，主要针对等值查询场景。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>哈希函数映射</strong>：通过哈希函数将键值映射到哈希表中的桶（bucket）。</li>\n<li><strong>不支持范围查询</strong>：哈希表只能快速处理等值查询，对于范围查询无效。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-倒排索引（Inverted-Index）\"><a href=\"#3-倒排索引（Inverted-Index）\" class=\"headerlink\" title=\"3. 倒排索引（Inverted Index）\"></a>3. <strong>倒排索引（Inverted Index）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于全文索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>关键词映射</strong>：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。</li>\n<li><strong>分词处理</strong>：适用于大文本数据，通过词语的匹配加速查询。</li>\n<li><strong>高效全文搜索</strong>：特别适合搜索引擎和文本数据中的关键词查找。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-R树（R-Tree）\"><a href=\"#4-R树（R-Tree）\" class=\"headerlink\" title=\"4. R树（R-Tree）\"></a>4. <strong>R树（R-Tree）</strong></h3><ul>\n<li><strong>用途</strong>：用于空间索引，主要处理二维或多维的空间数据。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>范围查询</strong>：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。</li>\n<li><strong>分层结构</strong>：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-位图（Bitmap）\"><a href=\"#5-位图（Bitmap）\" class=\"headerlink\" title=\"5. 位图（Bitmap）\"></a>5. <strong>位图（Bitmap）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于位图索引，适用于低基数（如性别、状态等）的列。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>位数组表示</strong>：使用位数组来表示数据的位置，适合数据重复较多的场景。</li>\n<li><strong>组合查询高效</strong>：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。</li>\n<li><strong>不适合频繁更新</strong>：因为每次修改需要更新整个位图，频繁更新时效率较低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-跳表（Skip-List）\"><a href=\"#6-跳表（Skip-List）\" class=\"headerlink\" title=\"6. 跳表（Skip List）\"></a>6. <strong>跳表（Skip List）</strong></h3><ul>\n<li><strong>用途</strong>：Redis等轻量级存储中常用的索引结构。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多层链表结构</strong>：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。</li>\n<li><strong>范围查询</strong>：跳表支持快速的范围查找，且实现简单。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><ol>\n<li><strong>常见索引结构</strong>：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。</li>\n<li><strong>其他结构</strong>：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。</li>\n<li><strong>性能权衡</strong>：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。</li>\n</ol>\n","cover":false,"excerpt":"","more":"<p>数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：</p>\n<h2 id=\"一、数据库索引的分类\"><a href=\"#一、数据库索引的分类\" class=\"headerlink\" title=\"一、数据库索引的分类\"></a>一、数据库索引的分类</h2><h3 id=\"1-主键索引（Primary-Key-Index）\"><a href=\"#1-主键索引（Primary-Key-Index）\" class=\"headerlink\" title=\"1. 主键索引（Primary Key Index）\"></a>1. <strong>主键索引（Primary Key Index）</strong></h3><ul>\n<li><strong>分类</strong>：唯一性索引的一种特殊形式。</li>\n<li><strong>特点</strong>：对主键列创建的索引，保证唯一性且不能为空。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"2-唯一索引（Unique-Index）\"><a href=\"#2-唯一索引（Unique-Index）\" class=\"headerlink\" title=\"2. 唯一索引（Unique Index）\"></a>2. <strong>唯一索引（Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：确保列中的值唯一，但可以包含空值。</li>\n<li><strong>特点</strong>：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"3-普通索引（Non-Unique-Index）\"><a href=\"#3-普通索引（Non-Unique-Index）\" class=\"headerlink\" title=\"3. 普通索引（Non-Unique Index）\"></a>3. <strong>普通索引（Non-Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：不对列的唯一性做要求，最常见的索引类型。</li>\n<li><strong>特点</strong>：支持常规的查询加速，允许重复值。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"4-复合索引（Composite-Index）\"><a href=\"#4-复合索引（Composite-Index）\" class=\"headerlink\" title=\"4. 复合索引（Composite Index）\"></a>4. <strong>复合索引（Composite Index）</strong></h3><ul>\n<li><strong>分类</strong>：在多个列上创建的索引。</li>\n<li><strong>特点</strong>：按指定列顺序建立，遵循“最左前缀原则”。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"5-全文索引（Full-Text-Index）\"><a href=\"#5-全文索引（Full-Text-Index）\" class=\"headerlink\" title=\"5. 全文索引（Full-Text Index）\"></a>5. <strong>全文索引（Full-Text Index）</strong></h3><ul>\n<li><strong>分类</strong>：专门用于大文本字段搜索的索引。</li>\n<li><strong>特点</strong>：基于分词进行全文检索，支持复杂的文本查询。</li>\n<li><strong>底层结构</strong>：倒排索引（Inverted Index）。</li>\n</ul>\n<h3 id=\"6-空间索引（Spatial-Index）\"><a href=\"#6-空间索引（Spatial-Index）\" class=\"headerlink\" title=\"6. 空间索引（Spatial Index）\"></a>6. <strong>空间索引（Spatial Index）</strong></h3><ul>\n<li><strong>分类</strong>：用于地理空间数据（如坐标、地图位置）的索引。</li>\n<li><strong>特点</strong>：支持多维数据的范围查询。</li>\n<li><strong>底层结构</strong>：R树（R-Tree）。</li>\n</ul>\n<h3 id=\"7-聚集索引（Clustered-Index）\"><a href=\"#7-聚集索引（Clustered-Index）\" class=\"headerlink\" title=\"7. 聚集索引（Clustered Index）\"></a>7. <strong>聚集索引（Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序一致的索引。</li>\n<li><strong>特点</strong>：通常用于主键索引，每个表只能有一个聚集索引。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"8-非聚集索引（Non-Clustered-Index）\"><a href=\"#8-非聚集索引（Non-Clustered-Index）\" class=\"headerlink\" title=\"8. 非聚集索引（Non-Clustered Index）\"></a>8. <strong>非聚集索引（Non-Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序无关的索引。</li>\n<li><strong>特点</strong>：每个表可以有多个非聚集索引，独立于数据存储。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"9-哈希索引（Hash-Index）\"><a href=\"#9-哈希索引（Hash-Index）\" class=\"headerlink\" title=\"9. 哈希索引（Hash Index）\"></a>9. <strong>哈希索引（Hash Index）</strong></h3><ul>\n<li><strong>分类</strong>：基于哈希函数的索引。</li>\n<li><strong>特点</strong>：等值查询效率极高，但不支持范围查询。</li>\n<li><strong>底层结构</strong>：哈希表。</li>\n</ul>\n<h3 id=\"10-位图索引（Bitmap-Index）\"><a href=\"#10-位图索引（Bitmap-Index）\" class=\"headerlink\" title=\"10. 位图索引（Bitmap Index）\"></a>10. <strong>位图索引（Bitmap Index）</strong></h3><ul>\n<li><strong>分类</strong>：通过位图表示数据的索引。</li>\n<li><strong>特点</strong>：适合低基数列，适用于组合查询，但不适合频繁更新的场景。</li>\n<li><strong>底层结构</strong>：位图（Bitmap）。</li>\n</ul>\n<hr>\n<h2 id=\"二、数据库索引的底层数据结构\"><a href=\"#二、数据库索引的底层数据结构\" class=\"headerlink\" title=\"二、数据库索引的底层数据结构\"></a>二、数据库索引的底层数据结构</h2><h3 id=\"1-B-树（B-Tree）\"><a href=\"#1-B-树（B-Tree）\" class=\"headerlink\" title=\"1. B+树（B+ Tree）\"></a>1. <strong>B+树（B+ Tree）</strong></h3><ul>\n<li><strong>用途</strong>：最常用于主键索引、唯一索引、普通索引和复合索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多路平衡树</strong>：节点包含多个键值，树高度低，磁盘I&#x2F;O次数少。</li>\n<li><strong>叶子节点链表</strong>：所有数据存储在叶子节点，并通过链表连接，支持范围查询。</li>\n<li><strong>顺序访问效率高</strong>：适合范围查询和排序操作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-哈希表（Hash-Table）\"><a href=\"#2-哈希表（Hash-Table）\" class=\"headerlink\" title=\"2. 哈希表（Hash Table）\"></a>2. <strong>哈希表（Hash Table）</strong></h3><ul>\n<li><strong>用途</strong>：用于哈希索引，主要针对等值查询场景。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>哈希函数映射</strong>：通过哈希函数将键值映射到哈希表中的桶（bucket）。</li>\n<li><strong>不支持范围查询</strong>：哈希表只能快速处理等值查询，对于范围查询无效。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-倒排索引（Inverted-Index）\"><a href=\"#3-倒排索引（Inverted-Index）\" class=\"headerlink\" title=\"3. 倒排索引（Inverted Index）\"></a>3. <strong>倒排索引（Inverted Index）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于全文索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>关键词映射</strong>：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。</li>\n<li><strong>分词处理</strong>：适用于大文本数据，通过词语的匹配加速查询。</li>\n<li><strong>高效全文搜索</strong>：特别适合搜索引擎和文本数据中的关键词查找。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-R树（R-Tree）\"><a href=\"#4-R树（R-Tree）\" class=\"headerlink\" title=\"4. R树（R-Tree）\"></a>4. <strong>R树（R-Tree）</strong></h3><ul>\n<li><strong>用途</strong>：用于空间索引，主要处理二维或多维的空间数据。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>范围查询</strong>：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。</li>\n<li><strong>分层结构</strong>：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-位图（Bitmap）\"><a href=\"#5-位图（Bitmap）\" class=\"headerlink\" title=\"5. 位图（Bitmap）\"></a>5. <strong>位图（Bitmap）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于位图索引，适用于低基数（如性别、状态等）的列。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>位数组表示</strong>：使用位数组来表示数据的位置，适合数据重复较多的场景。</li>\n<li><strong>组合查询高效</strong>：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。</li>\n<li><strong>不适合频繁更新</strong>：因为每次修改需要更新整个位图，频繁更新时效率较低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-跳表（Skip-List）\"><a href=\"#6-跳表（Skip-List）\" class=\"headerlink\" title=\"6. 跳表（Skip List）\"></a>6. <strong>跳表（Skip List）</strong></h3><ul>\n<li><strong>用途</strong>：Redis等轻量级存储中常用的索引结构。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多层链表结构</strong>：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。</li>\n<li><strong>范围查询</strong>：跳表支持快速的范围查找，且实现简单。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><ol>\n<li><strong>常见索引结构</strong>：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。</li>\n<li><strong>其他结构</strong>：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。</li>\n<li><strong>性能权衡</strong>：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。</li>\n</ol>\n"},{"title":"redisson的分布式锁实现","date":"2025-01-14T08:02:21.000Z","_content":"\nRedisson 分布式锁通过 Redis 的setnx和 Lua 脚本实现，主要特点如下：\n\n#### **加锁**\n\n- **使用 `SETNX` 命令加锁**：\n  \n  - `SET key value NX PX timeout`\n  - `NX` 确保只有当锁不存在时才创建。\n  - `PX timeout` 设置锁的过期时间，避免死锁。\n  - `value` 通常是一个唯一标识（如 UUID），标记当前客户端（线程）持有锁。\n\n- **续锁机制**：\n  \n  - Redisson 内置了锁续期机制（**Watchdog**），会定期检查锁是否仍然持有。\n  - 默认锁过期时间为 30 秒，但 Watchdog 会每隔 10 秒（默认值）续期，保持锁的有效性，直到客户端主动解锁或宕机。\n\n#### **解锁**\n\n- 使用 Lua 脚本保证解锁的原子性：\n  \n  - 检查锁的值是否与当前客户端（线程）的唯一标识匹配，匹配则删除锁。\n  \n  - 示例脚本：\n    \n    lua\n    \n    复制代码\n    \n    `if redis.call(\"GET\", KEYS[1]) == ARGV[1] then     return redis.call(\"DEL\", KEYS[1]) else     return 0 end`\n","source":"_posts/redisson的分布式锁实现.md","raw":"---\ntitle: redisson的分布式锁实现\ndate: 2025-01-14 16:02:21\ntags: redis\ncategories: 底层实现\n---\n\nRedisson 分布式锁通过 Redis 的setnx和 Lua 脚本实现，主要特点如下：\n\n#### **加锁**\n\n- **使用 `SETNX` 命令加锁**：\n  \n  - `SET key value NX PX timeout`\n  - `NX` 确保只有当锁不存在时才创建。\n  - `PX timeout` 设置锁的过期时间，避免死锁。\n  - `value` 通常是一个唯一标识（如 UUID），标记当前客户端（线程）持有锁。\n\n- **续锁机制**：\n  \n  - Redisson 内置了锁续期机制（**Watchdog**），会定期检查锁是否仍然持有。\n  - 默认锁过期时间为 30 秒，但 Watchdog 会每隔 10 秒（默认值）续期，保持锁的有效性，直到客户端主动解锁或宕机。\n\n#### **解锁**\n\n- 使用 Lua 脚本保证解锁的原子性：\n  \n  - 检查锁的值是否与当前客户端（线程）的唯一标识匹配，匹配则删除锁。\n  \n  - 示例脚本：\n    \n    lua\n    \n    复制代码\n    \n    `if redis.call(\"GET\", KEYS[1]) == ARGV[1] then     return redis.call(\"DEL\", KEYS[1]) else     return 0 end`\n","slug":"redisson的分布式锁实现","published":1,"updated":"2025-01-14T08:09:14.093Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2100163ga8cyb8crpt","content":"<p>Redisson 分布式锁通过 Redis 的setnx和 Lua 脚本实现，主要特点如下：</p>\n<h4 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a><strong>加锁</strong></h4><ul>\n<li><p><strong>使用 <code>SETNX</code> 命令加锁</strong>：</p>\n<ul>\n<li><code>SET key value NX PX timeout</code></li>\n<li><code>NX</code> 确保只有当锁不存在时才创建。</li>\n<li><code>PX timeout</code> 设置锁的过期时间，避免死锁。</li>\n<li><code>value</code> 通常是一个唯一标识（如 UUID），标记当前客户端（线程）持有锁。</li>\n</ul>\n</li>\n<li><p><strong>续锁机制</strong>：</p>\n<ul>\n<li>Redisson 内置了锁续期机制（<strong>Watchdog</strong>），会定期检查锁是否仍然持有。</li>\n<li>默认锁过期时间为 30 秒，但 Watchdog 会每隔 10 秒（默认值）续期，保持锁的有效性，直到客户端主动解锁或宕机。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a><strong>解锁</strong></h4><ul>\n<li><p>使用 Lua 脚本保证解锁的原子性：</p>\n<ul>\n<li><p>检查锁的值是否与当前客户端（线程）的唯一标识匹配，匹配则删除锁。</p>\n</li>\n<li><p>示例脚本：</p>\n<p>lua</p>\n<p>复制代码</p>\n<p><code>if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then     return redis.call(&quot;DEL&quot;, KEYS[1]) else     return 0 end</code></p>\n</li>\n</ul>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<p>Redisson 分布式锁通过 Redis 的setnx和 Lua 脚本实现，主要特点如下：</p>\n<h4 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a><strong>加锁</strong></h4><ul>\n<li><p><strong>使用 <code>SETNX</code> 命令加锁</strong>：</p>\n<ul>\n<li><code>SET key value NX PX timeout</code></li>\n<li><code>NX</code> 确保只有当锁不存在时才创建。</li>\n<li><code>PX timeout</code> 设置锁的过期时间，避免死锁。</li>\n<li><code>value</code> 通常是一个唯一标识（如 UUID），标记当前客户端（线程）持有锁。</li>\n</ul>\n</li>\n<li><p><strong>续锁机制</strong>：</p>\n<ul>\n<li>Redisson 内置了锁续期机制（<strong>Watchdog</strong>），会定期检查锁是否仍然持有。</li>\n<li>默认锁过期时间为 30 秒，但 Watchdog 会每隔 10 秒（默认值）续期，保持锁的有效性，直到客户端主动解锁或宕机。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a><strong>解锁</strong></h4><ul>\n<li><p>使用 Lua 脚本保证解锁的原子性：</p>\n<ul>\n<li><p>检查锁的值是否与当前客户端（线程）的唯一标识匹配，匹配则删除锁。</p>\n</li>\n<li><p>示例脚本：</p>\n<p>lua</p>\n<p>复制代码</p>\n<p><code>if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then     return redis.call(&quot;DEL&quot;, KEYS[1]) else     return 0 end</code></p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"redis淘汰策略","date":"2024-10-15T06:20:22.000Z","_content":"\n在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n### 1. Redis 支持的淘汰策略\n\n- **noeviction**：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n- **allkeys-lru**：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n- **volatile-lru**：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n- **allkeys-random**：对所有的键随机淘汰。\n- **volatile-random**：只对设置了过期时间的键随机淘汰。\n- **volatile-ttl**：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n\n#### Redis 4.0 之后新增的策略\n\n- **allkeys-lfu**：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n- **volatile-lfu**：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n\n### 2. 配置 Redis 缓存淘汰策略\n\nRedis 的淘汰策略可以通过修改配置文件 `redis.conf` 或运行时使用命令行配置。\n\n#### 配置方式一：修改 `redis.conf`\n\n找到 Redis 配置文件 `redis.conf`，修改 `maxmemory-policy` 来设置淘汰策略。例如：\n\n```bash\nmaxmemory-policy allkeys-lru\n```\n\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\n```bash\nmaxmemory 256mb\n```\n\n#### 配置方式二：运行时设置\n\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\n```bash\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\n### 3. TTL（过期时间）实现\n\nRedis 提供了两种设置过期时间的方法：\n\n- `EXPIRE key seconds`：为键设置一个存活时间（秒），过期后自动删除。\n- `SET key value EX seconds`：在设置键的同时指定过期时间（秒）。\n\n#### 示例：\n\n```bash\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n```\n\n### 4. Redis LRU 实现机制\n\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 `maxmemory-samples` 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n#### 示例：\n\n在配置文件中设置采样数：\n\n```bash\nmaxmemory-samples 10\n```\n\n运行时设置：\n\n```bash\nCONFIG SET maxmemory-samples 10\n```\n\n### 5. Redis 缓存淘汰策略实战\n\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n1. **设置 Redis 的最大内存和 LRU 策略**：\n   \n   ```bash\n   CONFIG SET maxmemory 128mb\n   CONFIG SET maxmemory-policy allkeys-lru\n   ```\n\n2. **向 Redis 写入会话数据，并设置过期时间**：\n   \n   ```bash\n   SET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\n   SET session:user:1002 \"session_data\" EX 3600\n   ```\n\n3. **监控淘汰情况**：\n    当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n### 总结\n\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 `volatile-lru` 或 `volatile-ttl`，而如果没有过期时间且想控制整体缓存大小，可以选择 `allkeys-lru` 或 `allkeys-random`。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n1. Redis 支持的淘汰策略\n   noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n   allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n   volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n   allkeys-random：对所有的键随机淘汰。\n   volatile-random：只对设置了过期时间的键随机淘汰。\n   volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n   Redis 4.0 之后新增的策略\n   allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n   volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n2. 配置 Redis 缓存淘汰策略\n   Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。\n\n配置方式一：修改 redis.conf\n找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：\n\nmaxmemory-policy allkeys-lru\n1\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\nmaxmemory 256mb\n1\n配置方式二：运行时设置\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n3. TTL（过期时间）实现\nRedis 提供了两种设置过期时间的方法：\n\nEXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。\nSET key value EX seconds：在设置键的同时指定过期时间（秒）。\n示例：\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n1\n2\n4. Redis LRU 实现机制\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n示例：\n在配置文件中设置采样数：\n\nmaxmemory-samples 10\n1\n运行时设置：\n\nCONFIG SET maxmemory-samples 10\n1\n5. Redis 缓存淘汰策略实战\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n设置 Redis 的最大内存和 LRU 策略：\n\nCONFIG SET maxmemory 128mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n向 Redis 写入会话数据，并设置过期时间：\n\nSET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\nSET session:user:1002 \"session_data\" EX 3600\n1\n2\n监控淘汰情况：\n当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n总结\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。\n","source":"_posts/redis淘汰策略.md","raw":"---\ntitle: redis淘汰策略\ndate: 2024-10-15 14:20:22\ntags: redis\ncategories: 八股文\n---\n\n在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n### 1. Redis 支持的淘汰策略\n\n- **noeviction**：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n- **allkeys-lru**：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n- **volatile-lru**：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n- **allkeys-random**：对所有的键随机淘汰。\n- **volatile-random**：只对设置了过期时间的键随机淘汰。\n- **volatile-ttl**：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n\n#### Redis 4.0 之后新增的策略\n\n- **allkeys-lfu**：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n- **volatile-lfu**：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n\n### 2. 配置 Redis 缓存淘汰策略\n\nRedis 的淘汰策略可以通过修改配置文件 `redis.conf` 或运行时使用命令行配置。\n\n#### 配置方式一：修改 `redis.conf`\n\n找到 Redis 配置文件 `redis.conf`，修改 `maxmemory-policy` 来设置淘汰策略。例如：\n\n```bash\nmaxmemory-policy allkeys-lru\n```\n\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\n```bash\nmaxmemory 256mb\n```\n\n#### 配置方式二：运行时设置\n\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\n```bash\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\n### 3. TTL（过期时间）实现\n\nRedis 提供了两种设置过期时间的方法：\n\n- `EXPIRE key seconds`：为键设置一个存活时间（秒），过期后自动删除。\n- `SET key value EX seconds`：在设置键的同时指定过期时间（秒）。\n\n#### 示例：\n\n```bash\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n```\n\n### 4. Redis LRU 实现机制\n\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 `maxmemory-samples` 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n#### 示例：\n\n在配置文件中设置采样数：\n\n```bash\nmaxmemory-samples 10\n```\n\n运行时设置：\n\n```bash\nCONFIG SET maxmemory-samples 10\n```\n\n### 5. Redis 缓存淘汰策略实战\n\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n1. **设置 Redis 的最大内存和 LRU 策略**：\n   \n   ```bash\n   CONFIG SET maxmemory 128mb\n   CONFIG SET maxmemory-policy allkeys-lru\n   ```\n\n2. **向 Redis 写入会话数据，并设置过期时间**：\n   \n   ```bash\n   SET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\n   SET session:user:1002 \"session_data\" EX 3600\n   ```\n\n3. **监控淘汰情况**：\n    当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n### 总结\n\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 `volatile-lru` 或 `volatile-ttl`，而如果没有过期时间且想控制整体缓存大小，可以选择 `allkeys-lru` 或 `allkeys-random`。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n1. Redis 支持的淘汰策略\n   noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n   allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n   volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n   allkeys-random：对所有的键随机淘汰。\n   volatile-random：只对设置了过期时间的键随机淘汰。\n   volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n   Redis 4.0 之后新增的策略\n   allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n   volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n2. 配置 Redis 缓存淘汰策略\n   Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。\n\n配置方式一：修改 redis.conf\n找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：\n\nmaxmemory-policy allkeys-lru\n1\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\nmaxmemory 256mb\n1\n配置方式二：运行时设置\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n3. TTL（过期时间）实现\nRedis 提供了两种设置过期时间的方法：\n\nEXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。\nSET key value EX seconds：在设置键的同时指定过期时间（秒）。\n示例：\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n1\n2\n4. Redis LRU 实现机制\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n示例：\n在配置文件中设置采样数：\n\nmaxmemory-samples 10\n1\n运行时设置：\n\nCONFIG SET maxmemory-samples 10\n1\n5. Redis 缓存淘汰策略实战\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n设置 Redis 的最大内存和 LRU 策略：\n\nCONFIG SET maxmemory 128mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n向 Redis 写入会话数据，并设置过期时间：\n\nSET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\nSET session:user:1002 \"session_data\" EX 3600\n1\n2\n监控淘汰情况：\n当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n总结\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。\n","slug":"redis淘汰策略","published":1,"updated":"2024-12-14T09:14:20.682Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2200193ga80jyi8kdt","content":"<p>在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<h3 id=\"1-Redis-支持的淘汰策略\"><a href=\"#1-Redis-支持的淘汰策略\" class=\"headerlink\" title=\"1. Redis 支持的淘汰策略\"></a>1. Redis 支持的淘汰策略</h3><ul>\n<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。</li>\n<li><strong>allkeys-lru</strong>：对所有的键使用 LRU（最近最少使用）算法进行淘汰。</li>\n<li><strong>volatile-lru</strong>：只对设置了过期时间的键使用 LRU 算法进行淘汰。</li>\n<li><strong>allkeys-random</strong>：对所有的键随机淘汰。</li>\n<li><strong>volatile-random</strong>：只对设置了过期时间的键随机淘汰。</li>\n<li><strong>volatile-ttl</strong>：只对设置了过期时间的键，选择即将过期的键进行淘汰。</li>\n</ul>\n<h4 id=\"Redis-4-0-之后新增的策略\"><a href=\"#Redis-4-0-之后新增的策略\" class=\"headerlink\" title=\"Redis 4.0 之后新增的策略\"></a>Redis 4.0 之后新增的策略</h4><ul>\n<li><strong>allkeys-lfu</strong>：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。</li>\n<li><strong>volatile-lfu</strong>：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n</ul>\n<h3 id=\"2-配置-Redis-缓存淘汰策略\"><a href=\"#2-配置-Redis-缓存淘汰策略\" class=\"headerlink\" title=\"2. 配置 Redis 缓存淘汰策略\"></a>2. 配置 Redis 缓存淘汰策略</h3><p>Redis 的淘汰策略可以通过修改配置文件 <code>redis.conf</code> 或运行时使用命令行配置。</p>\n<h4 id=\"配置方式一：修改-redis-conf\"><a href=\"#配置方式一：修改-redis-conf\" class=\"headerlink\" title=\"配置方式一：修改 redis.conf\"></a>配置方式一：修改 <code>redis.conf</code></h4><p>找到 Redis 配置文件 <code>redis.conf</code>，修改 <code>maxmemory-policy</code> 来设置淘汰策略。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<p>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory 256mb</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置方式二：运行时设置\"><a href=\"#配置方式二：运行时设置\" class=\"headerlink\" title=\"配置方式二：运行时设置\"></a>配置方式二：运行时设置</h4><p>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 256mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-TTL（过期时间）实现\"><a href=\"#3-TTL（过期时间）实现\" class=\"headerlink\" title=\"3. TTL（过期时间）实现\"></a>3. TTL（过期时间）实现</h3><p>Redis 提供了两种设置过期时间的方法：</p>\n<ul>\n<li><code>EXPIRE key seconds</code>：为键设置一个存活时间（秒），过期后自动删除。</li>\n<li><code>SET key value EX seconds</code>：在设置键的同时指定过期时间（秒）。</li>\n</ul>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET user:1001 <span class=\"string\">&quot;John&quot;</span> EX 60  <span class=\"comment\"># 设置 key 为 user:1001，60秒后过期</span></span><br><span class=\"line\">EXPIRE user:1002 120         <span class=\"comment\"># 为现有 key user:1002 设置120秒的过期时间</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Redis-LRU-实现机制\"><a href=\"#4-Redis-LRU-实现机制\" class=\"headerlink\" title=\"4. Redis LRU 实现机制\"></a>4. Redis LRU 实现机制</h3><p>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 <code>maxmemory-samples</code> 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><p>在配置文件中设置采样数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<p>运行时设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Redis-缓存淘汰策略实战\"><a href=\"#5-Redis-缓存淘汰策略实战\" class=\"headerlink\" title=\"5. Redis 缓存淘汰策略实战\"></a>5. Redis 缓存淘汰策略实战</h3><p>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<ol>\n<li><p><strong>设置 Redis 的最大内存和 LRU 策略</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 128mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>向 Redis 写入会话数据，并设置过期时间</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET session:user:1001 <span class=\"string\">&quot;session_data&quot;</span> EX 3600  <span class=\"comment\"># 会话信息1小时过期</span></span><br><span class=\"line\">SET session:user:1002 <span class=\"string\">&quot;session_data&quot;</span> EX 3600</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>监控淘汰情况</strong>：<br> 当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 <code>volatile-lru</code> 或 <code>volatile-ttl</code>，而如果没有过期时间且想控制整体缓存大小，可以选择 <code>allkeys-lru</code> 或 <code>allkeys-random</code>。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<ol>\n<li>Redis 支持的淘汰策略<br>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。<br>allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。<br>volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。<br>allkeys-random：对所有的键随机淘汰。<br>volatile-random：只对设置了过期时间的键随机淘汰。<br>volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。<br>Redis 4.0 之后新增的策略<br>allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。<br>volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n<li>配置 Redis 缓存淘汰策略<br>Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。</li>\n</ol>\n<p>配置方式一：修改 redis.conf<br>找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：</p>\n<p>maxmemory-policy allkeys-lru<br>1<br>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<p>maxmemory 256mb<br>1<br>配置方式二：运行时设置<br>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<p>CONFIG SET maxmemory 256mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>3. TTL（过期时间）实现<br>Redis 提供了两种设置过期时间的方法：</p>\n<p>EXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。<br>SET key value EX seconds：在设置键的同时指定过期时间（秒）。<br>示例：<br>SET user:1001 “John” EX 60  # 设置 key 为 user:1001，60秒后过期<br>EXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间<br>1<br>2<br>4. Redis LRU 实现机制<br>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<p>示例：<br>在配置文件中设置采样数：</p>\n<p>maxmemory-samples 10<br>1<br>运行时设置：</p>\n<p>CONFIG SET maxmemory-samples 10<br>1<br>5. Redis 缓存淘汰策略实战<br>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<p>设置 Redis 的最大内存和 LRU 策略：</p>\n<p>CONFIG SET maxmemory 128mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>向 Redis 写入会话数据，并设置过期时间：</p>\n<p>SET session:user:1001 “session_data” EX 3600  # 会话信息1小时过期<br>SET session:user:1002 “session_data” EX 3600<br>1<br>2<br>监控淘汰情况：<br>当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n<p>总结<br>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。</p>\n","cover":false,"excerpt":"","more":"<p>在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<h3 id=\"1-Redis-支持的淘汰策略\"><a href=\"#1-Redis-支持的淘汰策略\" class=\"headerlink\" title=\"1. Redis 支持的淘汰策略\"></a>1. Redis 支持的淘汰策略</h3><ul>\n<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。</li>\n<li><strong>allkeys-lru</strong>：对所有的键使用 LRU（最近最少使用）算法进行淘汰。</li>\n<li><strong>volatile-lru</strong>：只对设置了过期时间的键使用 LRU 算法进行淘汰。</li>\n<li><strong>allkeys-random</strong>：对所有的键随机淘汰。</li>\n<li><strong>volatile-random</strong>：只对设置了过期时间的键随机淘汰。</li>\n<li><strong>volatile-ttl</strong>：只对设置了过期时间的键，选择即将过期的键进行淘汰。</li>\n</ul>\n<h4 id=\"Redis-4-0-之后新增的策略\"><a href=\"#Redis-4-0-之后新增的策略\" class=\"headerlink\" title=\"Redis 4.0 之后新增的策略\"></a>Redis 4.0 之后新增的策略</h4><ul>\n<li><strong>allkeys-lfu</strong>：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。</li>\n<li><strong>volatile-lfu</strong>：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n</ul>\n<h3 id=\"2-配置-Redis-缓存淘汰策略\"><a href=\"#2-配置-Redis-缓存淘汰策略\" class=\"headerlink\" title=\"2. 配置 Redis 缓存淘汰策略\"></a>2. 配置 Redis 缓存淘汰策略</h3><p>Redis 的淘汰策略可以通过修改配置文件 <code>redis.conf</code> 或运行时使用命令行配置。</p>\n<h4 id=\"配置方式一：修改-redis-conf\"><a href=\"#配置方式一：修改-redis-conf\" class=\"headerlink\" title=\"配置方式一：修改 redis.conf\"></a>配置方式一：修改 <code>redis.conf</code></h4><p>找到 Redis 配置文件 <code>redis.conf</code>，修改 <code>maxmemory-policy</code> 来设置淘汰策略。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<p>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory 256mb</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置方式二：运行时设置\"><a href=\"#配置方式二：运行时设置\" class=\"headerlink\" title=\"配置方式二：运行时设置\"></a>配置方式二：运行时设置</h4><p>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 256mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-TTL（过期时间）实现\"><a href=\"#3-TTL（过期时间）实现\" class=\"headerlink\" title=\"3. TTL（过期时间）实现\"></a>3. TTL（过期时间）实现</h3><p>Redis 提供了两种设置过期时间的方法：</p>\n<ul>\n<li><code>EXPIRE key seconds</code>：为键设置一个存活时间（秒），过期后自动删除。</li>\n<li><code>SET key value EX seconds</code>：在设置键的同时指定过期时间（秒）。</li>\n</ul>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET user:1001 <span class=\"string\">&quot;John&quot;</span> EX 60  <span class=\"comment\"># 设置 key 为 user:1001，60秒后过期</span></span><br><span class=\"line\">EXPIRE user:1002 120         <span class=\"comment\"># 为现有 key user:1002 设置120秒的过期时间</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Redis-LRU-实现机制\"><a href=\"#4-Redis-LRU-实现机制\" class=\"headerlink\" title=\"4. Redis LRU 实现机制\"></a>4. Redis LRU 实现机制</h3><p>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 <code>maxmemory-samples</code> 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><p>在配置文件中设置采样数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<p>运行时设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Redis-缓存淘汰策略实战\"><a href=\"#5-Redis-缓存淘汰策略实战\" class=\"headerlink\" title=\"5. Redis 缓存淘汰策略实战\"></a>5. Redis 缓存淘汰策略实战</h3><p>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<ol>\n<li><p><strong>设置 Redis 的最大内存和 LRU 策略</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 128mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>向 Redis 写入会话数据，并设置过期时间</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET session:user:1001 <span class=\"string\">&quot;session_data&quot;</span> EX 3600  <span class=\"comment\"># 会话信息1小时过期</span></span><br><span class=\"line\">SET session:user:1002 <span class=\"string\">&quot;session_data&quot;</span> EX 3600</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>监控淘汰情况</strong>：<br> 当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 <code>volatile-lru</code> 或 <code>volatile-ttl</code>，而如果没有过期时间且想控制整体缓存大小，可以选择 <code>allkeys-lru</code> 或 <code>allkeys-random</code>。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<ol>\n<li>Redis 支持的淘汰策略<br>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。<br>allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。<br>volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。<br>allkeys-random：对所有的键随机淘汰。<br>volatile-random：只对设置了过期时间的键随机淘汰。<br>volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。<br>Redis 4.0 之后新增的策略<br>allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。<br>volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n<li>配置 Redis 缓存淘汰策略<br>Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。</li>\n</ol>\n<p>配置方式一：修改 redis.conf<br>找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：</p>\n<p>maxmemory-policy allkeys-lru<br>1<br>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<p>maxmemory 256mb<br>1<br>配置方式二：运行时设置<br>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<p>CONFIG SET maxmemory 256mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>3. TTL（过期时间）实现<br>Redis 提供了两种设置过期时间的方法：</p>\n<p>EXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。<br>SET key value EX seconds：在设置键的同时指定过期时间（秒）。<br>示例：<br>SET user:1001 “John” EX 60  # 设置 key 为 user:1001，60秒后过期<br>EXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间<br>1<br>2<br>4. Redis LRU 实现机制<br>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<p>示例：<br>在配置文件中设置采样数：</p>\n<p>maxmemory-samples 10<br>1<br>运行时设置：</p>\n<p>CONFIG SET maxmemory-samples 10<br>1<br>5. Redis 缓存淘汰策略实战<br>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<p>设置 Redis 的最大内存和 LRU 策略：</p>\n<p>CONFIG SET maxmemory 128mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>向 Redis 写入会话数据，并设置过期时间：</p>\n<p>SET session:user:1001 “session_data” EX 3600  # 会话信息1小时过期<br>SET session:user:1002 “session_data” EX 3600<br>1<br>2<br>监控淘汰情况：<br>当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n<p>总结<br>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。</p>\n"},{"title":"两个线程轮流打印0-100","date":"2025-01-19T11:14:56.000Z","catgories":"算法","_content":"\n**使用synchronized和wait/notify轮流打印0-100**\n\n这种方法利用synchronized关键字实现对共享资源的互斥访问，并使用wait和notify方法实现线程间的通信。每个线程在打印数字之前，判断是否轮到自己执行，如果不是则进入等待状态，直到被其他线程唤醒。\n\n```java\npublic class PrintOddEven {\n    private static int count = 0;\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) {\n        Thread evenThread = new Thread(() -> {\n            while (count <= 100) {\n                synchronized (lock) {\n                    if ((count & 1) == 0) {\n                        System.out.println(Thread.currentThread().getName() + \": \" + count++);\n                        lock.notify();\n                    } else {\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }, \"偶数线程\");\n\n        Thread oddThread = new Thread(() -> {\n            while (count <= 100) {\n                synchronized (lock) {\n                    if ((count & 1) != 0) {\n                        System.out.println(Thread.currentThread().getName() + \": \" + count++);\n                        lock.notify();\n                    } else {\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }, \"奇数线程\");\n\n        evenThread.start();\n        oddThread.start();\n    }\n}\n```\n","source":"_posts/两个线程轮流打印0-100.md","raw":"---\ntitle: 两个线程轮流打印0-100\ndate: 2025-01-19 19:14:56\ntags: 算法\ncatgories: 算法\n---\n\n**使用synchronized和wait/notify轮流打印0-100**\n\n这种方法利用synchronized关键字实现对共享资源的互斥访问，并使用wait和notify方法实现线程间的通信。每个线程在打印数字之前，判断是否轮到自己执行，如果不是则进入等待状态，直到被其他线程唤醒。\n\n```java\npublic class PrintOddEven {\n    private static int count = 0;\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) {\n        Thread evenThread = new Thread(() -> {\n            while (count <= 100) {\n                synchronized (lock) {\n                    if ((count & 1) == 0) {\n                        System.out.println(Thread.currentThread().getName() + \": \" + count++);\n                        lock.notify();\n                    } else {\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }, \"偶数线程\");\n\n        Thread oddThread = new Thread(() -> {\n            while (count <= 100) {\n                synchronized (lock) {\n                    if ((count & 1) != 0) {\n                        System.out.println(Thread.currentThread().getName() + \": \" + count++);\n                        lock.notify();\n                    } else {\n                        try {\n                            lock.wait();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }, \"奇数线程\");\n\n        evenThread.start();\n        oddThread.start();\n    }\n}\n```\n","slug":"两个线程轮流打印0-100","published":1,"updated":"2025-01-19T11:30:40.034Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd22001c3ga8afa67j6d","content":"<p><strong>使用synchronized和wait&#x2F;notify轮流打印0-100</strong></p>\n<p>这种方法利用synchronized关键字实现对共享资源的互斥访问，并使用wait和notify方法实现线程间的通信。每个线程在打印数字之前，判断是否轮到自己执行，如果不是则进入等待状态，直到被其他线程唤醒。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrintOddEven</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">evenThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((count &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: &quot;</span> + count++);</span><br><span class=\"line\">                        lock.notify();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;偶数线程&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">oddThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((count &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: &quot;</span> + count++);</span><br><span class=\"line\">                        lock.notify();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;奇数线程&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        evenThread.start();</span><br><span class=\"line\">        oddThread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","cover":false,"excerpt":"","more":"<p><strong>使用synchronized和wait&#x2F;notify轮流打印0-100</strong></p>\n<p>这种方法利用synchronized关键字实现对共享资源的互斥访问，并使用wait和notify方法实现线程间的通信。每个线程在打印数字之前，判断是否轮到自己执行，如果不是则进入等待状态，直到被其他线程唤醒。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PrintOddEven</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">evenThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((count &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: &quot;</span> + count++);</span><br><span class=\"line\">                        lock.notify();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;偶数线程&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">oddThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((count &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: &quot;</span> + count++);</span><br><span class=\"line\">                        lock.notify();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;奇数线程&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        evenThread.start();</span><br><span class=\"line\">        oddThread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"redo log和undo log","date":"2024-10-15T05:55:26.000Z","_content":"\n# 1.redo log:\n\nRedo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。\n\n## Redo Log 的工作原理：\n\n1. 事务开始：\n   当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。\n\n2. 写入内存：\n   修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。\n\n3. 写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。\n\n4. 数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。\n\n5. 崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。\n\n## Redo Log 的特性：\n\n- 循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。\n\n- 持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。\n\n- 效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。\n  \n  ### Redo Log 与 Binlog 的区别：\n\n- Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。\n\n- Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。\n  通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。\n  \n  # 2.undo log:\n  \n  Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和**多版本并发控制（MVCC）**的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。\n\n## Undo Log 的工作原理：\n\n1. 事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。\n\n2. 回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。\n\n3. 多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。\n\n## Undo Log 的特性：\n\n- 用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。\n\n- 支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。\n\n- 存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。\n\n- 删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。\n\n## Undo Log 与 Redo Log 的区别：\n\n- Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。\n\n- Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。\n  \n  ## Undo Log 的作用：\n1. 回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。\n\n2. 快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。\n\n总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。\n","source":"_posts/redo-log和undo-log.md","raw":"---\ntitle: redo log和undo log\ndate: 2024-10-15 13:55:26\ntags: mysql\ncategories: 八股文\n---\n\n# 1.redo log:\n\nRedo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。\n\n## Redo Log 的工作原理：\n\n1. 事务开始：\n   当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。\n\n2. 写入内存：\n   修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。\n\n3. 写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。\n\n4. 数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。\n\n5. 崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。\n\n## Redo Log 的特性：\n\n- 循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。\n\n- 持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。\n\n- 效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。\n  \n  ### Redo Log 与 Binlog 的区别：\n\n- Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。\n\n- Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。\n  通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。\n  \n  # 2.undo log:\n  \n  Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和**多版本并发控制（MVCC）**的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。\n\n## Undo Log 的工作原理：\n\n1. 事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。\n\n2. 回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。\n\n3. 多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。\n\n## Undo Log 的特性：\n\n- 用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。\n\n- 支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。\n\n- 存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。\n\n- 删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。\n\n## Undo Log 与 Redo Log 的区别：\n\n- Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。\n\n- Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。\n  \n  ## Undo Log 的作用：\n1. 回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。\n\n2. 快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。\n\n总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。\n","slug":"redo-log和undo-log","published":1,"updated":"2024-12-14T09:14:44.312Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd23001f3ga87yhe2ycn","content":"<h1 id=\"1-redo-log\"><a href=\"#1-redo-log\" class=\"headerlink\" title=\"1.redo log:\"></a>1.redo log:</h1><p>Redo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。</p>\n<h2 id=\"Redo-Log-的工作原理：\"><a href=\"#Redo-Log-的工作原理：\" class=\"headerlink\" title=\"Redo Log 的工作原理：\"></a>Redo Log 的工作原理：</h2><ol>\n<li><p>事务开始：<br>当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。</p>\n</li>\n<li><p>写入内存：<br>修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。</p>\n</li>\n<li><p>写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。</p>\n</li>\n<li><p>数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。</p>\n</li>\n<li><p>崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。</p>\n</li>\n</ol>\n<h2 id=\"Redo-Log-的特性：\"><a href=\"#Redo-Log-的特性：\" class=\"headerlink\" title=\"Redo Log 的特性：\"></a>Redo Log 的特性：</h2><ul>\n<li><p>循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。</p>\n</li>\n<li><p>持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。</p>\n</li>\n<li><p>效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。</p>\n<h3 id=\"Redo-Log-与-Binlog-的区别：\"><a href=\"#Redo-Log-与-Binlog-的区别：\" class=\"headerlink\" title=\"Redo Log 与 Binlog 的区别：\"></a>Redo Log 与 Binlog 的区别：</h3></li>\n<li><p>Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。</p>\n</li>\n<li><p>Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。<br>通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。</p>\n<h1 id=\"2-undo-log\"><a href=\"#2-undo-log\" class=\"headerlink\" title=\"2.undo log:\"></a>2.undo log:</h1><p>Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和<strong>多版本并发控制（MVCC）</strong>的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-的工作原理：\"><a href=\"#Undo-Log-的工作原理：\" class=\"headerlink\" title=\"Undo Log 的工作原理：\"></a>Undo Log 的工作原理：</h2><ol>\n<li><p>事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。</p>\n</li>\n<li><p>回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。</p>\n</li>\n<li><p>多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。</p>\n</li>\n</ol>\n<h2 id=\"Undo-Log-的特性：\"><a href=\"#Undo-Log-的特性：\" class=\"headerlink\" title=\"Undo Log 的特性：\"></a>Undo Log 的特性：</h2><ul>\n<li><p>用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。</p>\n</li>\n<li><p>支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。</p>\n</li>\n<li><p>存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。</p>\n</li>\n<li><p>删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-与-Redo-Log-的区别：\"><a href=\"#Undo-Log-与-Redo-Log-的区别：\" class=\"headerlink\" title=\"Undo Log 与 Redo Log 的区别：\"></a>Undo Log 与 Redo Log 的区别：</h2><ul>\n<li><p>Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。</p>\n</li>\n<li><p>Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。</p>\n<h2 id=\"Undo-Log-的作用：\"><a href=\"#Undo-Log-的作用：\" class=\"headerlink\" title=\"Undo Log 的作用：\"></a>Undo Log 的作用：</h2></li>\n</ul>\n<ol>\n<li><p>回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。</p>\n</li>\n<li><p>快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。</p>\n</li>\n</ol>\n<p>总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"1-redo-log\"><a href=\"#1-redo-log\" class=\"headerlink\" title=\"1.redo log:\"></a>1.redo log:</h1><p>Redo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。</p>\n<h2 id=\"Redo-Log-的工作原理：\"><a href=\"#Redo-Log-的工作原理：\" class=\"headerlink\" title=\"Redo Log 的工作原理：\"></a>Redo Log 的工作原理：</h2><ol>\n<li><p>事务开始：<br>当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。</p>\n</li>\n<li><p>写入内存：<br>修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。</p>\n</li>\n<li><p>写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。</p>\n</li>\n<li><p>数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。</p>\n</li>\n<li><p>崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。</p>\n</li>\n</ol>\n<h2 id=\"Redo-Log-的特性：\"><a href=\"#Redo-Log-的特性：\" class=\"headerlink\" title=\"Redo Log 的特性：\"></a>Redo Log 的特性：</h2><ul>\n<li><p>循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。</p>\n</li>\n<li><p>持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。</p>\n</li>\n<li><p>效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。</p>\n<h3 id=\"Redo-Log-与-Binlog-的区别：\"><a href=\"#Redo-Log-与-Binlog-的区别：\" class=\"headerlink\" title=\"Redo Log 与 Binlog 的区别：\"></a>Redo Log 与 Binlog 的区别：</h3></li>\n<li><p>Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。</p>\n</li>\n<li><p>Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。<br>通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。</p>\n<h1 id=\"2-undo-log\"><a href=\"#2-undo-log\" class=\"headerlink\" title=\"2.undo log:\"></a>2.undo log:</h1><p>Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和<strong>多版本并发控制（MVCC）</strong>的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-的工作原理：\"><a href=\"#Undo-Log-的工作原理：\" class=\"headerlink\" title=\"Undo Log 的工作原理：\"></a>Undo Log 的工作原理：</h2><ol>\n<li><p>事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。</p>\n</li>\n<li><p>回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。</p>\n</li>\n<li><p>多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。</p>\n</li>\n</ol>\n<h2 id=\"Undo-Log-的特性：\"><a href=\"#Undo-Log-的特性：\" class=\"headerlink\" title=\"Undo Log 的特性：\"></a>Undo Log 的特性：</h2><ul>\n<li><p>用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。</p>\n</li>\n<li><p>支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。</p>\n</li>\n<li><p>存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。</p>\n</li>\n<li><p>删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-与-Redo-Log-的区别：\"><a href=\"#Undo-Log-与-Redo-Log-的区别：\" class=\"headerlink\" title=\"Undo Log 与 Redo Log 的区别：\"></a>Undo Log 与 Redo Log 的区别：</h2><ul>\n<li><p>Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。</p>\n</li>\n<li><p>Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。</p>\n<h2 id=\"Undo-Log-的作用：\"><a href=\"#Undo-Log-的作用：\" class=\"headerlink\" title=\"Undo Log 的作用：\"></a>Undo Log 的作用：</h2></li>\n</ul>\n<ol>\n<li><p>回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。</p>\n</li>\n<li><p>快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。</p>\n</li>\n</ol>\n<p>总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。</p>\n"},{"title":"实在智能实习经历收获","date":"2024-10-26T10:32:16.000Z","_content":"\n> 2024年9月18日入职杭州实在智能有限公司java实习生\n\n## 实习历程：\n\n- 刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令\n\n- 杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解\n\n- 接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力\n\n- 设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用\n\n- 设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回\n\n- 完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug\n\n- 完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题\n\n- 完成crm接口的开发，联调，测试，上线\n\n## 实习项目介绍（实习经历）\n\n**项目介绍：**\n\nIDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：[http://idp.ai-indeed.com/](http://idp.ai-indeed.com/)。\n\n**负责模块**:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署\n\n**主要工作：** \n\n- **自定义抽取模板开发**：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。\n- **自定义抽取任务管理**：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。\n- **OCR集成与CRM审核模板生成**：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。\n- **CRM异步任务处理和结果反馈**：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。\n- **私有化定制部署**：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。\n\n## 实习期间遇到的难点：\n\n- 项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核\n  解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核\n\n- 项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台\n  首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台\n","source":"_posts/实在智能实习经历收获.md","raw":"---\ntitle: 实在智能实习经历收获\ndate: 2024-10-26 18:32:16\ntags: 实习\ncategories: 实习业务\n---\n\n> 2024年9月18日入职杭州实在智能有限公司java实习生\n\n## 实习历程：\n\n- 刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令\n\n- 杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解\n\n- 接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力\n\n- 设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用\n\n- 设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回\n\n- 完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug\n\n- 完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题\n\n- 完成crm接口的开发，联调，测试，上线\n\n## 实习项目介绍（实习经历）\n\n**项目介绍：**\n\nIDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：[http://idp.ai-indeed.com/](http://idp.ai-indeed.com/)。\n\n**负责模块**:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署\n\n**主要工作：** \n\n- **自定义抽取模板开发**：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。\n- **自定义抽取任务管理**：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。\n- **OCR集成与CRM审核模板生成**：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。\n- **CRM异步任务处理和结果反馈**：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。\n- **私有化定制部署**：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。\n\n## 实习期间遇到的难点：\n\n- 项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核\n  解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核\n\n- 项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台\n  首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台\n","slug":"实在智能实习经历收获","published":1,"updated":"2024-12-14T09:16:47.121Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd24001j3ga8bqd19rpd","content":"<blockquote>\n<p>2024年9月18日入职杭州实在智能有限公司java实习生</p>\n</blockquote>\n<h2 id=\"实习历程：\"><a href=\"#实习历程：\" class=\"headerlink\" title=\"实习历程：\"></a>实习历程：</h2><ul>\n<li><p>刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令</p>\n</li>\n<li><p>杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解</p>\n</li>\n<li><p>接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力</p>\n</li>\n<li><p>设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用</p>\n</li>\n<li><p>设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回</p>\n</li>\n<li><p>完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug</p>\n</li>\n<li><p>完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题</p>\n</li>\n<li><p>完成crm接口的开发，联调，测试，上线</p>\n</li>\n</ul>\n<h2 id=\"实习项目介绍（实习经历）\"><a href=\"#实习项目介绍（实习经历）\" class=\"headerlink\" title=\"实习项目介绍（实习经历）\"></a>实习项目介绍（实习经历）</h2><p><strong>项目介绍：</strong></p>\n<p>IDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：<a href=\"http://idp.ai-indeed.com/\">http://idp.ai-indeed.com/</a>。</p>\n<p><strong>负责模块</strong>:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署</p>\n<p><strong>主要工作：</strong> </p>\n<ul>\n<li><strong>自定义抽取模板开发</strong>：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。</li>\n<li><strong>自定义抽取任务管理</strong>：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。</li>\n<li><strong>OCR集成与CRM审核模板生成</strong>：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。</li>\n<li><strong>CRM异步任务处理和结果反馈</strong>：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。</li>\n<li><strong>私有化定制部署</strong>：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。</li>\n</ul>\n<h2 id=\"实习期间遇到的难点：\"><a href=\"#实习期间遇到的难点：\" class=\"headerlink\" title=\"实习期间遇到的难点：\"></a>实习期间遇到的难点：</h2><ul>\n<li><p>项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核<br>解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核</p>\n</li>\n<li><p>项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台<br>首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<blockquote>\n<p>2024年9月18日入职杭州实在智能有限公司java实习生</p>\n</blockquote>\n<h2 id=\"实习历程：\"><a href=\"#实习历程：\" class=\"headerlink\" title=\"实习历程：\"></a>实习历程：</h2><ul>\n<li><p>刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令</p>\n</li>\n<li><p>杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解</p>\n</li>\n<li><p>接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力</p>\n</li>\n<li><p>设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用</p>\n</li>\n<li><p>设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回</p>\n</li>\n<li><p>完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug</p>\n</li>\n<li><p>完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题</p>\n</li>\n<li><p>完成crm接口的开发，联调，测试，上线</p>\n</li>\n</ul>\n<h2 id=\"实习项目介绍（实习经历）\"><a href=\"#实习项目介绍（实习经历）\" class=\"headerlink\" title=\"实习项目介绍（实习经历）\"></a>实习项目介绍（实习经历）</h2><p><strong>项目介绍：</strong></p>\n<p>IDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：<a href=\"http://idp.ai-indeed.com/\">http://idp.ai-indeed.com/</a>。</p>\n<p><strong>负责模块</strong>:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署</p>\n<p><strong>主要工作：</strong> </p>\n<ul>\n<li><strong>自定义抽取模板开发</strong>：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。</li>\n<li><strong>自定义抽取任务管理</strong>：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。</li>\n<li><strong>OCR集成与CRM审核模板生成</strong>：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。</li>\n<li><strong>CRM异步任务处理和结果反馈</strong>：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。</li>\n<li><strong>私有化定制部署</strong>：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。</li>\n</ul>\n<h2 id=\"实习期间遇到的难点：\"><a href=\"#实习期间遇到的难点：\" class=\"headerlink\" title=\"实习期间遇到的难点：\"></a>实习期间遇到的难点：</h2><ul>\n<li><p>项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核<br>解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核</p>\n</li>\n<li><p>项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台<br>首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台</p>\n</li>\n</ul>\n"},{"title":"删除链表的倒数第n个结点","date":"2025-02-03T10:15:21.000Z","_content":"\n# 题目\n\n[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n提示\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n**输入：**head = [1,2,3,4,5], n = 2\n**输出：**[1,2,3,5]\n\n**示例 2：**\n\n**输入：**head = [1], n = 1\n**输出：**[]\n\n**示例 3：**\n\n**输入：**head = [1,2], n = 1\n**输出：**[1]\n\n**提示：**\n\n- 链表中结点的数目为 `sz`\n- `1 <= sz <= 30`\n- `0 <= Node.val <= 100`\n- `1 <= n <= sz`\n\n# 题解\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int num=0;\n        ListNode p = head;\n        while(p!=null)\n        {\n            num++;\n            p=p.next;\n        }\n        int order = num-n+1;\n        if(order<1||order>num)\n        {\n            return head;\n        }\n        if(order==1)\n        {\n            return head.next;\n        }\n        p=head;\n        ListNode q=head.next;\n        order--;\n        while(order>0)\n        {\n            order--;\n            if(order == 0)\n            {\n                p.next=q.next;\n                return head;\n            }\n            p=p.next;\n            q=q.next;\n        }\n        return head;\n    }\n}\n```\n\n# 思路\n\n- 先扫描一次链表得到结点数\n\n- 计算顺数的顺序\n\n- 遍历到对应的节点，将该节点前面的节点指向该节点的后面节点\n\n- 返回结果的头节点\n","source":"_posts/删除链表的倒数第n个结点.md","raw":"---\ntitle: 删除链表的倒数第n个结点\ndate: 2025-02-03 18:15:21\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n提示\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n**输入：**head = [1,2,3,4,5], n = 2\n**输出：**[1,2,3,5]\n\n**示例 2：**\n\n**输入：**head = [1], n = 1\n**输出：**[]\n\n**示例 3：**\n\n**输入：**head = [1,2], n = 1\n**输出：**[1]\n\n**提示：**\n\n- 链表中结点的数目为 `sz`\n- `1 <= sz <= 30`\n- `0 <= Node.val <= 100`\n- `1 <= n <= sz`\n\n# 题解\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int num=0;\n        ListNode p = head;\n        while(p!=null)\n        {\n            num++;\n            p=p.next;\n        }\n        int order = num-n+1;\n        if(order<1||order>num)\n        {\n            return head;\n        }\n        if(order==1)\n        {\n            return head.next;\n        }\n        p=head;\n        ListNode q=head.next;\n        order--;\n        while(order>0)\n        {\n            order--;\n            if(order == 0)\n            {\n                p.next=q.next;\n                return head;\n            }\n            p=p.next;\n            q=q.next;\n        }\n        return head;\n    }\n}\n```\n\n# 思路\n\n- 先扫描一次链表得到结点数\n\n- 计算顺数的顺序\n\n- 遍历到对应的节点，将该节点前面的节点指向该节点的后面节点\n\n- 返回结果的头节点\n","slug":"删除链表的倒数第n个结点","published":1,"updated":"2025-02-03T10:19:30.163Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd24001m3ga80gkt1ke7","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\">19. 删除链表的倒数第 N 个结点</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>提示</p>\n<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\"></p>\n<p><strong>输入：</strong>head &#x3D; [1,2,3,4,5], n &#x3D; 2<br><strong>输出：</strong>[1,2,3,5]</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>head &#x3D; [1], n &#x3D; 1<br><strong>输出：</strong>[]</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong>head &#x3D; [1,2], n &#x3D; 1<br><strong>输出：</strong>[1]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中结点的数目为 <code>sz</code></li>\n<li><code>1 &lt;= sz &lt;= 30</code></li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            num++;</span><br><span class=\"line\">            p=p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> num-n+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(order&lt;<span class=\"number\">1</span>||order&gt;num)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(order==<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p=head;</span><br><span class=\"line\">        ListNode q=head.next;</span><br><span class=\"line\">        order--;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(order&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            order--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(order == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                p.next=q.next;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p=p.next;</span><br><span class=\"line\">            q=q.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>先扫描一次链表得到结点数</p>\n</li>\n<li><p>计算顺数的顺序</p>\n</li>\n<li><p>遍历到对应的节点，将该节点前面的节点指向该节点的后面节点</p>\n</li>\n<li><p>返回结果的头节点</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\">19. 删除链表的倒数第 N 个结点</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>提示</p>\n<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\"></p>\n<p><strong>输入：</strong>head &#x3D; [1,2,3,4,5], n &#x3D; 2<br><strong>输出：</strong>[1,2,3,5]</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>head &#x3D; [1], n &#x3D; 1<br><strong>输出：</strong>[]</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong>head &#x3D; [1,2], n &#x3D; 1<br><strong>输出：</strong>[1]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中结点的数目为 <code>sz</code></li>\n<li><code>1 &lt;= sz &lt;= 30</code></li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            num++;</span><br><span class=\"line\">            p=p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> num-n+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(order&lt;<span class=\"number\">1</span>||order&gt;num)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(order==<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p=head;</span><br><span class=\"line\">        ListNode q=head.next;</span><br><span class=\"line\">        order--;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(order&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            order--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(order == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                p.next=q.next;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p=p.next;</span><br><span class=\"line\">            q=q.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>先扫描一次链表得到结点数</p>\n</li>\n<li><p>计算顺数的顺序</p>\n</li>\n<li><p>遍历到对应的节点，将该节点前面的节点指向该节点的后面节点</p>\n</li>\n<li><p>返回结果的头节点</p>\n</li>\n</ul>\n"},{"title":"工厂+注册表模式设计nodeHandler","date":"2024-11-14T13:09:17.000Z","_content":"\n# 工厂+注册表模式获取nodeHandler\n\n自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler\n\n其中一个是默认nodeHandler.\n\n由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点\n\n```java\npackage ai.ii.supertext.app.serivce.extraction.handler;\n\nimport ai.ii.supertext.plus.common.util.SpringContext;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Configuration\npublic class NodeHandlerFactory {\n\n    private static final ConcurrentHashMap<String, NodeHandler> nodeHandlerMap = new ConcurrentHashMap<>();\n\n    public static void registerHandler(NodeHandler handler) {\n        nodeHandlerMap.put(handler.getNodeCode(), handler);\n    }\n\n    public NodeHandler getNodeHandler(String nodeCode) {\n        if (nodeCode == null) {\n            log.error(\"action=getNodeHandler node is null. please confirm config\");\n            return null;\n        }\n        return nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));\n    }\n}\n```\n\n工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。\n因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂\n\n工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.\n\n使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本\n","source":"_posts/工厂-注册表模式设计nodeHandler.md","raw":"---\ntitle: 工厂+注册表模式设计nodeHandler\ndate: 2024-11-14 21:09:17\ntags: 设计模式\ncategories: 业务场景\n---\n\n# 工厂+注册表模式获取nodeHandler\n\n自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler\n\n其中一个是默认nodeHandler.\n\n由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点\n\n```java\npackage ai.ii.supertext.app.serivce.extraction.handler;\n\nimport ai.ii.supertext.plus.common.util.SpringContext;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Configuration\npublic class NodeHandlerFactory {\n\n    private static final ConcurrentHashMap<String, NodeHandler> nodeHandlerMap = new ConcurrentHashMap<>();\n\n    public static void registerHandler(NodeHandler handler) {\n        nodeHandlerMap.put(handler.getNodeCode(), handler);\n    }\n\n    public NodeHandler getNodeHandler(String nodeCode) {\n        if (nodeCode == null) {\n            log.error(\"action=getNodeHandler node is null. please confirm config\");\n            return null;\n        }\n        return nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));\n    }\n}\n```\n\n工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。\n因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂\n\n工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.\n\n使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本\n","slug":"工厂-注册表模式设计nodeHandler","published":1,"updated":"2024-12-14T09:15:53.521Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd27001q3ga8cdi76aje","content":"<h1 id=\"工厂-注册表模式获取nodeHandler\"><a href=\"#工厂-注册表模式获取nodeHandler\" class=\"headerlink\" title=\"工厂+注册表模式获取nodeHandler\"></a>工厂+注册表模式获取nodeHandler</h1><p>自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler</p>\n<p>其中一个是默认nodeHandler.</p>\n<p>由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ai.ii.supertext.app.serivce.extraction.handler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ai.ii.supertext.plus.common.util.SpringContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NodeHandlerFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, NodeHandler&gt; nodeHandlerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerHandler</span><span class=\"params\">(NodeHandler handler)</span> &#123;</span><br><span class=\"line\">        nodeHandlerMap.put(handler.getNodeCode(), handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> NodeHandler <span class=\"title function_\">getNodeHandler</span><span class=\"params\">(String nodeCode)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeCode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;action=getNodeHandler node is null. please confirm config&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。<br>因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂</p>\n<p>工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.</p>\n<p>使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"工厂-注册表模式获取nodeHandler\"><a href=\"#工厂-注册表模式获取nodeHandler\" class=\"headerlink\" title=\"工厂+注册表模式获取nodeHandler\"></a>工厂+注册表模式获取nodeHandler</h1><p>自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler</p>\n<p>其中一个是默认nodeHandler.</p>\n<p>由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ai.ii.supertext.app.serivce.extraction.handler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ai.ii.supertext.plus.common.util.SpringContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NodeHandlerFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, NodeHandler&gt; nodeHandlerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerHandler</span><span class=\"params\">(NodeHandler handler)</span> &#123;</span><br><span class=\"line\">        nodeHandlerMap.put(handler.getNodeCode(), handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> NodeHandler <span class=\"title function_\">getNodeHandler</span><span class=\"params\">(String nodeCode)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeCode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;action=getNodeHandler node is null. please confirm config&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。<br>因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂</p>\n<p>工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.</p>\n<p>使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本</p>\n"},{"title":"206.反转链表","date":"2025-01-08T14:00:24.000Z","_content":"\n# 题目\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n**输入**：head = [1,2,3,4,5]\n**输出：**[5,4,3,2,1]\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n**输入**：head = [1,2]\n**输出：**[2,1]\n\n**示例 3**：\n\n**输入**：head = []\n**输出：**[]\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 5000]`\n- `-5000 <= Node.val <= 5000`\n\n\n\n# 题解\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode before = null;\n        ListNode current = head;\n        while(current!=null)\n        {\n            ListNode after = current.next;\n            current.next = before;\n            before = current;\n            current = after;\n        }\n        return before;\n    }\n}\n```\n\n\n\n# 思路\n\n双指针加临时指针迭代\n","source":"_posts/反转链表.md","raw":"---\ntitle: 206.反转链表\ndate: 2025-01-08 22:00:24\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n**输入**：head = [1,2,3,4,5]\n**输出：**[5,4,3,2,1]\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n**输入**：head = [1,2]\n**输出：**[2,1]\n\n**示例 3**：\n\n**输入**：head = []\n**输出：**[]\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 5000]`\n- `-5000 <= Node.val <= 5000`\n\n\n\n# 题解\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode before = null;\n        ListNode current = head;\n        while(current!=null)\n        {\n            ListNode after = current.next;\n            current.next = before;\n            before = current;\n            current = after;\n        }\n        return before;\n    }\n}\n```\n\n\n\n# 思路\n\n双指针加临时指针迭代\n","slug":"反转链表","published":1,"updated":"2025-01-08T14:32:59.044Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd27001t3ga8epeoc5oq","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\"></p>\n<p><strong>输入</strong>：head &#x3D; [1,2,3,4,5]<br><strong>输出：</strong>[5,4,3,2,1]</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\"></p>\n<p><strong>输入</strong>：head &#x3D; [1,2]<br><strong>输出：</strong>[2,1]</p>\n<p><strong>示例 3</strong>：</p>\n<p><strong>输入</strong>：head &#x3D; []<br><strong>输出：</strong>[]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">before</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current!=<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">ListNode</span> <span class=\"variable\">after</span> <span class=\"operator\">=</span> current.next;</span><br><span class=\"line\">            current.next = before;</span><br><span class=\"line\">            before = current;</span><br><span class=\"line\">            current = after;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> before;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>双指针加临时指针迭代</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\"></p>\n<p><strong>输入</strong>：head &#x3D; [1,2,3,4,5]<br><strong>输出：</strong>[5,4,3,2,1]</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\"></p>\n<p><strong>输入</strong>：head &#x3D; [1,2]<br><strong>输出：</strong>[2,1]</p>\n<p><strong>示例 3</strong>：</p>\n<p><strong>输入</strong>：head &#x3D; []<br><strong>输出：</strong>[]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">before</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current!=<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">ListNode</span> <span class=\"variable\">after</span> <span class=\"operator\">=</span> current.next;</span><br><span class=\"line\">            current.next = before;</span><br><span class=\"line\">            before = current;</span><br><span class=\"line\">            current = after;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> before;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>双指针加临时指针迭代</p>\n"},{"title":"旋转图像","date":"2025-02-02T11:53:03.000Z","_content":"\n# 题目\n\n给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n\n**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]\n**输出：**[[7,4,1],[8,5,2],[9,6,3]]\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n\n**输入：**matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n**输出：**[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n**提示：**\n\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 20`\n- `-1000 <= matrix[i][j] <= 1000`\n\n# 题解\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for(int i=0;i<=(n-1)/2;i++)\n        {\n            for(int j=i;j<n-i-1;j++)\n            {\n                int swap = matrix[j][n-1-i];\n                matrix[j][n-1-i]=matrix[i][j];\n                matrix[i][j]=matrix[n-1-j][i];\n                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];\n                matrix[n-1-i][n-1-j]=swap;\n            }\n        }\n    }\n}\n```\n\n# 思路\n\n- 顺时针旋转90度的坐标关系：(i,j)->(j,n-1-i)\n\n- 每个坐标旋转的时候会影响四个坐标，将这四个坐标顺时针旋转交换\n\n- 避免重复交换，要注意坐标遍历取值\n","source":"_posts/旋转图像.md","raw":"---\ntitle: 旋转图像\ndate: 2025-02-02 19:53:03\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n\n**示例 1：**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n\n**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]\n**输出：**[[7,4,1],[8,5,2],[9,6,3]]\n\n**示例 2：**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n\n**输入：**matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n**输出：**[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n**提示：**\n\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 20`\n- `-1000 <= matrix[i][j] <= 1000`\n\n# 题解\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for(int i=0;i<=(n-1)/2;i++)\n        {\n            for(int j=i;j<n-i-1;j++)\n            {\n                int swap = matrix[j][n-1-i];\n                matrix[j][n-1-i]=matrix[i][j];\n                matrix[i][j]=matrix[n-1-j][i];\n                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];\n                matrix[n-1-i][n-1-j]=swap;\n            }\n        }\n    }\n}\n```\n\n# 思路\n\n- 顺时针旋转90度的坐标关系：(i,j)->(j,n-1-i)\n\n- 每个坐标旋转的时候会影响四个坐标，将这四个坐标顺时针旋转交换\n\n- 避免重复交换，要注意坐标遍历取值\n","slug":"旋转图像","published":1,"updated":"2025-02-02T12:04:12.030Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd28001y3ga8a24meocd","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>\n<p>你必须在 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == matrix.length == matrix[i].length</code></li>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rotate</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> matrix.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=(n-<span class=\"number\">1</span>)/<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j&lt;n-i-<span class=\"number\">1</span>;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">swap</span> <span class=\"operator\">=</span> matrix[j][n-<span class=\"number\">1</span>-i];</span><br><span class=\"line\">                matrix[j][n-<span class=\"number\">1</span>-i]=matrix[i][j];</span><br><span class=\"line\">                matrix[i][j]=matrix[n-<span class=\"number\">1</span>-j][i];</span><br><span class=\"line\">                matrix[n-<span class=\"number\">1</span>-j][i]=matrix[n-<span class=\"number\">1</span>-i][n-<span class=\"number\">1</span>-j];</span><br><span class=\"line\">                matrix[n-<span class=\"number\">1</span>-i][n-<span class=\"number\">1</span>-j]=swap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>顺时针旋转90度的坐标关系：(i,j)-&gt;(j,n-1-i)</p>\n</li>\n<li><p>每个坐标旋转的时候会影响四个坐标，将这四个坐标顺时针旋转交换</p>\n</li>\n<li><p>避免重复交换，要注意坐标遍历取值</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>\n<p>你必须在 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br><strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == matrix.length == matrix[i].length</code></li>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rotate</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> matrix.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=(n-<span class=\"number\">1</span>)/<span class=\"number\">2</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i;j&lt;n-i-<span class=\"number\">1</span>;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">swap</span> <span class=\"operator\">=</span> matrix[j][n-<span class=\"number\">1</span>-i];</span><br><span class=\"line\">                matrix[j][n-<span class=\"number\">1</span>-i]=matrix[i][j];</span><br><span class=\"line\">                matrix[i][j]=matrix[n-<span class=\"number\">1</span>-j][i];</span><br><span class=\"line\">                matrix[n-<span class=\"number\">1</span>-j][i]=matrix[n-<span class=\"number\">1</span>-i][n-<span class=\"number\">1</span>-j];</span><br><span class=\"line\">                matrix[n-<span class=\"number\">1</span>-i][n-<span class=\"number\">1</span>-j]=swap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>顺时针旋转90度的坐标关系：(i,j)-&gt;(j,n-1-i)</p>\n</li>\n<li><p>每个坐标旋转的时候会影响四个坐标，将这四个坐标顺时针旋转交换</p>\n</li>\n<li><p>避免重复交换，要注意坐标遍历取值</p>\n</li>\n</ul>\n"},{"title":"搜索二维矩阵","date":"2025-02-02T12:07:39.000Z","_content":"\n# 题目\n\n[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n\n- 每行的元素从左到右升序排列。\n- 每列的元素从上到下升序排列。\n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)\n\n**输入：**matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n**输出：**true\n\n**示例 2：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)\n\n**输入：**matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n**输出：**false\n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= n, m <= 300`\n- `-109 <= matrix[i][j] <= 109`\n- 每行的所有元素从左到右升序排列\n- 每列的所有元素从上到下升序排列\n- `-109 <= target <= 109`\n\n# 题解\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n       int m = matrix.length;\n       int n = matrix[0].length;\n       if(m==0||n==0)\n       {\n        return false;\n       }\n       boolean[] flag= new boolean[m*n];\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.addLast((m/2)*n+n/2);\n        while(queue.size()>0)\n        {\n            int front = queue.get(0);\n            int i = front/n;\n            int j = front-front/n*n;\n            if(target>matrix[i][j])\n            {\n                if(i+1<m&&!flag[(i+1)*n+j])\n                {\n                    queue.addLast((i+1)*n+j);\n                    flag[(i+1)*n+j]=true;\n                }\n                if(j+1<n&&!flag[i*n+j+1])\n                {\n                    queue.addLast(i*n+j+1);\n                    flag[i*n+j+1]=true;\n                }\n            } else if(target<matrix[i][j])\n            {\n                if(i-1>=0&&!flag[(i-1)*n+j])\n                {\n                    queue.addLast((i-1)*n+j);\n                    flag[(i-1)*n+j]=true;\n                }\n                if(j-1>=0&&!flag[i*n+j-1])\n                {\n                    queue.addLast(i*n+j-1);\n                    flag[i*n+j-1]=true;\n                }\n            } else {\n                return true;\n            }\n            queue.removeFirst();\n        }\n        return false;\n    }\n}\n```\n\n# 思路\n\n- 利用队列数据结构实现广度搜索\n\n- 从中心位置开始广搜，记录已经搜过的点，避免重复搜索\n\n- 比当前值大，往右下搜索，比当前值小，往左上搜索，相等返回true，最终没找到返回false\n","source":"_posts/搜索二维矩阵.md","raw":"---\ntitle: 搜索二维矩阵\ndate: 2025-02-02 20:07:39\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)\n\n已解答\n\n中等\n\n相关标签\n\n相关企业\n\n编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n\n- 每行的元素从左到右升序排列。\n- 每列的元素从上到下升序排列。\n\n**示例 1：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)\n\n**输入：**matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n**输出：**true\n\n**示例 2：**\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)\n\n**输入：**matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n**输出：**false\n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= n, m <= 300`\n- `-109 <= matrix[i][j] <= 109`\n- 每行的所有元素从左到右升序排列\n- 每列的所有元素从上到下升序排列\n- `-109 <= target <= 109`\n\n# 题解\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n       int m = matrix.length;\n       int n = matrix[0].length;\n       if(m==0||n==0)\n       {\n        return false;\n       }\n       boolean[] flag= new boolean[m*n];\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.addLast((m/2)*n+n/2);\n        while(queue.size()>0)\n        {\n            int front = queue.get(0);\n            int i = front/n;\n            int j = front-front/n*n;\n            if(target>matrix[i][j])\n            {\n                if(i+1<m&&!flag[(i+1)*n+j])\n                {\n                    queue.addLast((i+1)*n+j);\n                    flag[(i+1)*n+j]=true;\n                }\n                if(j+1<n&&!flag[i*n+j+1])\n                {\n                    queue.addLast(i*n+j+1);\n                    flag[i*n+j+1]=true;\n                }\n            } else if(target<matrix[i][j])\n            {\n                if(i-1>=0&&!flag[(i-1)*n+j])\n                {\n                    queue.addLast((i-1)*n+j);\n                    flag[(i-1)*n+j]=true;\n                }\n                if(j-1>=0&&!flag[i*n+j-1])\n                {\n                    queue.addLast(i*n+j-1);\n                    flag[i*n+j-1]=true;\n                }\n            } else {\n                return true;\n            }\n            queue.removeFirst();\n        }\n        return false;\n    }\n}\n```\n\n# 思路\n\n- 利用队列数据结构实现广度搜索\n\n- 从中心位置开始广搜，记录已经搜过的点，避免重复搜索\n\n- 比当前值大，往右下搜索，比当前值小，往左上搜索，相等返回true，最终没找到返回false\n","slug":"搜索二维矩阵","published":1,"updated":"2025-02-02T12:22:23.672Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2900213ga834tt86i6","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/search-a-2d-matrix-ii/\">240. 搜索二维矩阵 II</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>\n<ul>\n<li>每行的元素从左到右升序排列。</li>\n<li>每列的元素从上到下升序排列。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br><strong>输出：</strong>true</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20<br><strong>输出：</strong>false</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= n, m &lt;= 300</code></li>\n<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>\n<li>每行的所有元素从左到右升序排列</li>\n<li>每列的所有元素从上到下升序排列</li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">searchMatrix</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> matrix.length;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(m==<span class=\"number\">0</span>||n==<span class=\"number\">0</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">boolean</span>[] flag= <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m*n];</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.addLast((m/<span class=\"number\">2</span>)*n+n/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue.size()&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">front</span> <span class=\"operator\">=</span> queue.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> front/n;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> front-front/n*n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target&gt;matrix[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i+<span class=\"number\">1</span>&lt;m&amp;&amp;!flag[(i+<span class=\"number\">1</span>)*n+j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast((i+<span class=\"number\">1</span>)*n+j);</span><br><span class=\"line\">                    flag[(i+<span class=\"number\">1</span>)*n+j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j+<span class=\"number\">1</span>&lt;n&amp;&amp;!flag[i*n+j+<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast(i*n+j+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    flag[i*n+j+<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target&lt;matrix[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i-<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span>&amp;&amp;!flag[(i-<span class=\"number\">1</span>)*n+j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast((i-<span class=\"number\">1</span>)*n+j);</span><br><span class=\"line\">                    flag[(i-<span class=\"number\">1</span>)*n+j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j-<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span>&amp;&amp;!flag[i*n+j-<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast(i*n+j-<span class=\"number\">1</span>);</span><br><span class=\"line\">                    flag[i*n+j-<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>利用队列数据结构实现广度搜索</p>\n</li>\n<li><p>从中心位置开始广搜，记录已经搜过的点，避免重复搜索</p>\n</li>\n<li><p>比当前值大，往右下搜索，比当前值小，往左上搜索，相等返回true，最终没找到返回false</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/search-a-2d-matrix-ii/\">240. 搜索二维矩阵 II</a></p>\n<p>已解答</p>\n<p>中等</p>\n<p>相关标签</p>\n<p>相关企业</p>\n<p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>\n<ul>\n<li>每行的元素从左到右升序排列。</li>\n<li>每列的元素从上到下升序排列。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br><strong>输出：</strong>true</p>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg\"></p>\n<p><strong>输入：</strong>matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20<br><strong>输出：</strong>false</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= n, m &lt;= 300</code></li>\n<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>\n<li>每行的所有元素从左到右升序排列</li>\n<li>每列的所有元素从上到下升序排列</li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">searchMatrix</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> matrix.length;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(m==<span class=\"number\">0</span>||n==<span class=\"number\">0</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">boolean</span>[] flag= <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m*n];</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.addLast((m/<span class=\"number\">2</span>)*n+n/<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue.size()&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">front</span> <span class=\"operator\">=</span> queue.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> front/n;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> front-front/n*n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target&gt;matrix[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i+<span class=\"number\">1</span>&lt;m&amp;&amp;!flag[(i+<span class=\"number\">1</span>)*n+j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast((i+<span class=\"number\">1</span>)*n+j);</span><br><span class=\"line\">                    flag[(i+<span class=\"number\">1</span>)*n+j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j+<span class=\"number\">1</span>&lt;n&amp;&amp;!flag[i*n+j+<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast(i*n+j+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    flag[i*n+j+<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target&lt;matrix[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i-<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span>&amp;&amp;!flag[(i-<span class=\"number\">1</span>)*n+j])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast((i-<span class=\"number\">1</span>)*n+j);</span><br><span class=\"line\">                    flag[(i-<span class=\"number\">1</span>)*n+j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j-<span class=\"number\">1</span>&gt;=<span class=\"number\">0</span>&amp;&amp;!flag[i*n+j-<span class=\"number\">1</span>])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    queue.addLast(i*n+j-<span class=\"number\">1</span>);</span><br><span class=\"line\">                    flag[i*n+j-<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>利用队列数据结构实现广度搜索</p>\n</li>\n<li><p>从中心位置开始广搜，记录已经搜过的点，避免重复搜索</p>\n</li>\n<li><p>比当前值大，往右下搜索，比当前值小，往左上搜索，相等返回true，最终没找到返回false</p>\n</li>\n</ul>\n"},{"title":"力扣146-LRU缓存","date":"2024-09-10T14:22:11.000Z","_content":"\n# 力扣146.LRU缓存\n\n众所周知**LRU**是一种**缓存淘汰策略**，LRU策略是当一定容量存满时将最不常用的数据淘汰掉（最久没用的数据），如下题，让我们设计一个LRUCache类实现LRU缓存约束的数据结构。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ca33057fa44349dfafd7208f8d01f24f.png)\n因为淘汰的是最久不用的数据，我们可以用java集合提供的LinkedHashMap类帮我们解决。\n\n```java\nclass LRUCache {\n    private int capacity;//容量\n    private LinkedHashMap<Integer,Integer> map;//有序哈希表\n\n\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n        map=new LinkedHashMap<>();\n    }\n\n    public int get(int key) {\n        Integer value=map.get(key);\n        if(value==null)\n        {\n            return -1; \n        }\n        map.putLast(key,value);\n        return value; \n    }\n\n    public void put(int key, int value) {\n        map.putLast(key,value);\n        if(map.size()==capacity+1)\n        {\n            Integer firstKey=map.keySet().iterator().next();\n            map.remove(firstKey);\n        }\n    }\n}\n```\n\n> 当存取数据时，将数据放入LinkedHashMap末尾，则LinkedHashMap的头就是最不常用数据，当容量不够时淘汰\n\n1. 定义容量和LinkedHashMap对象。\n2. 有参构造方法初始化。\n3. get方法：从map中获取key对应value，若为空返回-1，否则将此数据放到LinkedHashMap末尾，表示刷新此数据，返回value。\n4. put方法：先放入map末尾，若容量超了，则淘汰第一个数据。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/75b075f22b3b435da9942480b2a1c1ee.png)\n","source":"_posts/力扣146-LRU缓存.md","raw":"---\ntitle: 力扣146-LRU缓存\ndate: 2024-09-10 22:22:11\ntags: leetcode\ncategories: 算法\n---\n\n# 力扣146.LRU缓存\n\n众所周知**LRU**是一种**缓存淘汰策略**，LRU策略是当一定容量存满时将最不常用的数据淘汰掉（最久没用的数据），如下题，让我们设计一个LRUCache类实现LRU缓存约束的数据结构。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ca33057fa44349dfafd7208f8d01f24f.png)\n因为淘汰的是最久不用的数据，我们可以用java集合提供的LinkedHashMap类帮我们解决。\n\n```java\nclass LRUCache {\n    private int capacity;//容量\n    private LinkedHashMap<Integer,Integer> map;//有序哈希表\n\n\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n        map=new LinkedHashMap<>();\n    }\n\n    public int get(int key) {\n        Integer value=map.get(key);\n        if(value==null)\n        {\n            return -1; \n        }\n        map.putLast(key,value);\n        return value; \n    }\n\n    public void put(int key, int value) {\n        map.putLast(key,value);\n        if(map.size()==capacity+1)\n        {\n            Integer firstKey=map.keySet().iterator().next();\n            map.remove(firstKey);\n        }\n    }\n}\n```\n\n> 当存取数据时，将数据放入LinkedHashMap末尾，则LinkedHashMap的头就是最不常用数据，当容量不够时淘汰\n\n1. 定义容量和LinkedHashMap对象。\n2. 有参构造方法初始化。\n3. get方法：从map中获取key对应value，若为空返回-1，否则将此数据放到LinkedHashMap末尾，表示刷新此数据，返回value。\n4. put方法：先放入map末尾，若容量超了，则淘汰第一个数据。\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/75b075f22b3b435da9942480b2a1c1ee.png)\n","slug":"力扣146-LRU缓存","published":1,"updated":"2024-12-24T14:24:16.135Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2a00253ga8dg5q92bg","content":"<h1 id=\"力扣146-LRU缓存\"><a href=\"#力扣146-LRU缓存\" class=\"headerlink\" title=\"力扣146.LRU缓存\"></a>力扣146.LRU缓存</h1><p>众所周知<strong>LRU</strong>是一种<strong>缓存淘汰策略</strong>，LRU策略是当一定容量存满时将最不常用的数据淘汰掉（最久没用的数据），如下题，让我们设计一个LRUCache类实现LRU缓存约束的数据结构。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/ca33057fa44349dfafd7208f8d01f24f.png\" alt=\"在这里插入图片描述\"><br>因为淘汰的是最久不用的数据，我们可以用java集合提供的LinkedHashMap类帮我们解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capacity;<span class=\"comment\">//容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;Integer,Integer&gt; map;<span class=\"comment\">//有序哈希表</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity=capacity;</span><br><span class=\"line\">        map=<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        Integer value=map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value==<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.putLast(key,value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        map.putLast(key,value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.size()==capacity+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Integer firstKey=map.keySet().iterator().next();</span><br><span class=\"line\">            map.remove(firstKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当存取数据时，将数据放入LinkedHashMap末尾，则LinkedHashMap的头就是最不常用数据，当容量不够时淘汰</p>\n</blockquote>\n<ol>\n<li>定义容量和LinkedHashMap对象。</li>\n<li>有参构造方法初始化。</li>\n<li>get方法：从map中获取key对应value，若为空返回-1，否则将此数据放到LinkedHashMap末尾，表示刷新此数据，返回value。</li>\n<li>put方法：先放入map末尾，若容量超了，则淘汰第一个数据。</li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/75b075f22b3b435da9942480b2a1c1ee.png\" alt=\"在这里插入图片描述\"></p>\n","cover":false,"excerpt":"","more":"<h1 id=\"力扣146-LRU缓存\"><a href=\"#力扣146-LRU缓存\" class=\"headerlink\" title=\"力扣146.LRU缓存\"></a>力扣146.LRU缓存</h1><p>众所周知<strong>LRU</strong>是一种<strong>缓存淘汰策略</strong>，LRU策略是当一定容量存满时将最不常用的数据淘汰掉（最久没用的数据），如下题，让我们设计一个LRUCache类实现LRU缓存约束的数据结构。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/ca33057fa44349dfafd7208f8d01f24f.png\" alt=\"在这里插入图片描述\"><br>因为淘汰的是最久不用的数据，我们可以用java集合提供的LinkedHashMap类帮我们解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capacity;<span class=\"comment\">//容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedHashMap&lt;Integer,Integer&gt; map;<span class=\"comment\">//有序哈希表</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity=capacity;</span><br><span class=\"line\">        map=<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        Integer value=map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value==<span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.putLast(key,value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        map.putLast(key,value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.size()==capacity+<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Integer firstKey=map.keySet().iterator().next();</span><br><span class=\"line\">            map.remove(firstKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当存取数据时，将数据放入LinkedHashMap末尾，则LinkedHashMap的头就是最不常用数据，当容量不够时淘汰</p>\n</blockquote>\n<ol>\n<li>定义容量和LinkedHashMap对象。</li>\n<li>有参构造方法初始化。</li>\n<li>get方法：从map中获取key对应value，若为空返回-1，否则将此数据放到LinkedHashMap末尾，表示刷新此数据，返回value。</li>\n<li>put方法：先放入map末尾，若容量超了，则淘汰第一个数据。</li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/direct/75b075f22b3b435da9942480b2a1c1ee.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"localCache本地缓存项目实现固定大小缓存","date":"2024-12-15T14:37:42.000Z","_content":"\n 为了便于用户使用，我们实现类似于 guava 的引导类。\n\n所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。\n\n```java\npackage com.github.houbb.cache.core.bs;\n\nimport com.github.houbb.cache.api.*;\nimport com.github.houbb.cache.core.core.Cache;\nimport com.github.houbb.cache.core.support.evict.CacheEvicts;\nimport com.github.houbb.cache.core.support.listener.remove.CacheRemoveListeners;\nimport com.github.houbb.cache.core.support.listener.slow.CacheSlowListeners;\nimport com.github.houbb.cache.core.support.load.CacheLoads;\nimport com.github.houbb.cache.core.support.persist.CachePersists;\nimport com.github.houbb.cache.core.support.proxy.CacheProxy;\nimport com.github.houbb.heaven.util.common.ArgUtil;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 缓存引导类\n * @author binbin.hou\n * @since 0.0.2\n */\npublic final class CacheBs<K,V> {\n\n    private CacheBs(){}\n\n    /**\n     * 创建对象实例\n     * @param <K> key\n     * @param <V> value\n     * @return this\n     * @since 0.0.2\n     */\n    public static <K,V> CacheBs<K,V> newInstance() {\n        return new CacheBs<>();\n    }\n\n    /**\n     * map 实现\n     * @since 0.0.2\n     */\n    private Map<K,V> map = new HashMap<>();\n\n    /**\n     * 大小限制\n     * @since 0.0.2\n     */\n    private int size = Integer.MAX_VALUE;\n\n    /**\n     * 驱除策略\n     * @since 0.0.2\n     */\n    private ICacheEvict<K,V> evict = CacheEvicts.fifo();\n\n    /**\n     * 删除监听类\n     * @since 0.0.6\n     */\n    private final List<ICacheRemoveListener<K,V>> removeListeners = CacheRemoveListeners.defaults();\n\n    /**\n     * 慢操作监听类\n     * @since 0.0.9\n     */\n    private final List<ICacheSlowListener> slowListeners = CacheSlowListeners.none();\n\n    /**\n     * 加载策略\n     * @since 0.0.7\n     */\n    private ICacheLoad<K,V> load = CacheLoads.none();\n\n    /**\n     * 持久化实现策略\n     * @since 0.0.8\n     */\n    private ICachePersist<K,V> persist = CachePersists.none();\n\n    /**\n     * map 实现\n     * @param map map\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> map(Map<K, V> map) {\n        ArgUtil.notNull(map, \"map\");\n\n        this.map = map;\n        return this;\n    }\n\n    /**\n     * 设置 size 信息\n     * @param size size\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> size(int size) {\n        ArgUtil.notNegative(size, \"size\");\n\n        this.size = size;\n        return this;\n    }\n\n    /**\n     * 设置驱除策略\n     * @param evict 驱除策略\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> evict(ICacheEvict<K, V> evict) {\n        ArgUtil.notNull(evict, \"evict\");\n\n        this.evict = evict;\n        return this;\n    }\n\n    /**\n     * 设置加载\n     * @param load 加载\n     * @return this\n     * @since 0.0.7\n     */\n    public CacheBs<K, V> load(ICacheLoad<K, V> load) {\n        ArgUtil.notNull(load, \"load\");\n\n        this.load = load;\n        return this;\n    }\n\n    /**\n     * 添加删除监听器\n     * @param removeListener 监听器\n     * @return this\n     * @since 0.0.6\n     */\n    public CacheBs<K, V> addRemoveListener(ICacheRemoveListener<K,V> removeListener) {\n        ArgUtil.notNull(removeListener, \"removeListener\");\n\n        this.removeListeners.add(removeListener);\n        return this;\n    }\n\n    /**\n     * 添加慢日志监听器\n     * @param slowListener 监听器\n     * @return this\n     * @since 0.0.9\n     */\n    public CacheBs<K, V> addSlowListener(ICacheSlowListener slowListener) {\n        ArgUtil.notNull(slowListener, \"slowListener\");\n\n        this.slowListeners.add(slowListener);\n        return this;\n    }\n\n    /**\n     * 设置持久化策略\n     * @param persist 持久化\n     * @return this\n     * @since 0.0.8\n     */\n    public CacheBs<K, V> persist(ICachePersist<K, V> persist) {\n        this.persist = persist;\n        return this;\n    }\n\n    /**\n     * 构建缓存信息\n     * @return 缓存信息\n     * @since 0.0.2\n     */\n    public ICache<K,V> build() {\n        Cache<K,V> cache = new Cache<>();\n        cache.map(map);\n        cache.evict(evict);\n        cache.sizeLimit(size);\n        cache.removeListeners(removeListeners);\n        cache.load(load);\n        cache.persist(persist);\n        cache.slowListeners(slowListeners);\n\n        // 初始化\n        cache.init();\n        return CacheProxy.getProxy(cache);\n    }\n\n}\n\n```\n\n\n\n使用CacheBs类构建Cache对象，并返回Cache对象的代理对象\n\n为了兼容 Map，我们定义缓存接口继承自 Map 接口。\n\n```java\n/**\n * 缓存接口\n * @author binbin.hou\n * @since 0.0.1\n */\npublic interface ICache<K, V> extends Map<K, V> {\n}\n\n```\n\n\n\n由于缓存是设置了固定大小的，所以在存入数据的时候要先尝试进行缓存淘汰，再存入数据\n\n```java\n@Override\npublic V put(K key, V value) {\n    //1.1 尝试驱除\n    CacheEvictContext<K,V> context = new CacheEvictContext<>();\n    context.key(key).size(sizeLimit).cache(this);\n    cacheEvict.evict(context);\n    //2. 判断驱除后的信息\n    if(isSizeLimit()) {\n        throw new CacheRuntimeException(\"当前队列已满，数据添加失败！\");\n    }\n    //3. 执行添加\n    return map.put(key, value);\n}e.add(key);\n    }\n\n}\n```\n\n\n\n在CacheBs构建Cache的时候可以指定淘汰策略\n\n```java\n    /**\n     * 设置驱除策略\n     * @param evict 驱除策略\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> evict(ICacheEvict<K, V> evict) {\n        ArgUtil.notNull(evict, \"evict\");\n\n        this.evict = evict;\n        return this;\n    }\n```\n\n\n\n默认使用fifo先进先出的策略\n\n```java\n    /**\n     * 驱除策略\n     * @since 0.0.2\n     */\n    private ICacheEvict<K,V> evict = CacheEvicts.fifo();\n```\n\n\n\nfifo是先进先出，使用LinkedList做队列，当缓存满了淘汰队头元素，然后将新元素放入队尾，并淘汰掉缓存中的数据\n\n```java\npackage com.github.houbb.cache.core.support.evict;\n\nimport com.github.houbb.cache.api.ICache;\nimport com.github.houbb.cache.api.ICacheEvictContext;\nimport com.github.houbb.cache.core.model.CacheEntry;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * 丢弃策略-先进先出\n * @author binbin.hou\n * @since 0.0.2\n */\npublic class CacheEvictFifo<K,V> extends AbstractCacheEvict<K,V> {\n\n    /**\n     * queue 信息\n     * @since 0.0.2\n     */\n    private final Queue<K> queue = new LinkedList<>();\n\n    @Override\n    public CacheEntry<K,V> doEvict(ICacheEvictContext<K, V> context) {\n        CacheEntry<K,V> result = null;\n\n        final ICache<K,V> cache = context.cache();\n        // 超过限制，执行移除\n        if(cache.size() >= context.size()) {\n            K evictKey = queue.remove();\n            // 移除最开始的元素\n            V evictValue = cache.remove(evictKey);\n            result = new CacheEntry<>(evictKey, evictValue);\n        }\n\n        // 将新加的元素放入队尾\n        final K key = context.key();\n        queue.add(key);\n\n        return result;\n    }\n\n}\n\n```\n","source":"_posts/localCache本地缓存项目实现固定大小缓存.md","raw":"---\ntitle: localCache本地缓存项目实现固定大小缓存\ndate: 2024-12-15 22:37:42\ntags: localCache\ncategories: 项目\n---\n\n 为了便于用户使用，我们实现类似于 guava 的引导类。\n\n所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。\n\n```java\npackage com.github.houbb.cache.core.bs;\n\nimport com.github.houbb.cache.api.*;\nimport com.github.houbb.cache.core.core.Cache;\nimport com.github.houbb.cache.core.support.evict.CacheEvicts;\nimport com.github.houbb.cache.core.support.listener.remove.CacheRemoveListeners;\nimport com.github.houbb.cache.core.support.listener.slow.CacheSlowListeners;\nimport com.github.houbb.cache.core.support.load.CacheLoads;\nimport com.github.houbb.cache.core.support.persist.CachePersists;\nimport com.github.houbb.cache.core.support.proxy.CacheProxy;\nimport com.github.houbb.heaven.util.common.ArgUtil;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 缓存引导类\n * @author binbin.hou\n * @since 0.0.2\n */\npublic final class CacheBs<K,V> {\n\n    private CacheBs(){}\n\n    /**\n     * 创建对象实例\n     * @param <K> key\n     * @param <V> value\n     * @return this\n     * @since 0.0.2\n     */\n    public static <K,V> CacheBs<K,V> newInstance() {\n        return new CacheBs<>();\n    }\n\n    /**\n     * map 实现\n     * @since 0.0.2\n     */\n    private Map<K,V> map = new HashMap<>();\n\n    /**\n     * 大小限制\n     * @since 0.0.2\n     */\n    private int size = Integer.MAX_VALUE;\n\n    /**\n     * 驱除策略\n     * @since 0.0.2\n     */\n    private ICacheEvict<K,V> evict = CacheEvicts.fifo();\n\n    /**\n     * 删除监听类\n     * @since 0.0.6\n     */\n    private final List<ICacheRemoveListener<K,V>> removeListeners = CacheRemoveListeners.defaults();\n\n    /**\n     * 慢操作监听类\n     * @since 0.0.9\n     */\n    private final List<ICacheSlowListener> slowListeners = CacheSlowListeners.none();\n\n    /**\n     * 加载策略\n     * @since 0.0.7\n     */\n    private ICacheLoad<K,V> load = CacheLoads.none();\n\n    /**\n     * 持久化实现策略\n     * @since 0.0.8\n     */\n    private ICachePersist<K,V> persist = CachePersists.none();\n\n    /**\n     * map 实现\n     * @param map map\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> map(Map<K, V> map) {\n        ArgUtil.notNull(map, \"map\");\n\n        this.map = map;\n        return this;\n    }\n\n    /**\n     * 设置 size 信息\n     * @param size size\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> size(int size) {\n        ArgUtil.notNegative(size, \"size\");\n\n        this.size = size;\n        return this;\n    }\n\n    /**\n     * 设置驱除策略\n     * @param evict 驱除策略\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> evict(ICacheEvict<K, V> evict) {\n        ArgUtil.notNull(evict, \"evict\");\n\n        this.evict = evict;\n        return this;\n    }\n\n    /**\n     * 设置加载\n     * @param load 加载\n     * @return this\n     * @since 0.0.7\n     */\n    public CacheBs<K, V> load(ICacheLoad<K, V> load) {\n        ArgUtil.notNull(load, \"load\");\n\n        this.load = load;\n        return this;\n    }\n\n    /**\n     * 添加删除监听器\n     * @param removeListener 监听器\n     * @return this\n     * @since 0.0.6\n     */\n    public CacheBs<K, V> addRemoveListener(ICacheRemoveListener<K,V> removeListener) {\n        ArgUtil.notNull(removeListener, \"removeListener\");\n\n        this.removeListeners.add(removeListener);\n        return this;\n    }\n\n    /**\n     * 添加慢日志监听器\n     * @param slowListener 监听器\n     * @return this\n     * @since 0.0.9\n     */\n    public CacheBs<K, V> addSlowListener(ICacheSlowListener slowListener) {\n        ArgUtil.notNull(slowListener, \"slowListener\");\n\n        this.slowListeners.add(slowListener);\n        return this;\n    }\n\n    /**\n     * 设置持久化策略\n     * @param persist 持久化\n     * @return this\n     * @since 0.0.8\n     */\n    public CacheBs<K, V> persist(ICachePersist<K, V> persist) {\n        this.persist = persist;\n        return this;\n    }\n\n    /**\n     * 构建缓存信息\n     * @return 缓存信息\n     * @since 0.0.2\n     */\n    public ICache<K,V> build() {\n        Cache<K,V> cache = new Cache<>();\n        cache.map(map);\n        cache.evict(evict);\n        cache.sizeLimit(size);\n        cache.removeListeners(removeListeners);\n        cache.load(load);\n        cache.persist(persist);\n        cache.slowListeners(slowListeners);\n\n        // 初始化\n        cache.init();\n        return CacheProxy.getProxy(cache);\n    }\n\n}\n\n```\n\n\n\n使用CacheBs类构建Cache对象，并返回Cache对象的代理对象\n\n为了兼容 Map，我们定义缓存接口继承自 Map 接口。\n\n```java\n/**\n * 缓存接口\n * @author binbin.hou\n * @since 0.0.1\n */\npublic interface ICache<K, V> extends Map<K, V> {\n}\n\n```\n\n\n\n由于缓存是设置了固定大小的，所以在存入数据的时候要先尝试进行缓存淘汰，再存入数据\n\n```java\n@Override\npublic V put(K key, V value) {\n    //1.1 尝试驱除\n    CacheEvictContext<K,V> context = new CacheEvictContext<>();\n    context.key(key).size(sizeLimit).cache(this);\n    cacheEvict.evict(context);\n    //2. 判断驱除后的信息\n    if(isSizeLimit()) {\n        throw new CacheRuntimeException(\"当前队列已满，数据添加失败！\");\n    }\n    //3. 执行添加\n    return map.put(key, value);\n}e.add(key);\n    }\n\n}\n```\n\n\n\n在CacheBs构建Cache的时候可以指定淘汰策略\n\n```java\n    /**\n     * 设置驱除策略\n     * @param evict 驱除策略\n     * @return this\n     * @since 0.0.2\n     */\n    public CacheBs<K, V> evict(ICacheEvict<K, V> evict) {\n        ArgUtil.notNull(evict, \"evict\");\n\n        this.evict = evict;\n        return this;\n    }\n```\n\n\n\n默认使用fifo先进先出的策略\n\n```java\n    /**\n     * 驱除策略\n     * @since 0.0.2\n     */\n    private ICacheEvict<K,V> evict = CacheEvicts.fifo();\n```\n\n\n\nfifo是先进先出，使用LinkedList做队列，当缓存满了淘汰队头元素，然后将新元素放入队尾，并淘汰掉缓存中的数据\n\n```java\npackage com.github.houbb.cache.core.support.evict;\n\nimport com.github.houbb.cache.api.ICache;\nimport com.github.houbb.cache.api.ICacheEvictContext;\nimport com.github.houbb.cache.core.model.CacheEntry;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * 丢弃策略-先进先出\n * @author binbin.hou\n * @since 0.0.2\n */\npublic class CacheEvictFifo<K,V> extends AbstractCacheEvict<K,V> {\n\n    /**\n     * queue 信息\n     * @since 0.0.2\n     */\n    private final Queue<K> queue = new LinkedList<>();\n\n    @Override\n    public CacheEntry<K,V> doEvict(ICacheEvictContext<K, V> context) {\n        CacheEntry<K,V> result = null;\n\n        final ICache<K,V> cache = context.cache();\n        // 超过限制，执行移除\n        if(cache.size() >= context.size()) {\n            K evictKey = queue.remove();\n            // 移除最开始的元素\n            V evictValue = cache.remove(evictKey);\n            result = new CacheEntry<>(evictKey, evictValue);\n        }\n\n        // 将新加的元素放入队尾\n        final K key = context.key();\n        queue.add(key);\n\n        return result;\n    }\n\n}\n\n```\n","slug":"localCache本地缓存项目实现固定大小缓存","published":1,"updated":"2024-12-15T15:14:43.084Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2b00283ga8f1qk718p","content":"<p> 为了便于用户使用，我们实现类似于 guava 的引导类。</p>\n<p>所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.houbb.cache.core.bs;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.core.Cache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.evict.CacheEvicts;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.listener.remove.CacheRemoveListeners;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.listener.slow.CacheSlowListeners;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.load.CacheLoads;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.persist.CachePersists;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.proxy.CacheProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.heaven.util.common.ArgUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存引导类</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheBs</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">CacheBs</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建对象实例</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;K&gt; key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;V&gt; value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K,V&gt; CacheBs&lt;K,V&gt; <span class=\"title function_\">newInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CacheBs</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * map 实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;K,V&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 大小限制</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除监听类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.6</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ICacheRemoveListener&lt;K,V&gt;&gt; removeListeners = CacheRemoveListeners.defaults();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 慢操作监听类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.9</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ICacheSlowListener&gt; slowListeners = CacheSlowListeners.none();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ICacheLoad&lt;K,V&gt; load = CacheLoads.none();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 持久化实现策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ICachePersist&lt;K,V&gt; persist = CachePersists.none();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * map 实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map map</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">map</span><span class=\"params\">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(map, <span class=\"string\">&quot;map&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.map = map;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置 size 信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> size size</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">size</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNegative(size, <span class=\"string\">&quot;size&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置驱除策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evict 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">evict</span><span class=\"params\">(ICacheEvict&lt;K, V&gt; evict)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(evict, <span class=\"string\">&quot;evict&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.evict = evict;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置加载</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> load 加载</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">load</span><span class=\"params\">(ICacheLoad&lt;K, V&gt; load)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(load, <span class=\"string\">&quot;load&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.load = load;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加删除监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> removeListener 监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.6</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">addRemoveListener</span><span class=\"params\">(ICacheRemoveListener&lt;K,V&gt; removeListener)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(removeListener, <span class=\"string\">&quot;removeListener&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.removeListeners.add(removeListener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加慢日志监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> slowListener 监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.9</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">addSlowListener</span><span class=\"params\">(ICacheSlowListener slowListener)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(slowListener, <span class=\"string\">&quot;slowListener&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.slowListeners.add(slowListener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置持久化策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> persist 持久化</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">persist</span><span class=\"params\">(ICachePersist&lt;K, V&gt; persist)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.persist = persist;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构建缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ICache&lt;K,V&gt; <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Cache&lt;K,V&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">Cache</span>&lt;&gt;();</span><br><span class=\"line\">        cache.map(map);</span><br><span class=\"line\">        cache.evict(evict);</span><br><span class=\"line\">        cache.sizeLimit(size);</span><br><span class=\"line\">        cache.removeListeners(removeListeners);</span><br><span class=\"line\">        cache.load(load);</span><br><span class=\"line\">        cache.persist(persist);</span><br><span class=\"line\">        cache.slowListeners(slowListeners);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        cache.init();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CacheProxy.getProxy(cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用CacheBs类构建Cache对象，并返回Cache对象的代理对象</p>\n<p>为了兼容 Map，我们定义缓存接口继承自 Map 接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存接口</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Map</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>由于缓存是设置了固定大小的，所以在存入数据的时候要先尝试进行缓存淘汰，再存入数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.1 尝试驱除</span></span><br><span class=\"line\">    CacheEvictContext&lt;K,V&gt; context = <span class=\"keyword\">new</span> <span class=\"title class_\">CacheEvictContext</span>&lt;&gt;();</span><br><span class=\"line\">    context.key(key).size(sizeLimit).cache(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    cacheEvict.evict(context);</span><br><span class=\"line\">    <span class=\"comment\">//2. 判断驱除后的信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isSizeLimit()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CacheRuntimeException</span>(<span class=\"string\">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3. 执行添加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(key, value);</span><br><span class=\"line\">&#125;e.add(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在CacheBs构建Cache的时候可以指定淘汰策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置驱除策略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">evict</span><span class=\"params\">(ICacheEvict&lt;K, V&gt; evict)</span> &#123;</span><br><span class=\"line\">    ArgUtil.notNull(evict, <span class=\"string\">&quot;evict&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.evict = evict;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认使用fifo先进先出的策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>fifo是先进先出，使用LinkedList做队列，当缓存满了淘汰队头元素，然后将新元素放入队尾，并淘汰掉缓存中的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.houbb.cache.core.support.evict;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheEvictContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.model.CacheEntry;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 丢弃策略-先进先出</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheEvictFifo</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractCacheEvict</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * queue 信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Queue&lt;K&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheEntry&lt;K,V&gt; <span class=\"title function_\">doEvict</span><span class=\"params\">(ICacheEvictContext&lt;K, V&gt; context)</span> &#123;</span><br><span class=\"line\">        CacheEntry&lt;K,V&gt; result = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class=\"line\">        <span class=\"comment\">// 超过限制，执行移除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class=\"line\">            <span class=\"type\">K</span> <span class=\"variable\">evictKey</span> <span class=\"operator\">=</span> queue.remove();</span><br><span class=\"line\">            <span class=\"comment\">// 移除最开始的元素</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">evictValue</span> <span class=\"operator\">=</span> cache.remove(evictKey);</span><br><span class=\"line\">            result = <span class=\"keyword\">new</span> <span class=\"title class_\">CacheEntry</span>&lt;&gt;(evictKey, evictValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将新加的元素放入队尾</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> context.key();</span><br><span class=\"line\">        queue.add(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","cover":false,"excerpt":"","more":"<p> 为了便于用户使用，我们实现类似于 guava 的引导类。</p>\n<p>所有参数都提供默认值，使用 fluent 流式写法，提升用户体验。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.houbb.cache.core.bs;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.core.Cache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.evict.CacheEvicts;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.listener.remove.CacheRemoveListeners;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.listener.slow.CacheSlowListeners;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.load.CacheLoads;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.persist.CachePersists;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.support.proxy.CacheProxy;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.heaven.util.common.ArgUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存引导类</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheBs</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">CacheBs</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建对象实例</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;K&gt; key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;V&gt; value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K,V&gt; CacheBs&lt;K,V&gt; <span class=\"title function_\">newInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CacheBs</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * map 实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;K,V&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 大小限制</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除监听类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.6</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ICacheRemoveListener&lt;K,V&gt;&gt; removeListeners = CacheRemoveListeners.defaults();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 慢操作监听类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.9</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ICacheSlowListener&gt; slowListeners = CacheSlowListeners.none();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ICacheLoad&lt;K,V&gt; load = CacheLoads.none();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 持久化实现策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ICachePersist&lt;K,V&gt; persist = CachePersists.none();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * map 实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map map</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">map</span><span class=\"params\">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(map, <span class=\"string\">&quot;map&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.map = map;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置 size 信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> size size</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">size</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNegative(size, <span class=\"string\">&quot;size&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置驱除策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evict 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">evict</span><span class=\"params\">(ICacheEvict&lt;K, V&gt; evict)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(evict, <span class=\"string\">&quot;evict&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.evict = evict;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置加载</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> load 加载</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">load</span><span class=\"params\">(ICacheLoad&lt;K, V&gt; load)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(load, <span class=\"string\">&quot;load&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.load = load;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加删除监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> removeListener 监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.6</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">addRemoveListener</span><span class=\"params\">(ICacheRemoveListener&lt;K,V&gt; removeListener)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(removeListener, <span class=\"string\">&quot;removeListener&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.removeListeners.add(removeListener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加慢日志监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> slowListener 监听器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.9</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">addSlowListener</span><span class=\"params\">(ICacheSlowListener slowListener)</span> &#123;</span><br><span class=\"line\">        ArgUtil.notNull(slowListener, <span class=\"string\">&quot;slowListener&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.slowListeners.add(slowListener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置持久化策略</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> persist 持久化</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.8</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">persist</span><span class=\"params\">(ICachePersist&lt;K, V&gt; persist)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.persist = persist;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构建缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 缓存信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ICache&lt;K,V&gt; <span class=\"title function_\">build</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Cache&lt;K,V&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">Cache</span>&lt;&gt;();</span><br><span class=\"line\">        cache.map(map);</span><br><span class=\"line\">        cache.evict(evict);</span><br><span class=\"line\">        cache.sizeLimit(size);</span><br><span class=\"line\">        cache.removeListeners(removeListeners);</span><br><span class=\"line\">        cache.load(load);</span><br><span class=\"line\">        cache.persist(persist);</span><br><span class=\"line\">        cache.slowListeners(slowListeners);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        cache.init();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CacheProxy.getProxy(cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用CacheBs类构建Cache对象，并返回Cache对象的代理对象</p>\n<p>为了兼容 Map，我们定义缓存接口继承自 Map 接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存接口</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICache</span>&lt;K, V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Map</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>由于缓存是设置了固定大小的，所以在存入数据的时候要先尝试进行缓存淘汰，再存入数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.1 尝试驱除</span></span><br><span class=\"line\">    CacheEvictContext&lt;K,V&gt; context = <span class=\"keyword\">new</span> <span class=\"title class_\">CacheEvictContext</span>&lt;&gt;();</span><br><span class=\"line\">    context.key(key).size(sizeLimit).cache(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    cacheEvict.evict(context);</span><br><span class=\"line\">    <span class=\"comment\">//2. 判断驱除后的信息</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isSizeLimit()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CacheRuntimeException</span>(<span class=\"string\">&quot;当前队列已满，数据添加失败！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3. 执行添加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(key, value);</span><br><span class=\"line\">&#125;e.add(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在CacheBs构建Cache的时候可以指定淘汰策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置驱除策略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> this</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CacheBs&lt;K, V&gt; <span class=\"title function_\">evict</span><span class=\"params\">(ICacheEvict&lt;K, V&gt; evict)</span> &#123;</span><br><span class=\"line\">    ArgUtil.notNull(evict, <span class=\"string\">&quot;evict&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.evict = evict;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认使用fifo先进先出的策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 驱除策略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ICacheEvict&lt;K,V&gt; evict = CacheEvicts.fifo();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>fifo是先进先出，使用LinkedList做队列，当缓存满了淘汰队头元素，然后将新元素放入队尾，并淘汰掉缓存中的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.houbb.cache.core.support.evict;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICache;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.api.ICacheEvictContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.houbb.cache.core.model.CacheEntry;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 丢弃策略-先进先出</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> binbin.hou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheEvictFifo</span>&lt;K,V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractCacheEvict</span>&lt;K,V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * queue 信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 0.0.2</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Queue&lt;K&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheEntry&lt;K,V&gt; <span class=\"title function_\">doEvict</span><span class=\"params\">(ICacheEvictContext&lt;K, V&gt; context)</span> &#123;</span><br><span class=\"line\">        CacheEntry&lt;K,V&gt; result = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ICache&lt;K,V&gt; cache = context.cache();</span><br><span class=\"line\">        <span class=\"comment\">// 超过限制，执行移除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cache.size() &gt;= context.size()) &#123;</span><br><span class=\"line\">            <span class=\"type\">K</span> <span class=\"variable\">evictKey</span> <span class=\"operator\">=</span> queue.remove();</span><br><span class=\"line\">            <span class=\"comment\">// 移除最开始的元素</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">evictValue</span> <span class=\"operator\">=</span> cache.remove(evictKey);</span><br><span class=\"line\">            result = <span class=\"keyword\">new</span> <span class=\"title class_\">CacheEntry</span>&lt;&gt;(evictKey, evictValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将新加的元素放入队尾</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">K</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> context.key();</span><br><span class=\"line\">        queue.add(key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"最大子数组和","date":"2025-01-06T15:46:31.000Z","_content":"\n# 题目\n\n给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**子数组**\n\n是数组中的一个连续部分。\n\n**示例 1：**\n\n**输入**：nums = [-2,1,-3,4,-1,2,1,-5,4]\n**输出**：6\n**解释**：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n**示例 2：**\n\n**输入**：nums = [1]\n**输出**：1\n\n**示例 3：**\n\n**输入**：nums = [5,4,-1,7,8]\n**输出**：23\n\n\n\n---\n\n# 题解\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int[] maxSum=new int[nums.length];\n        maxSum[0]=nums[0];\n        int max=nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            maxSum[i]=maxSum[i-1]>0?nums[i]+maxSum[i-1]:nums[i];\n            max=max>maxSum[i]?max:maxSum[i];\n        }\n        return max;\n    }\n}\n```\n\n\n\n# 思路\n\n使用dp动态规划，定义一个dp数组记录到i号元素的最大和，那么到i+1号元素的最大和取决于到i号元素的最大和，如果到i号元素最大和>0,那么到i+1号元素的最大和等于元素值加到i号元素的最大和，否则为元素值。最后得出所有最大和的最大值。\n","source":"_posts/最大子数组和.md","raw":"---\ntitle: 最大子数组和\ndate: 2025-01-06 23:46:31\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**子数组**\n\n是数组中的一个连续部分。\n\n**示例 1：**\n\n**输入**：nums = [-2,1,-3,4,-1,2,1,-5,4]\n**输出**：6\n**解释**：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n**示例 2：**\n\n**输入**：nums = [1]\n**输出**：1\n\n**示例 3：**\n\n**输入**：nums = [5,4,-1,7,8]\n**输出**：23\n\n\n\n---\n\n# 题解\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int[] maxSum=new int[nums.length];\n        maxSum[0]=nums[0];\n        int max=nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            maxSum[i]=maxSum[i-1]>0?nums[i]+maxSum[i-1]:nums[i];\n            max=max>maxSum[i]?max:maxSum[i];\n        }\n        return max;\n    }\n}\n```\n\n\n\n# 思路\n\n使用dp动态规划，定义一个dp数组记录到i号元素的最大和，那么到i+1号元素的最大和取决于到i号元素的最大和，如果到i号元素最大和>0,那么到i+1号元素的最大和等于元素值加到i号元素的最大和，否则为元素值。最后得出所有最大和的最大值。\n","slug":"最大子数组和","published":1,"updated":"2025-01-06T15:55:11.750Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2b002c3ga8f9trfd3q","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>子数组</strong></p>\n<p>是数组中的一个连续部分。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br><strong>输出</strong>：6<br><strong>解释</strong>：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [1]<br><strong>输出</strong>：1</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [5,4,-1,7,8]<br><strong>输出</strong>：23</p>\n<hr>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] maxSum=<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        maxSum[<span class=\"number\">0</span>]=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> max=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            maxSum[i]=maxSum[i-<span class=\"number\">1</span>]&gt;<span class=\"number\">0</span>?nums[i]+maxSum[i-<span class=\"number\">1</span>]:nums[i];</span><br><span class=\"line\">            max=max&gt;maxSum[i]?max:maxSum[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>使用dp动态规划，定义一个dp数组记录到i号元素的最大和，那么到i+1号元素的最大和取决于到i号元素的最大和，如果到i号元素最大和&gt;0,那么到i+1号元素的最大和等于元素值加到i号元素的最大和，否则为元素值。最后得出所有最大和的最大值。</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>子数组</strong></p>\n<p>是数组中的一个连续部分。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br><strong>输出</strong>：6<br><strong>解释</strong>：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [1]<br><strong>输出</strong>：1</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入</strong>：nums &#x3D; [5,4,-1,7,8]<br><strong>输出</strong>：23</p>\n<hr>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] maxSum=<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        maxSum[<span class=\"number\">0</span>]=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> max=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            maxSum[i]=maxSum[i-<span class=\"number\">1</span>]&gt;<span class=\"number\">0</span>?nums[i]+maxSum[i-<span class=\"number\">1</span>]:nums[i];</span><br><span class=\"line\">            max=max&gt;maxSum[i]?max:maxSum[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>使用dp动态规划，定义一个dp数组记录到i号元素的最大和，那么到i+1号元素的最大和取决于到i号元素的最大和，如果到i号元素最大和&gt;0,那么到i+1号元素的最大和等于元素值加到i号元素的最大和，否则为元素值。最后得出所有最大和的最大值。</p>\n"},{"title":"杭州实在智能java实习面经","date":"2024-09-14T14:27:22.000Z","_content":"\n# 杭州实在智能java实习面经\n\n`题目比较简单，大概记得的题：`\n\n1. 自我介绍\n\n2. java三大特性\n\n3. 多态是怎么表现的\n\n4. 重载和重写的区别\n\n5. 问了几种情况是否为重载\n\n6. springboot自动装配原理\n\n7. 如何检测链表是否有环\n\n8. 如何设计一个管理系统，表结构\n\n9. 用过map吗\n\n10. hashmap是否线程安全\n\n11. hashmap线程不安全具体体现\n\n12. 什么map是线程安全的\n\n13. hashtable与hashmap的区别\n\n14. if else 太多怎么优化\n\n15. 用枚举怎么实现\n\n16. 反问\n","source":"_posts/杭州实在智能java实习面经.md","raw":"---\ntitle: 杭州实在智能java实习面经\ndate: 2024-09-14 22:27:22\ntags: 实在智能\ncategories: 面经\n---\n\n# 杭州实在智能java实习面经\n\n`题目比较简单，大概记得的题：`\n\n1. 自我介绍\n\n2. java三大特性\n\n3. 多态是怎么表现的\n\n4. 重载和重写的区别\n\n5. 问了几种情况是否为重载\n\n6. springboot自动装配原理\n\n7. 如何检测链表是否有环\n\n8. 如何设计一个管理系统，表结构\n\n9. 用过map吗\n\n10. hashmap是否线程安全\n\n11. hashmap线程不安全具体体现\n\n12. 什么map是线程安全的\n\n13. hashtable与hashmap的区别\n\n14. if else 太多怎么优化\n\n15. 用枚举怎么实现\n\n16. 反问\n","slug":"杭州实在智能java实习面经","published":1,"updated":"2024-12-24T14:28:43.793Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2c002f3ga89hrjckdl","content":"<h1 id=\"杭州实在智能java实习面经\"><a href=\"#杭州实在智能java实习面经\" class=\"headerlink\" title=\"杭州实在智能java实习面经\"></a>杭州实在智能java实习面经</h1><p><code>题目比较简单，大概记得的题：</code></p>\n<ol>\n<li><p>自我介绍</p>\n</li>\n<li><p>java三大特性</p>\n</li>\n<li><p>多态是怎么表现的</p>\n</li>\n<li><p>重载和重写的区别</p>\n</li>\n<li><p>问了几种情况是否为重载</p>\n</li>\n<li><p>springboot自动装配原理</p>\n</li>\n<li><p>如何检测链表是否有环</p>\n</li>\n<li><p>如何设计一个管理系统，表结构</p>\n</li>\n<li><p>用过map吗</p>\n</li>\n<li><p>hashmap是否线程安全</p>\n</li>\n<li><p>hashmap线程不安全具体体现</p>\n</li>\n<li><p>什么map是线程安全的</p>\n</li>\n<li><p>hashtable与hashmap的区别</p>\n</li>\n<li><p>if else 太多怎么优化</p>\n</li>\n<li><p>用枚举怎么实现</p>\n</li>\n<li><p>反问</p>\n</li>\n</ol>\n","cover":false,"excerpt":"","more":"<h1 id=\"杭州实在智能java实习面经\"><a href=\"#杭州实在智能java实习面经\" class=\"headerlink\" title=\"杭州实在智能java实习面经\"></a>杭州实在智能java实习面经</h1><p><code>题目比较简单，大概记得的题：</code></p>\n<ol>\n<li><p>自我介绍</p>\n</li>\n<li><p>java三大特性</p>\n</li>\n<li><p>多态是怎么表现的</p>\n</li>\n<li><p>重载和重写的区别</p>\n</li>\n<li><p>问了几种情况是否为重载</p>\n</li>\n<li><p>springboot自动装配原理</p>\n</li>\n<li><p>如何检测链表是否有环</p>\n</li>\n<li><p>如何设计一个管理系统，表结构</p>\n</li>\n<li><p>用过map吗</p>\n</li>\n<li><p>hashmap是否线程安全</p>\n</li>\n<li><p>hashmap线程不安全具体体现</p>\n</li>\n<li><p>什么map是线程安全的</p>\n</li>\n<li><p>hashtable与hashmap的区别</p>\n</li>\n<li><p>if else 太多怎么优化</p>\n</li>\n<li><p>用枚举怎么实现</p>\n</li>\n<li><p>反问</p>\n</li>\n</ol>\n"},{"title":"面试题收集","date":"2025-01-09T14:22:31.000Z","_content":"\n1. **对Java的反射如何理解？** Java的反射机制允许在运行时动态地加载、探测、操作类和对象的属性和方法。通过反射，程序可以在运行时检查类的构造方法、成员变量和方法，甚至可以修改它们的值，调用方法。反射是Java的一种强大功能，支持动态对象操作，常用于框架设计、代码生成、依赖注入等场景。\n\n2. **反射机制对于其他没有反射的语言有什么好处？** 反射机制的主要好处是使得程序在运行时具有灵活性，可以动态地加载类、检查类的结构并在运行时操作对象的字段和方法。这种灵活性对于框架和库的设计非常重要，因为它允许程序在不事先知道具体类的情况下操作对象。例如，Java的Spring框架利用反射实现了依赖注入、AOP等特性，而不需要在编译时确定对象类型。\n\n3. **在Java中哪些效率高的功能是基于反射做的呢？**\n   \n   - **动态代理**：Java的`Proxy`类和`InvocationHandler`接口使用反射机制实现动态代理，使得可以在运行时动态创建代理对象，处理方法调用。\n   - **依赖注入（DI）**：在Spring框架中，反射被用来动态地注入依赖。\n   - **ORM框架**：如Hibernate、MyBatis，使用反射来映射数据库表和对象之间的关系。\n   - **序列化与反序列化**：Java的`Serializable`接口和`ObjectInputStream`/`ObjectOutputStream`的反序列化机制也依赖于反射。\n\n4. **volatile 关键字作用** `volatile`关键字确保变量的值对所有线程都是可见的。它告诉JVM，每当一个线程更新变量的值时，其他线程能够立刻看到这个变化。它避免了线程间的缓存一致性问题。\n\n5. **不加这个关键字对变量修改就不会加到主存吗？加了volatile** 如果没有加`volatile`关键字，线程在修改变量时可能会将修改存储在本地缓存中，而不会立刻写回到主内存，这就会导致其他线程看不到更新的值。加了`volatile`后，确保变量的值在每个线程中都是实时可见的，修改会直接反映到主内存。\n\n6. **加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？** `volatile`不能代替加锁，它仅仅保证变量在多线程中的可见性，但不保证原子性。对于需要保证原子性、多个操作的同步控制，还是需要使用锁（如`ReentrantLock`、`synchronized`）。`volatile`适用于状态标志位、简单计数器等简单场景。\n\n7. **假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口，怎么实现的大概说一下**\n   \n   - **变量**：\n     - 核心线程数、最大线程数、队列容量、线程池的状态（如是否关闭）。\n   - **接口**：\n     - `execute(Runnable task)`：提交任务。\n     - `shutdown()`：关闭线程池。\n     - `submit(Callable<T> task)`：提交返回结果的任务。\n     - `getActiveCount()`：获取当前活动线程数。\n   - **实现**：可以通过`ExecutorService`接口来实现线程池，使用`ThreadPoolExecutor`实现，结合阻塞队列（如`LinkedBlockingQueue`）来缓存任务，设置核心线程数和最大线程数来动态调整线程池的大小。\n\n8. **线程数量已经有了，任务超过了线程数量，怎么进行调度呢？比如核心线程数量是5，最大线程是10，现在来了11个任务** 当任务超过线程池的核心线程数时，线程池会将任务放入队列等待执行。如果队列也满了，线程池会创建新的线程来执行任务，直到最大线程数为止。如果达到最大线程数且队列已满，可以使用拒绝策略（如`AbortPolicy`、`CallerRunsPolicy`等）来处理。\n\n9. **如何去定位慢SQL和优化呢**\n   \n   - **定位慢SQL**：开启数据库的慢查询日志，分析查询执行的时间，或者通过数据库监控工具（如MySQL的`EXPLAIN`语句）来分析SQL的执行计划。\n   - **优化**：通过添加索引、重写查询、减少数据库连接数、优化表结构、避免不必要的全表扫描等手段来提升SQL性能。\n\n10. **数据库更新了一些异常数据，如何对异常的修改进行回退？比如清空了一段的一些值** 可以通过事务回滚来实现数据回退。在执行更新操作之前，通过事务确保一系列操作的一致性。如果操作中发现异常，可以调用`rollback()`回滚事务，恢复数据的原始状态。\n\n11. **SQL题:班级表和成绩表，统计这次考试每个班成绩总和的排序**\n\nsql\n\n复制代码\n\n`SELECT class_id, SUM(score) AS total_score FROM score_table GROUP BY class_id ORDER BY total_score DESC;`\n\n12. **内连接和外连接有什么区别**\n- **内连接（INNER JOIN）**：返回两个表中符合连接条件的记录。如果某一方没有匹配的记录，则该记录不会出现在结果集中。\n\n- **外连接（OUTER JOIN）**：返回满足连接条件的记录，如果一方没有匹配的记录，则返回另一方的记录，并使用`NULL`填充缺失的部分。外连接分为左外连接、右外连接和全外连接。\n13. **介绍一下IOC概念？有什么好处呢？** **IOC（Inversion of Control）**，控制反转，指的是将对象的创建和管理交给框架来完成，而不是在代码中手动创建和管理。它通过依赖注入（DI）实现，让程序的控制逻辑交给容器。好处是解耦、提高可维护性、便于单元测试。\n\n14. **利用kafka如何保证消息的顺序呢？** Kafka通过分区来保证消息的顺序。在一个分区内的消息会按照发送顺序保持一致，消费者会按照分区的顺序读取消息。如果需要全局顺序，则需要保证所有消息都发送到同一个分区。\n\n15. **针对IM项目，问了场景:一个群有1000个人，1000个人同时发消息，会发生消息风暴，如何处理呢？** 可以采用分布式消息队列（如Kafka、RabbitMQ等）来缓解消息风暴，采用消息异步消费、消息压缩等策略。同时可以设计消息去重、限流、批量发送等方式来处理高并发消息。\n\n16. **海量数据找前10个最大？数组做堆排序如何做？**\n- **堆排序**：通过构建最大堆，逐步移除最大元素，直到剩下前10个元素。\n\n- **时间复杂度**：堆排序的时间复杂度是`O(n log n)`，适合处理海量数据。\n17. **对于一个整数数组4455133，只有一个数字有1个，其他都是2个，并且相同的数是相邻的，如何找出只有一个的那个数的位置？时间复杂度log n** 可以利用二分查找。由于数字是相邻的，且其他数字成对出现，唯一的数字不成对，可以通过二分法找到唯一的数字的位置。\n\n18. **mysql数据库的默认隔离级别？会不会导致幻读**\n    \n    - MySQL 的默认隔离级别：\n    \n    在 MySQL 中，默认的事务隔离级别是 **`REPEATABLE READ`（可重复读）**。\n    \n     `REPEATABLE READ` 是否会导致幻读？\n    \n    - 什么是幻读？\n    \n    幻读指的是在一个事务中，某次查询后，另一次查询又看到了“幻影行”。也就是说，**同一个查询条件第一次没有匹配到的数据，第二次却匹配到了，似乎多出了一些行**。这通常是由于其他事务插入了符合条件的行所导致。\n\n19. **nacos的openfeign远程调用是通过http协议吗**\n- **OpenFeign 的本质**\n  \n  - OpenFeign 是基于 HTTP 协议的声明式 HTTP 客户端。它将 HTTP 请求封装成 Java 接口，调用接口方法时，会通过底层的 HTTP 客户端（如 Apache HttpClient 或 OkHttp）发送请求。\n  - Feign 的核心功能是简化服务间基于 HTTP 的调用。\n\n- **HTTP 协议作为通信方式**\n  \n  - 在 OpenFeign 中，每个接口方法映射为一个 HTTP 请求，方法的注解（如 `@GetMapping`、`@PostMapping`）定义了具体的 HTTP 方法和请求路径。\n20. \n","source":"_posts/面试题收集.md","raw":"---\ntitle: 面试题收集\ndate: 2025-01-09 22:22:31\ntags: 面试\ncategories: 面试题\n---\n\n1. **对Java的反射如何理解？** Java的反射机制允许在运行时动态地加载、探测、操作类和对象的属性和方法。通过反射，程序可以在运行时检查类的构造方法、成员变量和方法，甚至可以修改它们的值，调用方法。反射是Java的一种强大功能，支持动态对象操作，常用于框架设计、代码生成、依赖注入等场景。\n\n2. **反射机制对于其他没有反射的语言有什么好处？** 反射机制的主要好处是使得程序在运行时具有灵活性，可以动态地加载类、检查类的结构并在运行时操作对象的字段和方法。这种灵活性对于框架和库的设计非常重要，因为它允许程序在不事先知道具体类的情况下操作对象。例如，Java的Spring框架利用反射实现了依赖注入、AOP等特性，而不需要在编译时确定对象类型。\n\n3. **在Java中哪些效率高的功能是基于反射做的呢？**\n   \n   - **动态代理**：Java的`Proxy`类和`InvocationHandler`接口使用反射机制实现动态代理，使得可以在运行时动态创建代理对象，处理方法调用。\n   - **依赖注入（DI）**：在Spring框架中，反射被用来动态地注入依赖。\n   - **ORM框架**：如Hibernate、MyBatis，使用反射来映射数据库表和对象之间的关系。\n   - **序列化与反序列化**：Java的`Serializable`接口和`ObjectInputStream`/`ObjectOutputStream`的反序列化机制也依赖于反射。\n\n4. **volatile 关键字作用** `volatile`关键字确保变量的值对所有线程都是可见的。它告诉JVM，每当一个线程更新变量的值时，其他线程能够立刻看到这个变化。它避免了线程间的缓存一致性问题。\n\n5. **不加这个关键字对变量修改就不会加到主存吗？加了volatile** 如果没有加`volatile`关键字，线程在修改变量时可能会将修改存储在本地缓存中，而不会立刻写回到主内存，这就会导致其他线程看不到更新的值。加了`volatile`后，确保变量的值在每个线程中都是实时可见的，修改会直接反映到主内存。\n\n6. **加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？** `volatile`不能代替加锁，它仅仅保证变量在多线程中的可见性，但不保证原子性。对于需要保证原子性、多个操作的同步控制，还是需要使用锁（如`ReentrantLock`、`synchronized`）。`volatile`适用于状态标志位、简单计数器等简单场景。\n\n7. **假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口，怎么实现的大概说一下**\n   \n   - **变量**：\n     - 核心线程数、最大线程数、队列容量、线程池的状态（如是否关闭）。\n   - **接口**：\n     - `execute(Runnable task)`：提交任务。\n     - `shutdown()`：关闭线程池。\n     - `submit(Callable<T> task)`：提交返回结果的任务。\n     - `getActiveCount()`：获取当前活动线程数。\n   - **实现**：可以通过`ExecutorService`接口来实现线程池，使用`ThreadPoolExecutor`实现，结合阻塞队列（如`LinkedBlockingQueue`）来缓存任务，设置核心线程数和最大线程数来动态调整线程池的大小。\n\n8. **线程数量已经有了，任务超过了线程数量，怎么进行调度呢？比如核心线程数量是5，最大线程是10，现在来了11个任务** 当任务超过线程池的核心线程数时，线程池会将任务放入队列等待执行。如果队列也满了，线程池会创建新的线程来执行任务，直到最大线程数为止。如果达到最大线程数且队列已满，可以使用拒绝策略（如`AbortPolicy`、`CallerRunsPolicy`等）来处理。\n\n9. **如何去定位慢SQL和优化呢**\n   \n   - **定位慢SQL**：开启数据库的慢查询日志，分析查询执行的时间，或者通过数据库监控工具（如MySQL的`EXPLAIN`语句）来分析SQL的执行计划。\n   - **优化**：通过添加索引、重写查询、减少数据库连接数、优化表结构、避免不必要的全表扫描等手段来提升SQL性能。\n\n10. **数据库更新了一些异常数据，如何对异常的修改进行回退？比如清空了一段的一些值** 可以通过事务回滚来实现数据回退。在执行更新操作之前，通过事务确保一系列操作的一致性。如果操作中发现异常，可以调用`rollback()`回滚事务，恢复数据的原始状态。\n\n11. **SQL题:班级表和成绩表，统计这次考试每个班成绩总和的排序**\n\nsql\n\n复制代码\n\n`SELECT class_id, SUM(score) AS total_score FROM score_table GROUP BY class_id ORDER BY total_score DESC;`\n\n12. **内连接和外连接有什么区别**\n- **内连接（INNER JOIN）**：返回两个表中符合连接条件的记录。如果某一方没有匹配的记录，则该记录不会出现在结果集中。\n\n- **外连接（OUTER JOIN）**：返回满足连接条件的记录，如果一方没有匹配的记录，则返回另一方的记录，并使用`NULL`填充缺失的部分。外连接分为左外连接、右外连接和全外连接。\n13. **介绍一下IOC概念？有什么好处呢？** **IOC（Inversion of Control）**，控制反转，指的是将对象的创建和管理交给框架来完成，而不是在代码中手动创建和管理。它通过依赖注入（DI）实现，让程序的控制逻辑交给容器。好处是解耦、提高可维护性、便于单元测试。\n\n14. **利用kafka如何保证消息的顺序呢？** Kafka通过分区来保证消息的顺序。在一个分区内的消息会按照发送顺序保持一致，消费者会按照分区的顺序读取消息。如果需要全局顺序，则需要保证所有消息都发送到同一个分区。\n\n15. **针对IM项目，问了场景:一个群有1000个人，1000个人同时发消息，会发生消息风暴，如何处理呢？** 可以采用分布式消息队列（如Kafka、RabbitMQ等）来缓解消息风暴，采用消息异步消费、消息压缩等策略。同时可以设计消息去重、限流、批量发送等方式来处理高并发消息。\n\n16. **海量数据找前10个最大？数组做堆排序如何做？**\n- **堆排序**：通过构建最大堆，逐步移除最大元素，直到剩下前10个元素。\n\n- **时间复杂度**：堆排序的时间复杂度是`O(n log n)`，适合处理海量数据。\n17. **对于一个整数数组4455133，只有一个数字有1个，其他都是2个，并且相同的数是相邻的，如何找出只有一个的那个数的位置？时间复杂度log n** 可以利用二分查找。由于数字是相邻的，且其他数字成对出现，唯一的数字不成对，可以通过二分法找到唯一的数字的位置。\n\n18. **mysql数据库的默认隔离级别？会不会导致幻读**\n    \n    - MySQL 的默认隔离级别：\n    \n    在 MySQL 中，默认的事务隔离级别是 **`REPEATABLE READ`（可重复读）**。\n    \n     `REPEATABLE READ` 是否会导致幻读？\n    \n    - 什么是幻读？\n    \n    幻读指的是在一个事务中，某次查询后，另一次查询又看到了“幻影行”。也就是说，**同一个查询条件第一次没有匹配到的数据，第二次却匹配到了，似乎多出了一些行**。这通常是由于其他事务插入了符合条件的行所导致。\n\n19. **nacos的openfeign远程调用是通过http协议吗**\n- **OpenFeign 的本质**\n  \n  - OpenFeign 是基于 HTTP 协议的声明式 HTTP 客户端。它将 HTTP 请求封装成 Java 接口，调用接口方法时，会通过底层的 HTTP 客户端（如 Apache HttpClient 或 OkHttp）发送请求。\n  - Feign 的核心功能是简化服务间基于 HTTP 的调用。\n\n- **HTTP 协议作为通信方式**\n  \n  - 在 OpenFeign 中，每个接口方法映射为一个 HTTP 请求，方法的注解（如 `@GetMapping`、`@PostMapping`）定义了具体的 HTTP 方法和请求路径。\n20. \n","slug":"面试题收集","published":1,"updated":"2025-01-14T08:01:49.231Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2c002i3ga88to46vn3","content":"<ol>\n<li><p><strong>对Java的反射如何理解？</strong> Java的反射机制允许在运行时动态地加载、探测、操作类和对象的属性和方法。通过反射，程序可以在运行时检查类的构造方法、成员变量和方法，甚至可以修改它们的值，调用方法。反射是Java的一种强大功能，支持动态对象操作，常用于框架设计、代码生成、依赖注入等场景。</p>\n</li>\n<li><p><strong>反射机制对于其他没有反射的语言有什么好处？</strong> 反射机制的主要好处是使得程序在运行时具有灵活性，可以动态地加载类、检查类的结构并在运行时操作对象的字段和方法。这种灵活性对于框架和库的设计非常重要，因为它允许程序在不事先知道具体类的情况下操作对象。例如，Java的Spring框架利用反射实现了依赖注入、AOP等特性，而不需要在编译时确定对象类型。</p>\n</li>\n<li><p><strong>在Java中哪些效率高的功能是基于反射做的呢？</strong></p>\n<ul>\n<li><strong>动态代理</strong>：Java的<code>Proxy</code>类和<code>InvocationHandler</code>接口使用反射机制实现动态代理，使得可以在运行时动态创建代理对象，处理方法调用。</li>\n<li><strong>依赖注入（DI）</strong>：在Spring框架中，反射被用来动态地注入依赖。</li>\n<li><strong>ORM框架</strong>：如Hibernate、MyBatis，使用反射来映射数据库表和对象之间的关系。</li>\n<li><strong>序列化与反序列化</strong>：Java的<code>Serializable</code>接口和<code>ObjectInputStream</code>&#x2F;<code>ObjectOutputStream</code>的反序列化机制也依赖于反射。</li>\n</ul>\n</li>\n<li><p><strong>volatile 关键字作用</strong> <code>volatile</code>关键字确保变量的值对所有线程都是可见的。它告诉JVM，每当一个线程更新变量的值时，其他线程能够立刻看到这个变化。它避免了线程间的缓存一致性问题。</p>\n</li>\n<li><p><strong>不加这个关键字对变量修改就不会加到主存吗？加了volatile</strong> 如果没有加<code>volatile</code>关键字，线程在修改变量时可能会将修改存储在本地缓存中，而不会立刻写回到主内存，这就会导致其他线程看不到更新的值。加了<code>volatile</code>后，确保变量的值在每个线程中都是实时可见的，修改会直接反映到主内存。</p>\n</li>\n<li><p><strong>加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？</strong> <code>volatile</code>不能代替加锁，它仅仅保证变量在多线程中的可见性，但不保证原子性。对于需要保证原子性、多个操作的同步控制，还是需要使用锁（如<code>ReentrantLock</code>、<code>synchronized</code>）。<code>volatile</code>适用于状态标志位、简单计数器等简单场景。</p>\n</li>\n<li><p><strong>假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口，怎么实现的大概说一下</strong></p>\n<ul>\n<li><strong>变量</strong>：<ul>\n<li>核心线程数、最大线程数、队列容量、线程池的状态（如是否关闭）。</li>\n</ul>\n</li>\n<li><strong>接口</strong>：<ul>\n<li><code>execute(Runnable task)</code>：提交任务。</li>\n<li><code>shutdown()</code>：关闭线程池。</li>\n<li><code>submit(Callable&lt;T&gt; task)</code>：提交返回结果的任务。</li>\n<li><code>getActiveCount()</code>：获取当前活动线程数。</li>\n</ul>\n</li>\n<li><strong>实现</strong>：可以通过<code>ExecutorService</code>接口来实现线程池，使用<code>ThreadPoolExecutor</code>实现，结合阻塞队列（如<code>LinkedBlockingQueue</code>）来缓存任务，设置核心线程数和最大线程数来动态调整线程池的大小。</li>\n</ul>\n</li>\n<li><p><strong>线程数量已经有了，任务超过了线程数量，怎么进行调度呢？比如核心线程数量是5，最大线程是10，现在来了11个任务</strong> 当任务超过线程池的核心线程数时，线程池会将任务放入队列等待执行。如果队列也满了，线程池会创建新的线程来执行任务，直到最大线程数为止。如果达到最大线程数且队列已满，可以使用拒绝策略（如<code>AbortPolicy</code>、<code>CallerRunsPolicy</code>等）来处理。</p>\n</li>\n<li><p><strong>如何去定位慢SQL和优化呢</strong></p>\n<ul>\n<li><strong>定位慢SQL</strong>：开启数据库的慢查询日志，分析查询执行的时间，或者通过数据库监控工具（如MySQL的<code>EXPLAIN</code>语句）来分析SQL的执行计划。</li>\n<li><strong>优化</strong>：通过添加索引、重写查询、减少数据库连接数、优化表结构、避免不必要的全表扫描等手段来提升SQL性能。</li>\n</ul>\n</li>\n<li><p><strong>数据库更新了一些异常数据，如何对异常的修改进行回退？比如清空了一段的一些值</strong> 可以通过事务回滚来实现数据回退。在执行更新操作之前，通过事务确保一系列操作的一致性。如果操作中发现异常，可以调用<code>rollback()</code>回滚事务，恢复数据的原始状态。</p>\n</li>\n<li><p><strong>SQL题:班级表和成绩表，统计这次考试每个班成绩总和的排序</strong></p>\n</li>\n</ol>\n<p>sql</p>\n<p>复制代码</p>\n<p><code>SELECT class_id, SUM(score) AS total_score FROM score_table GROUP BY class_id ORDER BY total_score DESC;</code></p>\n<ol start=\"12\">\n<li><strong>内连接和外连接有什么区别</strong></li>\n</ol>\n<ul>\n<li><p><strong>内连接（INNER JOIN）</strong>：返回两个表中符合连接条件的记录。如果某一方没有匹配的记录，则该记录不会出现在结果集中。</p>\n</li>\n<li><p><strong>外连接（OUTER JOIN）</strong>：返回满足连接条件的记录，如果一方没有匹配的记录，则返回另一方的记录，并使用<code>NULL</code>填充缺失的部分。外连接分为左外连接、右外连接和全外连接。</p>\n</li>\n</ul>\n<ol start=\"13\">\n<li><p><strong>介绍一下IOC概念？有什么好处呢？</strong> <strong>IOC（Inversion of Control）</strong>，控制反转，指的是将对象的创建和管理交给框架来完成，而不是在代码中手动创建和管理。它通过依赖注入（DI）实现，让程序的控制逻辑交给容器。好处是解耦、提高可维护性、便于单元测试。</p>\n</li>\n<li><p><strong>利用kafka如何保证消息的顺序呢？</strong> Kafka通过分区来保证消息的顺序。在一个分区内的消息会按照发送顺序保持一致，消费者会按照分区的顺序读取消息。如果需要全局顺序，则需要保证所有消息都发送到同一个分区。</p>\n</li>\n<li><p><strong>针对IM项目，问了场景:一个群有1000个人，1000个人同时发消息，会发生消息风暴，如何处理呢？</strong> 可以采用分布式消息队列（如Kafka、RabbitMQ等）来缓解消息风暴，采用消息异步消费、消息压缩等策略。同时可以设计消息去重、限流、批量发送等方式来处理高并发消息。</p>\n</li>\n<li><p><strong>海量数据找前10个最大？数组做堆排序如何做？</strong></p>\n</li>\n</ol>\n<ul>\n<li><p><strong>堆排序</strong>：通过构建最大堆，逐步移除最大元素，直到剩下前10个元素。</p>\n</li>\n<li><p><strong>时间复杂度</strong>：堆排序的时间复杂度是<code>O(n log n)</code>，适合处理海量数据。</p>\n</li>\n</ul>\n<ol start=\"17\">\n<li><p><strong>对于一个整数数组4455133，只有一个数字有1个，其他都是2个，并且相同的数是相邻的，如何找出只有一个的那个数的位置？时间复杂度log n</strong> 可以利用二分查找。由于数字是相邻的，且其他数字成对出现，唯一的数字不成对，可以通过二分法找到唯一的数字的位置。</p>\n</li>\n<li><p><strong>mysql数据库的默认隔离级别？会不会导致幻读</strong></p>\n<ul>\n<li>MySQL 的默认隔离级别：</li>\n</ul>\n<p>在 MySQL 中，默认的事务隔离级别是 <strong><code>REPEATABLE READ</code>（可重复读）</strong>。</p>\n<p> <code>REPEATABLE READ</code> 是否会导致幻读？</p>\n<ul>\n<li>什么是幻读？</li>\n</ul>\n<p>幻读指的是在一个事务中，某次查询后，另一次查询又看到了“幻影行”。也就是说，<strong>同一个查询条件第一次没有匹配到的数据，第二次却匹配到了，似乎多出了一些行</strong>。这通常是由于其他事务插入了符合条件的行所导致。</p>\n</li>\n<li><p><strong>nacos的openfeign远程调用是通过http协议吗</strong></p>\n</li>\n</ol>\n<ul>\n<li><p><strong>OpenFeign 的本质</strong></p>\n<ul>\n<li>OpenFeign 是基于 HTTP 协议的声明式 HTTP 客户端。它将 HTTP 请求封装成 Java 接口，调用接口方法时，会通过底层的 HTTP 客户端（如 Apache HttpClient 或 OkHttp）发送请求。</li>\n<li>Feign 的核心功能是简化服务间基于 HTTP 的调用。</li>\n</ul>\n</li>\n<li><p><strong>HTTP 协议作为通信方式</strong></p>\n<ul>\n<li>在 OpenFeign 中，每个接口方法映射为一个 HTTP 请求，方法的注解（如 <code>@GetMapping</code>、<code>@PostMapping</code>）定义了具体的 HTTP 方法和请求路径。</li>\n</ul>\n</li>\n</ul>\n<p>20. </p>\n","cover":false,"excerpt":"","more":"<ol>\n<li><p><strong>对Java的反射如何理解？</strong> Java的反射机制允许在运行时动态地加载、探测、操作类和对象的属性和方法。通过反射，程序可以在运行时检查类的构造方法、成员变量和方法，甚至可以修改它们的值，调用方法。反射是Java的一种强大功能，支持动态对象操作，常用于框架设计、代码生成、依赖注入等场景。</p>\n</li>\n<li><p><strong>反射机制对于其他没有反射的语言有什么好处？</strong> 反射机制的主要好处是使得程序在运行时具有灵活性，可以动态地加载类、检查类的结构并在运行时操作对象的字段和方法。这种灵活性对于框架和库的设计非常重要，因为它允许程序在不事先知道具体类的情况下操作对象。例如，Java的Spring框架利用反射实现了依赖注入、AOP等特性，而不需要在编译时确定对象类型。</p>\n</li>\n<li><p><strong>在Java中哪些效率高的功能是基于反射做的呢？</strong></p>\n<ul>\n<li><strong>动态代理</strong>：Java的<code>Proxy</code>类和<code>InvocationHandler</code>接口使用反射机制实现动态代理，使得可以在运行时动态创建代理对象，处理方法调用。</li>\n<li><strong>依赖注入（DI）</strong>：在Spring框架中，反射被用来动态地注入依赖。</li>\n<li><strong>ORM框架</strong>：如Hibernate、MyBatis，使用反射来映射数据库表和对象之间的关系。</li>\n<li><strong>序列化与反序列化</strong>：Java的<code>Serializable</code>接口和<code>ObjectInputStream</code>&#x2F;<code>ObjectOutputStream</code>的反序列化机制也依赖于反射。</li>\n</ul>\n</li>\n<li><p><strong>volatile 关键字作用</strong> <code>volatile</code>关键字确保变量的值对所有线程都是可见的。它告诉JVM，每当一个线程更新变量的值时，其他线程能够立刻看到这个变化。它避免了线程间的缓存一致性问题。</p>\n</li>\n<li><p><strong>不加这个关键字对变量修改就不会加到主存吗？加了volatile</strong> 如果没有加<code>volatile</code>关键字，线程在修改变量时可能会将修改存储在本地缓存中，而不会立刻写回到主内存，这就会导致其他线程看不到更新的值。加了<code>volatile</code>后，确保变量的值在每个线程中都是实时可见的，修改会直接反映到主内存。</p>\n</li>\n<li><p><strong>加了这个关键字还需要加锁吗？这个关键字的一些应用场景都有哪些呢？</strong> <code>volatile</code>不能代替加锁，它仅仅保证变量在多线程中的可见性，但不保证原子性。对于需要保证原子性、多个操作的同步控制，还是需要使用锁（如<code>ReentrantLock</code>、<code>synchronized</code>）。<code>volatile</code>适用于状态标志位、简单计数器等简单场景。</p>\n</li>\n<li><p><strong>假设让你写一个线程池工具，你觉得应该怎么去设计呢？应该有什么变量？有什么接口，怎么实现的大概说一下</strong></p>\n<ul>\n<li><strong>变量</strong>：<ul>\n<li>核心线程数、最大线程数、队列容量、线程池的状态（如是否关闭）。</li>\n</ul>\n</li>\n<li><strong>接口</strong>：<ul>\n<li><code>execute(Runnable task)</code>：提交任务。</li>\n<li><code>shutdown()</code>：关闭线程池。</li>\n<li><code>submit(Callable&lt;T&gt; task)</code>：提交返回结果的任务。</li>\n<li><code>getActiveCount()</code>：获取当前活动线程数。</li>\n</ul>\n</li>\n<li><strong>实现</strong>：可以通过<code>ExecutorService</code>接口来实现线程池，使用<code>ThreadPoolExecutor</code>实现，结合阻塞队列（如<code>LinkedBlockingQueue</code>）来缓存任务，设置核心线程数和最大线程数来动态调整线程池的大小。</li>\n</ul>\n</li>\n<li><p><strong>线程数量已经有了，任务超过了线程数量，怎么进行调度呢？比如核心线程数量是5，最大线程是10，现在来了11个任务</strong> 当任务超过线程池的核心线程数时，线程池会将任务放入队列等待执行。如果队列也满了，线程池会创建新的线程来执行任务，直到最大线程数为止。如果达到最大线程数且队列已满，可以使用拒绝策略（如<code>AbortPolicy</code>、<code>CallerRunsPolicy</code>等）来处理。</p>\n</li>\n<li><p><strong>如何去定位慢SQL和优化呢</strong></p>\n<ul>\n<li><strong>定位慢SQL</strong>：开启数据库的慢查询日志，分析查询执行的时间，或者通过数据库监控工具（如MySQL的<code>EXPLAIN</code>语句）来分析SQL的执行计划。</li>\n<li><strong>优化</strong>：通过添加索引、重写查询、减少数据库连接数、优化表结构、避免不必要的全表扫描等手段来提升SQL性能。</li>\n</ul>\n</li>\n<li><p><strong>数据库更新了一些异常数据，如何对异常的修改进行回退？比如清空了一段的一些值</strong> 可以通过事务回滚来实现数据回退。在执行更新操作之前，通过事务确保一系列操作的一致性。如果操作中发现异常，可以调用<code>rollback()</code>回滚事务，恢复数据的原始状态。</p>\n</li>\n<li><p><strong>SQL题:班级表和成绩表，统计这次考试每个班成绩总和的排序</strong></p>\n</li>\n</ol>\n<p>sql</p>\n<p>复制代码</p>\n<p><code>SELECT class_id, SUM(score) AS total_score FROM score_table GROUP BY class_id ORDER BY total_score DESC;</code></p>\n<ol start=\"12\">\n<li><strong>内连接和外连接有什么区别</strong></li>\n</ol>\n<ul>\n<li><p><strong>内连接（INNER JOIN）</strong>：返回两个表中符合连接条件的记录。如果某一方没有匹配的记录，则该记录不会出现在结果集中。</p>\n</li>\n<li><p><strong>外连接（OUTER JOIN）</strong>：返回满足连接条件的记录，如果一方没有匹配的记录，则返回另一方的记录，并使用<code>NULL</code>填充缺失的部分。外连接分为左外连接、右外连接和全外连接。</p>\n</li>\n</ul>\n<ol start=\"13\">\n<li><p><strong>介绍一下IOC概念？有什么好处呢？</strong> <strong>IOC（Inversion of Control）</strong>，控制反转，指的是将对象的创建和管理交给框架来完成，而不是在代码中手动创建和管理。它通过依赖注入（DI）实现，让程序的控制逻辑交给容器。好处是解耦、提高可维护性、便于单元测试。</p>\n</li>\n<li><p><strong>利用kafka如何保证消息的顺序呢？</strong> Kafka通过分区来保证消息的顺序。在一个分区内的消息会按照发送顺序保持一致，消费者会按照分区的顺序读取消息。如果需要全局顺序，则需要保证所有消息都发送到同一个分区。</p>\n</li>\n<li><p><strong>针对IM项目，问了场景:一个群有1000个人，1000个人同时发消息，会发生消息风暴，如何处理呢？</strong> 可以采用分布式消息队列（如Kafka、RabbitMQ等）来缓解消息风暴，采用消息异步消费、消息压缩等策略。同时可以设计消息去重、限流、批量发送等方式来处理高并发消息。</p>\n</li>\n<li><p><strong>海量数据找前10个最大？数组做堆排序如何做？</strong></p>\n</li>\n</ol>\n<ul>\n<li><p><strong>堆排序</strong>：通过构建最大堆，逐步移除最大元素，直到剩下前10个元素。</p>\n</li>\n<li><p><strong>时间复杂度</strong>：堆排序的时间复杂度是<code>O(n log n)</code>，适合处理海量数据。</p>\n</li>\n</ul>\n<ol start=\"17\">\n<li><p><strong>对于一个整数数组4455133，只有一个数字有1个，其他都是2个，并且相同的数是相邻的，如何找出只有一个的那个数的位置？时间复杂度log n</strong> 可以利用二分查找。由于数字是相邻的，且其他数字成对出现，唯一的数字不成对，可以通过二分法找到唯一的数字的位置。</p>\n</li>\n<li><p><strong>mysql数据库的默认隔离级别？会不会导致幻读</strong></p>\n<ul>\n<li>MySQL 的默认隔离级别：</li>\n</ul>\n<p>在 MySQL 中，默认的事务隔离级别是 <strong><code>REPEATABLE READ</code>（可重复读）</strong>。</p>\n<p> <code>REPEATABLE READ</code> 是否会导致幻读？</p>\n<ul>\n<li>什么是幻读？</li>\n</ul>\n<p>幻读指的是在一个事务中，某次查询后，另一次查询又看到了“幻影行”。也就是说，<strong>同一个查询条件第一次没有匹配到的数据，第二次却匹配到了，似乎多出了一些行</strong>。这通常是由于其他事务插入了符合条件的行所导致。</p>\n</li>\n<li><p><strong>nacos的openfeign远程调用是通过http协议吗</strong></p>\n</li>\n</ol>\n<ul>\n<li><p><strong>OpenFeign 的本质</strong></p>\n<ul>\n<li>OpenFeign 是基于 HTTP 协议的声明式 HTTP 客户端。它将 HTTP 请求封装成 Java 接口，调用接口方法时，会通过底层的 HTTP 客户端（如 Apache HttpClient 或 OkHttp）发送请求。</li>\n<li>Feign 的核心功能是简化服务间基于 HTTP 的调用。</li>\n</ul>\n</li>\n<li><p><strong>HTTP 协议作为通信方式</strong></p>\n<ul>\n<li>在 OpenFeign 中，每个接口方法映射为一个 HTTP 请求，方法的注解（如 <code>@GetMapping</code>、<code>@PostMapping</code>）定义了具体的 HTTP 方法和请求路径。</li>\n</ul>\n</li>\n</ul>\n<p>20. </p>\n"},{"layout":"11","title":"盛最多水的容器","date":"2025-01-07T10:25:18.000Z","_content":"\n# 题目\n\n给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n\n找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n**说明**：你不能倾斜容器。\n\n**示例 1：**\n\n![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)\n\n**输入：**[1,8,6,2,5,4,8,3,7]\n**输出**：49 \n**解释：**图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n**示例 2：**\n\n**输入**：height = [1,1]\n**输出**：1\n\n**提示：**\n\n- `n == height.length`\n- `2 <= n <= 105`\n- `0 <= height[i] <= 104`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int max =(height.length-1)*Math.min(height[0],height[height.length-1]);\n        int i=0;\n        int j=height.length-1;\n        while(i<j)\n        {\n            while(height[i]<=height[j]&&i<j)\n            {\n                max=Math.max(max,height[i]*(j-i));\n                i++;\n            }\n            while(height[i]>=height[j]&&i<j)\n            {\n                max=Math.max(max,height[j]*(j-i));\n                j--;\n            }\n        }\n        return max;\n    }\n}\n```\n\n\n\n# 思路\n\n- 双指针，定义两个指针i,j。\n\n- i初始指向第一个元素，j初始指向最后一个元素。\n\n- 因为需要面积最大，高取决于短的那条边，所以短的边越长面积越大。\n\n- 由于指针向中间移动时底边变小，所以要在移动过程中记录最大值。我们定义一个循环，当i的高度小于j的高度时i向右移动，否则j向左移动，在移动过程中更新面积最大值，最后的答案即为面积最大值。\n","source":"_posts/盛最多水的容器.md","raw":"---\nlayout: 11\ntitle: 盛最多水的容器\ndate: 2025-01-07 18:25:18\ntags: leetcode\ncategories: 算法\n---\n\n# 题目\n\n给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n\n找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n**说明**：你不能倾斜容器。\n\n**示例 1：**\n\n![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)\n\n**输入：**[1,8,6,2,5,4,8,3,7]\n**输出**：49 \n**解释：**图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n**示例 2：**\n\n**输入**：height = [1,1]\n**输出**：1\n\n**提示：**\n\n- `n == height.length`\n- `2 <= n <= 105`\n- `0 <= height[i] <= 104`\n\n\n\n# 题解\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int max =(height.length-1)*Math.min(height[0],height[height.length-1]);\n        int i=0;\n        int j=height.length-1;\n        while(i<j)\n        {\n            while(height[i]<=height[j]&&i<j)\n            {\n                max=Math.max(max,height[i]*(j-i));\n                i++;\n            }\n            while(height[i]>=height[j]&&i<j)\n            {\n                max=Math.max(max,height[j]*(j-i));\n                j--;\n            }\n        }\n        return max;\n    }\n}\n```\n\n\n\n# 思路\n\n- 双指针，定义两个指针i,j。\n\n- i初始指向第一个元素，j初始指向最后一个元素。\n\n- 因为需要面积最大，高取决于短的那条边，所以短的边越长面积越大。\n\n- 由于指针向中间移动时底边变小，所以要在移动过程中记录最大值。我们定义一个循环，当i的高度小于j的高度时i向右移动，否则j向左移动，在移动过程中更新面积最大值，最后的答案即为面积最大值。\n","slug":"盛最多水的容器","published":1,"updated":"2025-01-07T10:34:22.352Z","comments":1,"photos":[],"_id":"cm6q6pd2g002n3ga8hpgx657u","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>\n<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>\n<p>返回容器可以储存的最大水量。</p>\n<p><strong>说明</strong>：你不能倾斜容器。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg\"></p>\n<p><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]<br><strong>输出</strong>：49<br><strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入</strong>：height &#x3D; [1,1]<br><strong>输出</strong>：1</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>2 &lt;= n &lt;= 105</code></li>\n<li><code>0 &lt;= height[i] &lt;= 104</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxArea</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span>(height.length-<span class=\"number\">1</span>)*Math.min(height[<span class=\"number\">0</span>],height[height.length-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=height.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(height[i]&lt;=height[j]&amp;&amp;i&lt;j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max=Math.max(max,height[i]*(j-i));</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(height[i]&gt;=height[j]&amp;&amp;i&lt;j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max=Math.max(max,height[j]*(j-i));</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>双指针，定义两个指针i,j。</p>\n</li>\n<li><p>i初始指向第一个元素，j初始指向最后一个元素。</p>\n</li>\n<li><p>因为需要面积最大，高取决于短的那条边，所以短的边越长面积越大。</p>\n</li>\n<li><p>由于指针向中间移动时底边变小，所以要在移动过程中记录最大值。我们定义一个循环，当i的高度小于j的高度时i向右移动，否则j向左移动，在移动过程中更新面积最大值，最后的答案即为面积最大值。</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>\n<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>\n<p>返回容器可以储存的最大水量。</p>\n<p><strong>说明</strong>：你不能倾斜容器。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg\"></p>\n<p><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]<br><strong>输出</strong>：49<br><strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入</strong>：height &#x3D; [1,1]<br><strong>输出</strong>：1</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == height.length</code></li>\n<li><code>2 &lt;= n &lt;= 105</code></li>\n<li><code>0 &lt;= height[i] &lt;= 104</code></li>\n</ul>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxArea</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span>(height.length-<span class=\"number\">1</span>)*Math.min(height[<span class=\"number\">0</span>],height[height.length-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=height.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(height[i]&lt;=height[j]&amp;&amp;i&lt;j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max=Math.max(max,height[i]*(j-i));</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(height[i]&gt;=height[j]&amp;&amp;i&lt;j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max=Math.max(max,height[j]*(j-i));</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><ul>\n<li><p>双指针，定义两个指针i,j。</p>\n</li>\n<li><p>i初始指向第一个元素，j初始指向最后一个元素。</p>\n</li>\n<li><p>因为需要面积最大，高取决于短的那条边，所以短的边越长面积越大。</p>\n</li>\n<li><p>由于指针向中间移动时底边变小，所以要在移动过程中记录最大值。我们定义一个循环，当i的高度小于j的高度时i向右移动，否则j向左移动，在移动过程中更新面积最大值，最后的答案即为面积最大值。</p>\n</li>\n</ul>\n"},{"title":"用线程池执行批量耗时任务的优点","date":"2024-11-21T03:08:35.000Z","_content":"\n使用线程池执行批量耗时任务的优点主要体现在以下几个方面：\n\n---\n\n### 1. **线程复用，节约资源**\n\n线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  \n\n- **优点**：  \n  - 减少系统资源的占用（如 CPU 和内存）。  \n  - 降低频繁创建线程带来的开销和延迟。  \n\n例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。\n\n---\n\n### 2. **控制并发数量，防止资源耗尽**\n\n线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  \n\n- **优点**：  \n  - 避免任务数过多导致的线程竞争和阻塞问题。  \n  - 提高系统的稳定性，防止线程爆炸。\n\n例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。\n\n---\n\n### 3. **简化任务管理**\n\n线程池提供了统一的接口用于提交和管理任务。  \n\n- **优点**：  \n  - 可以轻松管理任务的执行、取消、超时等操作。  \n  - 使用线程池调度任务时，无需手动管理线程的生命周期。\n\n例如：`ThreadPoolExecutor` 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。\n\n---\n\n### 4. **支持任务队列，实现任务分批处理**\n\n线程池内部使用任务队列存储待执行的任务。  \n\n- **优点**：  \n  - 可以实现任务的分批处理，适应大批量任务执行需求。  \n  - 支持灵活的队列类型（如 `LinkedBlockingQueue`, `ArrayBlockingQueue`）。\n\n例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。\n\n---\n\n### 5. **提供灵活的线程管理策略**\n\n线程池允许配置不同的线程数量和策略：  \n\n- **优点**：  \n  - 设置核心线程数、最大线程数，适应不同负载需求。  \n  - 支持定时任务、周期性任务等多种调度模式。\n\n例如：使用 `ScheduledThreadPoolExecutor` 可以定时调度任务，而 `CachedThreadPool` 适用于大量短期任务。\n\n---\n\n### 6. **提高任务处理效率**\n\n线程池允许多任务并发执行，充分利用 CPU 多核资源。  \n\n- **优点**：  \n  - 任务可以并行处理，缩短总的执行时间。  \n  - 对于 I/O 密集型任务，可以避免阻塞操作浪费 CPU 时间。\n\n例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。\n\n---\n\n### 7. **支持自定义线程工厂，增强可监控性**\n\n通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  \n\n- **优点**：  \n  - 线程的命名规则便于调试和定位问题。  \n  - 可定制线程池的行为（如异常处理、自定义日志记录等）。\n\n---\n\n### 8. **减少程序的复杂度**\n\n线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  \n\n- **优点**：  \n  - 简化代码，提高可维护性。  \n  - 避免手动管理线程带来的复杂性。\n\n例如：直接提交任务给线程池，而无需手动启动或管理线程。\n\n---\n\n### **总结**\n\n使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于**高效利用系统资源**和**便捷的任务管理**，是处理大规模并发任务的最佳实践之一。\n","source":"_posts/用线程池执行批量耗时任务的优点.md","raw":"---\ntitle: 用线程池执行批量耗时任务的优点\ndate: 2024-11-21 11:08:35\ntags: java基础\ncategories: 八股文\n---\n\n使用线程池执行批量耗时任务的优点主要体现在以下几个方面：\n\n---\n\n### 1. **线程复用，节约资源**\n\n线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  \n\n- **优点**：  \n  - 减少系统资源的占用（如 CPU 和内存）。  \n  - 降低频繁创建线程带来的开销和延迟。  \n\n例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。\n\n---\n\n### 2. **控制并发数量，防止资源耗尽**\n\n线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  \n\n- **优点**：  \n  - 避免任务数过多导致的线程竞争和阻塞问题。  \n  - 提高系统的稳定性，防止线程爆炸。\n\n例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。\n\n---\n\n### 3. **简化任务管理**\n\n线程池提供了统一的接口用于提交和管理任务。  \n\n- **优点**：  \n  - 可以轻松管理任务的执行、取消、超时等操作。  \n  - 使用线程池调度任务时，无需手动管理线程的生命周期。\n\n例如：`ThreadPoolExecutor` 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。\n\n---\n\n### 4. **支持任务队列，实现任务分批处理**\n\n线程池内部使用任务队列存储待执行的任务。  \n\n- **优点**：  \n  - 可以实现任务的分批处理，适应大批量任务执行需求。  \n  - 支持灵活的队列类型（如 `LinkedBlockingQueue`, `ArrayBlockingQueue`）。\n\n例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。\n\n---\n\n### 5. **提供灵活的线程管理策略**\n\n线程池允许配置不同的线程数量和策略：  \n\n- **优点**：  \n  - 设置核心线程数、最大线程数，适应不同负载需求。  \n  - 支持定时任务、周期性任务等多种调度模式。\n\n例如：使用 `ScheduledThreadPoolExecutor` 可以定时调度任务，而 `CachedThreadPool` 适用于大量短期任务。\n\n---\n\n### 6. **提高任务处理效率**\n\n线程池允许多任务并发执行，充分利用 CPU 多核资源。  \n\n- **优点**：  \n  - 任务可以并行处理，缩短总的执行时间。  \n  - 对于 I/O 密集型任务，可以避免阻塞操作浪费 CPU 时间。\n\n例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。\n\n---\n\n### 7. **支持自定义线程工厂，增强可监控性**\n\n通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  \n\n- **优点**：  \n  - 线程的命名规则便于调试和定位问题。  \n  - 可定制线程池的行为（如异常处理、自定义日志记录等）。\n\n---\n\n### 8. **减少程序的复杂度**\n\n线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  \n\n- **优点**：  \n  - 简化代码，提高可维护性。  \n  - 避免手动管理线程带来的复杂性。\n\n例如：直接提交任务给线程池，而无需手动启动或管理线程。\n\n---\n\n### **总结**\n\n使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于**高效利用系统资源**和**便捷的任务管理**，是处理大规模并发任务的最佳实践之一。\n","slug":"用线程池执行批量耗时任务的优点","published":1,"updated":"2024-12-14T09:16:59.572Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2h002q3ga8ebpk61me","content":"<p>使用线程池执行批量耗时任务的优点主要体现在以下几个方面：</p>\n<hr>\n<h3 id=\"1-线程复用，节约资源\"><a href=\"#1-线程复用，节约资源\" class=\"headerlink\" title=\"1. 线程复用，节约资源\"></a>1. <strong>线程复用，节约资源</strong></h3><p>线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>减少系统资源的占用（如 CPU 和内存）。  </li>\n<li>降低频繁创建线程带来的开销和延迟。</li>\n</ul>\n</li>\n</ul>\n<p>例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。</p>\n<hr>\n<h3 id=\"2-控制并发数量，防止资源耗尽\"><a href=\"#2-控制并发数量，防止资源耗尽\" class=\"headerlink\" title=\"2. 控制并发数量，防止资源耗尽\"></a>2. <strong>控制并发数量，防止资源耗尽</strong></h3><p>线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>避免任务数过多导致的线程竞争和阻塞问题。  </li>\n<li>提高系统的稳定性，防止线程爆炸。</li>\n</ul>\n</li>\n</ul>\n<p>例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。</p>\n<hr>\n<h3 id=\"3-简化任务管理\"><a href=\"#3-简化任务管理\" class=\"headerlink\" title=\"3. 简化任务管理\"></a>3. <strong>简化任务管理</strong></h3><p>线程池提供了统一的接口用于提交和管理任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以轻松管理任务的执行、取消、超时等操作。  </li>\n<li>使用线程池调度任务时，无需手动管理线程的生命周期。</li>\n</ul>\n</li>\n</ul>\n<p>例如：<code>ThreadPoolExecutor</code> 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。</p>\n<hr>\n<h3 id=\"4-支持任务队列，实现任务分批处理\"><a href=\"#4-支持任务队列，实现任务分批处理\" class=\"headerlink\" title=\"4. 支持任务队列，实现任务分批处理\"></a>4. <strong>支持任务队列，实现任务分批处理</strong></h3><p>线程池内部使用任务队列存储待执行的任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以实现任务的分批处理，适应大批量任务执行需求。  </li>\n<li>支持灵活的队列类型（如 <code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code>）。</li>\n</ul>\n</li>\n</ul>\n<p>例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。</p>\n<hr>\n<h3 id=\"5-提供灵活的线程管理策略\"><a href=\"#5-提供灵活的线程管理策略\" class=\"headerlink\" title=\"5. 提供灵活的线程管理策略\"></a>5. <strong>提供灵活的线程管理策略</strong></h3><p>线程池允许配置不同的线程数量和策略：  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>设置核心线程数、最大线程数，适应不同负载需求。  </li>\n<li>支持定时任务、周期性任务等多种调度模式。</li>\n</ul>\n</li>\n</ul>\n<p>例如：使用 <code>ScheduledThreadPoolExecutor</code> 可以定时调度任务，而 <code>CachedThreadPool</code> 适用于大量短期任务。</p>\n<hr>\n<h3 id=\"6-提高任务处理效率\"><a href=\"#6-提高任务处理效率\" class=\"headerlink\" title=\"6. 提高任务处理效率\"></a>6. <strong>提高任务处理效率</strong></h3><p>线程池允许多任务并发执行，充分利用 CPU 多核资源。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>任务可以并行处理，缩短总的执行时间。  </li>\n<li>对于 I&#x2F;O 密集型任务，可以避免阻塞操作浪费 CPU 时间。</li>\n</ul>\n</li>\n</ul>\n<p>例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。</p>\n<hr>\n<h3 id=\"7-支持自定义线程工厂，增强可监控性\"><a href=\"#7-支持自定义线程工厂，增强可监控性\" class=\"headerlink\" title=\"7. 支持自定义线程工厂，增强可监控性\"></a>7. <strong>支持自定义线程工厂，增强可监控性</strong></h3><p>通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>线程的命名规则便于调试和定位问题。  </li>\n<li>可定制线程池的行为（如异常处理、自定义日志记录等）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"8-减少程序的复杂度\"><a href=\"#8-减少程序的复杂度\" class=\"headerlink\" title=\"8. 减少程序的复杂度\"></a>8. <strong>减少程序的复杂度</strong></h3><p>线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>简化代码，提高可维护性。  </li>\n<li>避免手动管理线程带来的复杂性。</li>\n</ul>\n</li>\n</ul>\n<p>例如：直接提交任务给线程池，而无需手动启动或管理线程。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于<strong>高效利用系统资源</strong>和<strong>便捷的任务管理</strong>，是处理大规模并发任务的最佳实践之一。</p>\n","cover":false,"excerpt":"","more":"<p>使用线程池执行批量耗时任务的优点主要体现在以下几个方面：</p>\n<hr>\n<h3 id=\"1-线程复用，节约资源\"><a href=\"#1-线程复用，节约资源\" class=\"headerlink\" title=\"1. 线程复用，节约资源\"></a>1. <strong>线程复用，节约资源</strong></h3><p>线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>减少系统资源的占用（如 CPU 和内存）。  </li>\n<li>降低频繁创建线程带来的开销和延迟。</li>\n</ul>\n</li>\n</ul>\n<p>例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。</p>\n<hr>\n<h3 id=\"2-控制并发数量，防止资源耗尽\"><a href=\"#2-控制并发数量，防止资源耗尽\" class=\"headerlink\" title=\"2. 控制并发数量，防止资源耗尽\"></a>2. <strong>控制并发数量，防止资源耗尽</strong></h3><p>线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>避免任务数过多导致的线程竞争和阻塞问题。  </li>\n<li>提高系统的稳定性，防止线程爆炸。</li>\n</ul>\n</li>\n</ul>\n<p>例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。</p>\n<hr>\n<h3 id=\"3-简化任务管理\"><a href=\"#3-简化任务管理\" class=\"headerlink\" title=\"3. 简化任务管理\"></a>3. <strong>简化任务管理</strong></h3><p>线程池提供了统一的接口用于提交和管理任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以轻松管理任务的执行、取消、超时等操作。  </li>\n<li>使用线程池调度任务时，无需手动管理线程的生命周期。</li>\n</ul>\n</li>\n</ul>\n<p>例如：<code>ThreadPoolExecutor</code> 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。</p>\n<hr>\n<h3 id=\"4-支持任务队列，实现任务分批处理\"><a href=\"#4-支持任务队列，实现任务分批处理\" class=\"headerlink\" title=\"4. 支持任务队列，实现任务分批处理\"></a>4. <strong>支持任务队列，实现任务分批处理</strong></h3><p>线程池内部使用任务队列存储待执行的任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以实现任务的分批处理，适应大批量任务执行需求。  </li>\n<li>支持灵活的队列类型（如 <code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code>）。</li>\n</ul>\n</li>\n</ul>\n<p>例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。</p>\n<hr>\n<h3 id=\"5-提供灵活的线程管理策略\"><a href=\"#5-提供灵活的线程管理策略\" class=\"headerlink\" title=\"5. 提供灵活的线程管理策略\"></a>5. <strong>提供灵活的线程管理策略</strong></h3><p>线程池允许配置不同的线程数量和策略：  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>设置核心线程数、最大线程数，适应不同负载需求。  </li>\n<li>支持定时任务、周期性任务等多种调度模式。</li>\n</ul>\n</li>\n</ul>\n<p>例如：使用 <code>ScheduledThreadPoolExecutor</code> 可以定时调度任务，而 <code>CachedThreadPool</code> 适用于大量短期任务。</p>\n<hr>\n<h3 id=\"6-提高任务处理效率\"><a href=\"#6-提高任务处理效率\" class=\"headerlink\" title=\"6. 提高任务处理效率\"></a>6. <strong>提高任务处理效率</strong></h3><p>线程池允许多任务并发执行，充分利用 CPU 多核资源。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>任务可以并行处理，缩短总的执行时间。  </li>\n<li>对于 I&#x2F;O 密集型任务，可以避免阻塞操作浪费 CPU 时间。</li>\n</ul>\n</li>\n</ul>\n<p>例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。</p>\n<hr>\n<h3 id=\"7-支持自定义线程工厂，增强可监控性\"><a href=\"#7-支持自定义线程工厂，增强可监控性\" class=\"headerlink\" title=\"7. 支持自定义线程工厂，增强可监控性\"></a>7. <strong>支持自定义线程工厂，增强可监控性</strong></h3><p>通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>线程的命名规则便于调试和定位问题。  </li>\n<li>可定制线程池的行为（如异常处理、自定义日志记录等）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"8-减少程序的复杂度\"><a href=\"#8-减少程序的复杂度\" class=\"headerlink\" title=\"8. 减少程序的复杂度\"></a>8. <strong>减少程序的复杂度</strong></h3><p>线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>简化代码，提高可维护性。  </li>\n<li>避免手动管理线程带来的复杂性。</li>\n</ul>\n</li>\n</ul>\n<p>例如：直接提交任务给线程池，而无需手动启动或管理线程。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于<strong>高效利用系统资源</strong>和<strong>便捷的任务管理</strong>，是处理大规模并发任务的最佳实践之一。</p>\n"},{"title":"普通线程池的执行流程","date":"2024-11-01T08:50:09.000Z","_content":"\n普通线程池的执行流程通常包括以下几个步骤：\n\n1. **线程池初始化**  \n   在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。\n\n2. **提交任务**  \n   当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。\n\n3. **任务执行流程**  \n   根据线程池的状态和配置，线程池采取以下策略来执行任务：\n   \n   - **核心线程数未满**：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。\n   - **核心线程已满，任务队列未满**：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。\n   - **任务队列已满，且线程数未达上限**：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。\n   - **任务队列已满，且线程数达到上限**：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。\n\n4. **线程执行任务**  \n   被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。\n\n5. **线程回收与销毁**\n   \n   - **空闲线程回收**：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。\n   - **线程池关闭**：当调用线程池的 `shutdown` 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 `shutdownNow` 方法立即中断所有线程，强制关闭线程池。\n\n6. **任务结束后的清理**  \n   当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。\n\n整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。\n","source":"_posts/普通线程池的执行流程.md","raw":"---\ntitle: 普通线程池的执行流程\ndate: 2024-11-01 16:50:09\ntags: java基础\ncategories: 八股文\n---\n\n普通线程池的执行流程通常包括以下几个步骤：\n\n1. **线程池初始化**  \n   在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。\n\n2. **提交任务**  \n   当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。\n\n3. **任务执行流程**  \n   根据线程池的状态和配置，线程池采取以下策略来执行任务：\n   \n   - **核心线程数未满**：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。\n   - **核心线程已满，任务队列未满**：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。\n   - **任务队列已满，且线程数未达上限**：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。\n   - **任务队列已满，且线程数达到上限**：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。\n\n4. **线程执行任务**  \n   被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。\n\n5. **线程回收与销毁**\n   \n   - **空闲线程回收**：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。\n   - **线程池关闭**：当调用线程池的 `shutdown` 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 `shutdownNow` 方法立即中断所有线程，强制关闭线程池。\n\n6. **任务结束后的清理**  \n   当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。\n\n整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。\n","slug":"普通线程池的执行流程","published":1,"updated":"2024-12-14T09:16:09.195Z","comments":1,"layout":"post","photos":[],"_id":"cm6q6pd2h002u3ga8a8v29uzd","content":"<p>普通线程池的执行流程通常包括以下几个步骤：</p>\n<ol>\n<li><p><strong>线程池初始化</strong><br>在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。</p>\n</li>\n<li><p><strong>提交任务</strong><br>当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。</p>\n</li>\n<li><p><strong>任务执行流程</strong><br>根据线程池的状态和配置，线程池采取以下策略来执行任务：</p>\n<ul>\n<li><strong>核心线程数未满</strong>：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。</li>\n<li><strong>核心线程已满，任务队列未满</strong>：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。</li>\n<li><strong>任务队列已满，且线程数未达上限</strong>：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。</li>\n<li><strong>任务队列已满，且线程数达到上限</strong>：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。</li>\n</ul>\n</li>\n<li><p><strong>线程执行任务</strong><br>被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。</p>\n</li>\n<li><p><strong>线程回收与销毁</strong></p>\n<ul>\n<li><strong>空闲线程回收</strong>：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。</li>\n<li><strong>线程池关闭</strong>：当调用线程池的 <code>shutdown</code> 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 <code>shutdownNow</code> 方法立即中断所有线程，强制关闭线程池。</li>\n</ul>\n</li>\n<li><p><strong>任务结束后的清理</strong><br>当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。</p>\n</li>\n</ol>\n<p>整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。</p>\n","cover":false,"excerpt":"","more":"<p>普通线程池的执行流程通常包括以下几个步骤：</p>\n<ol>\n<li><p><strong>线程池初始化</strong><br>在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。</p>\n</li>\n<li><p><strong>提交任务</strong><br>当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。</p>\n</li>\n<li><p><strong>任务执行流程</strong><br>根据线程池的状态和配置，线程池采取以下策略来执行任务：</p>\n<ul>\n<li><strong>核心线程数未满</strong>：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。</li>\n<li><strong>核心线程已满，任务队列未满</strong>：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。</li>\n<li><strong>任务队列已满，且线程数未达上限</strong>：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。</li>\n<li><strong>任务队列已满，且线程数达到上限</strong>：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。</li>\n</ul>\n</li>\n<li><p><strong>线程执行任务</strong><br>被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。</p>\n</li>\n<li><p><strong>线程回收与销毁</strong></p>\n<ul>\n<li><strong>空闲线程回收</strong>：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。</li>\n<li><strong>线程池关闭</strong>：当调用线程池的 <code>shutdown</code> 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 <code>shutdownNow</code> 方法立即中断所有线程，强制关闭线程池。</li>\n</ul>\n</li>\n<li><p><strong>任务结束后的清理</strong><br>当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。</p>\n</li>\n</ol>\n<p>整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm6q6pd1m00013ga87mog2k3h","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd1u000d3ga8h5ga8s8z"},{"post_id":"cm6q6pd1o00023ga84vwc79qy","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd1w000k3ga8f6ysf2hq"},{"post_id":"cm6q6pd1t000c3ga8dlcg5mha","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd1y000p3ga8epscciu1"},{"post_id":"cm6q6pd1u000g3ga800zpbz2u","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd1y000s3ga8goye7u7a"},{"post_id":"cm6q6pd1q00053ga8f6vc3lf2","category_id":"cm6q6pd1u000e3ga8bznnf4kh","_id":"cm6q6pd1z000x3ga8074a1nsl"},{"post_id":"cm6q6pd1x000n3ga8fkumff1o","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2000103ga88mhlda0d"},{"post_id":"cm6q6pd1r00063ga80kmfhdaf","category_id":"cm6q6pd1u000e3ga8bznnf4kh","_id":"cm6q6pd2100143ga8dqob54ka"},{"post_id":"cm6q6pd1z000v3ga8e77mfpkb","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd2100173ga842euf3os"},{"post_id":"cm6q6pd1r00073ga889c915r6","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd22001a3ga8famr7woa"},{"post_id":"cm6q6pd1z000y3ga86ruw5hu0","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd23001e3ga82c2qa6je"},{"post_id":"cm6q6pd1s000b3ga8bou8emgg","category_id":"cm6q6pd2000113ga8godb6ykd","_id":"cm6q6pd23001h3ga85y7ig7ix"},{"post_id":"cm6q6pd2200193ga80jyi8kdt","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd24001k3ga8bebqce4h"},{"post_id":"cm6q6pd1v000i3ga85ydta824","category_id":"cm6q6pd2100183ga8daw0a1n7","_id":"cm6q6pd26001o3ga8762da8iq"},{"post_id":"cm6q6pd23001f3ga87yhe2ycn","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd27001r3ga85y1rh3im"},{"post_id":"cm6q6pd1y000q3ga85gbx1539","category_id":"cm6q6pd2100183ga8daw0a1n7","_id":"cm6q6pd28001v3ga85mljdwl6"},{"post_id":"cm6q6pd24001m3ga80gkt1ke7","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd29001z3ga8c3a1c8ad"},{"post_id":"cm6q6pd27001q3ga8cdi76aje","category_id":"cm6q6pd1u000e3ga8bznnf4kh","_id":"cm6q6pd2a00223ga89qfyfopv"},{"post_id":"cm6q6pd2100163ga8cyb8crpt","category_id":"cm6q6pd24001n3ga8e2gw8n8m","_id":"cm6q6pd2a00263ga80qcr7i3v"},{"post_id":"cm6q6pd27001t3ga8epeoc5oq","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2b00293ga876o37f0h"},{"post_id":"cm6q6pd28001y3ga8a24meocd","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2c002d3ga80xmx1xl2"},{"post_id":"cm6q6pd24001j3ga8bqd19rpd","category_id":"cm6q6pd28001u3ga84zpk8u51","_id":"cm6q6pd2c002g3ga86i3b1a1j"},{"post_id":"cm6q6pd2900213ga834tt86i6","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2d002k3ga83w4l0oam"},{"post_id":"cm6q6pd2a00253ga8dg5q92bg","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2h002o3ga87lvzhfhb"},{"post_id":"cm6q6pd2b00283ga8f1qk718p","category_id":"cm6q6pd2100183ga8daw0a1n7","_id":"cm6q6pd2h002s3ga8behc9fn1"},{"post_id":"cm6q6pd2b002c3ga8f9trfd3q","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2i002w3ga81ctf9wz0"},{"post_id":"cm6q6pd2g002n3ga8hpgx657u","category_id":"cm6q6pd1p00033ga8bp4l1b0s","_id":"cm6q6pd2i002y3ga8afe18yvq"},{"post_id":"cm6q6pd2h002q3ga8ebpk61me","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd2i00313ga840mff2yu"},{"post_id":"cm6q6pd2c002f3ga89hrjckdl","category_id":"cm6q6pd2g002m3ga819xp1dv4","_id":"cm6q6pd2j00333ga866wghvzg"},{"post_id":"cm6q6pd2h002u3ga8a8v29uzd","category_id":"cm6q6pd1s00083ga82c4304lb","_id":"cm6q6pd2j00363ga83auo3rqm"},{"post_id":"cm6q6pd2c002i3ga88to46vn3","category_id":"cm6q6pd2i002v3ga8glfz4j2g","_id":"cm6q6pd2j00383ga834efccpt"}],"PostTag":[{"post_id":"cm6q6pd1m00013ga87mog2k3h","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd1s000a3ga8g34i3bue"},{"post_id":"cm6q6pd1o00023ga84vwc79qy","tag_id":"cm6q6pd1s00093ga82anjadv8","_id":"cm6q6pd1v000h3ga82xr83dvx"},{"post_id":"cm6q6pd1t000c3ga8dlcg5mha","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd1w000j3ga8gwkz3tvu"},{"post_id":"cm6q6pd1u000g3ga800zpbz2u","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd1y000o3ga8d8n4f4fp"},{"post_id":"cm6q6pd1q00053ga8f6vc3lf2","tag_id":"cm6q6pd1u000f3ga89ded7lhv","_id":"cm6q6pd1y000r3ga8dubs18hb"},{"post_id":"cm6q6pd1x000n3ga8fkumff1o","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd1z000w3ga85fii99ep"},{"post_id":"cm6q6pd1r00063ga80kmfhdaf","tag_id":"cm6q6pd1w000m3ga8a9jz3sh0","_id":"cm6q6pd20000z3ga8gbrk4z2x"},{"post_id":"cm6q6pd1r00073ga889c915r6","tag_id":"cm6q6pd1z000u3ga80iywa65r","_id":"cm6q6pd2100153ga8ego3hx4a"},{"post_id":"cm6q6pd1s000b3ga8bou8emgg","tag_id":"cm6q6pd2000133ga8f934glmr","_id":"cm6q6pd23001d3ga8hurggx89"},{"post_id":"cm6q6pd1v000i3ga85ydta824","tag_id":"cm6q6pd22001b3ga80md5a863","_id":"cm6q6pd24001l3ga8gwofh3xv"},{"post_id":"cm6q6pd1y000q3ga85gbx1539","tag_id":"cm6q6pd22001b3ga80md5a863","_id":"cm6q6pd27001s3ga832c97vn3"},{"post_id":"cm6q6pd24001m3ga80gkt1ke7","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd28001w3ga827t30i1z"},{"post_id":"cm6q6pd1z000v3ga8e77mfpkb","tag_id":"cm6q6pd1z000u3ga80iywa65r","_id":"cm6q6pd2900203ga84eo6dkkd"},{"post_id":"cm6q6pd27001t3ga8epeoc5oq","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd2a00233ga80u62gll3"},{"post_id":"cm6q6pd28001y3ga8a24meocd","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd2a00273ga80mvu79xd"},{"post_id":"cm6q6pd1z000y3ga86ruw5hu0","tag_id":"cm6q6pd28001x3ga8d054e0lo","_id":"cm6q6pd2b002a3ga8ag8t6jph"},{"post_id":"cm6q6pd2900213ga834tt86i6","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd2c002e3ga868rpaupt"},{"post_id":"cm6q6pd2a00253ga8dg5q92bg","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd2c002h3ga88n6he72i"},{"post_id":"cm6q6pd2000123ga850ky6mrd","tag_id":"cm6q6pd28001x3ga8d054e0lo","_id":"cm6q6pd2g002l3ga87udz03l2"},{"post_id":"cm6q6pd2b00283ga8f1qk718p","tag_id":"cm6q6pd22001b3ga80md5a863","_id":"cm6q6pd2h002p3ga8gbv08yx6"},{"post_id":"cm6q6pd2b002c3ga8f9trfd3q","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd2h002t3ga8fi9q50hd"},{"post_id":"cm6q6pd2100163ga8cyb8crpt","tag_id":"cm6q6pd2b002b3ga800nn7mwi","_id":"cm6q6pd2i002x3ga8659j9ilp"},{"post_id":"cm6q6pd2g002n3ga8hpgx657u","tag_id":"cm6q6pd1q00043ga8cwkibkb6","_id":"cm6q6pd2i00303ga8fpax8icz"},{"post_id":"cm6q6pd2200193ga80jyi8kdt","tag_id":"cm6q6pd2b002b3ga800nn7mwi","_id":"cm6q6pd2i00323ga83ef90t0q"},{"post_id":"cm6q6pd2h002q3ga8ebpk61me","tag_id":"cm6q6pd1z000u3ga80iywa65r","_id":"cm6q6pd2j00353ga86wsmdhah"},{"post_id":"cm6q6pd2h002u3ga8a8v29uzd","tag_id":"cm6q6pd1z000u3ga80iywa65r","_id":"cm6q6pd2j00373ga83xnj2f08"},{"post_id":"cm6q6pd22001c3ga8afa67j6d","tag_id":"cm6q6pd2h002r3ga8gqrv4t3d","_id":"cm6q6pd2j00393ga84ks18156"},{"post_id":"cm6q6pd23001f3ga87yhe2ycn","tag_id":"cm6q6pd28001x3ga8d054e0lo","_id":"cm6q6pd2k003b3ga8eueq3v5x"},{"post_id":"cm6q6pd24001j3ga8bqd19rpd","tag_id":"cm6q6pd2j00343ga8dj0a0z11","_id":"cm6q6pd2k003c3ga8d1jabmf6"},{"post_id":"cm6q6pd27001q3ga8cdi76aje","tag_id":"cm6q6pd2j003a3ga8hqle2n2o","_id":"cm6q6pd2k003e3ga81fv10tdx"},{"post_id":"cm6q6pd2c002f3ga89hrjckdl","tag_id":"cm6q6pd2k003d3ga81yj1fmnq","_id":"cm6q6pd2k003g3ga89e3sfy5c"},{"post_id":"cm6q6pd2c002i3ga88to46vn3","tag_id":"cm6q6pd2k003f3ga8a9m0d9ju","_id":"cm6q6pd2k003h3ga804lpfa40"}],"Tag":[{"name":"leetcode","_id":"cm6q6pd1q00043ga8cwkibkb6"},{"name":"juc","_id":"cm6q6pd1s00093ga82anjadv8"},{"name":"线程池","_id":"cm6q6pd1u000f3ga89ded7lhv"},{"name":"gradle","_id":"cm6q6pd1w000m3ga8a9jz3sh0"},{"name":"java基础","_id":"cm6q6pd1z000u3ga80iywa65r"},{"name":"java","_id":"cm6q6pd2000133ga8f934glmr"},{"name":"localCache","_id":"cm6q6pd22001b3ga80md5a863"},{"name":"mysql","_id":"cm6q6pd28001x3ga8d054e0lo"},{"name":"redis","_id":"cm6q6pd2b002b3ga800nn7mwi"},{"name":"算法","_id":"cm6q6pd2h002r3ga8gqrv4t3d"},{"name":"实习","_id":"cm6q6pd2j00343ga8dj0a0z11"},{"name":"设计模式","_id":"cm6q6pd2j003a3ga8hqle2n2o"},{"name":"实在智能","_id":"cm6q6pd2k003d3ga81yj1fmnq"},{"name":"面试","_id":"cm6q6pd2k003f3ga8a9m0d9ju"}]}}