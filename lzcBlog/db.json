{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/background.png","path":"img/background.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/head-pic.png","path":"img/head-pic.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/java中Atomic原子类型.md","hash":"abc8c8c9cab0c540553531a8022920e9def8581b","modified":1734162516139},{"_id":"source/_posts/java中的代理.md","hash":"102586c833b5902bc022a4bf62a8e25c7c0f37fd","modified":1734162614235},{"_id":"source/_posts/redis淘汰策略.md","hash":"1a4c60742d732920c1204ed684c6eac142f572a3","modified":1734167660682},{"_id":"source/_posts/redo-log和undo-log.md","hash":"a723c907866990e382e89b45dd7f205e6424f00c","modified":1734167684312},{"_id":"source/_posts/leetcode第31题解.md","hash":"bbc7301420ca92794d9cca18c50082ed3437d17f","modified":1734163773135},{"_id":"source/_posts/mysql数据库索引分类及其底层数据结构.md","hash":"e66a6660305bcd2fbef9ff10f0d7cd8e3c1a7b92","modified":1734162705874},{"_id":"source/_posts/实在智能实习经历收获.md","hash":"739fb15158a995a579af124e3aaecffef7be48c6","modified":1734167807121},{"_id":"source/_posts/普通线程池的执行流程.md","hash":"804ca26dbcc2f0988dcff2f8d0db741eadbd60f8","modified":1734167769195},{"_id":"source/_posts/工厂-注册表模式设计nodeHandler.md","hash":"32ddfa6422a5293f6a83390ff76f91626ea17d4a","modified":1734167753521},{"_id":"source/_posts/用线程池执行批量耗时任务的优点.md","hash":"52c18bd7496099961eb9c9b3a1e64f927ac0164c","modified":1734167819572},{"_id":"themes/butterfly/README_CN.md","hash":"6e79be6f188bd671eb6ef1084ea7dd757fa2b3e9","modified":1733383146000},{"_id":"themes/butterfly/package.json","hash":"dc0b4447ce57e182169c634b0018e9b0bd3b5bdc","modified":1734159092018},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1733383146000},{"_id":"themes/butterfly/README.md","hash":"310bf423097f1cefb6121ce3f115b2ef68aacc44","modified":1733383146000},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1733383146000},{"_id":"themes/butterfly/languages/default.yml","hash":"f46a8e362641f7a7c432d68e3984e739d5fe6b44","modified":1733383146000},{"_id":"themes/butterfly/languages/en.yml","hash":"f46a8e362641f7a7c432d68e3984e739d5fe6b44","modified":1733383146000},{"_id":"themes/butterfly/languages/ja.yml","hash":"c978fbf9421af4d96978161cef828ea88ae06037","modified":1733383146000},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"c3e863ad5b5aa618873ad4370cf0335a9cc67b39","modified":1733383146000},{"_id":"themes/butterfly/languages/ko.yml","hash":"ca8d31350e60b5849bb609a4d33f90d3dd8905a2","modified":1733383146000},{"_id":"themes/butterfly/layout/archive.pug","hash":"bb32c9c476372de747dfa563b83f77d7a917a77d","modified":1733383146000},{"_id":"themes/butterfly/plugins.yml","hash":"a244af3b578de079666bd87c3055917220e63c25","modified":1733383146000},{"_id":"themes/butterfly/_config.yml","hash":"1b98c3a938a6c3256c4edc5f8cfbb8c2dffe5165","modified":1734167539957},{"_id":"themes/butterfly/package-lock.json","hash":"552f3a90ddf6282d0d0cce79a0893f93cc4dc98c","modified":1734159092018},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"9fecee5467e9c5034515fea73f1901c3c67e8ef9","modified":1733383146000},{"_id":"themes/butterfly/layout/category.pug","hash":"bf07d9624ac7285214c7f1d505da3a813c164c8c","modified":1733383146000},{"_id":"themes/butterfly/layout/index.pug","hash":"6aba5fd01aba75fd38ef2e2c1d406d951b8c5560","modified":1733383146000},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"e91ac1a94e1fc84cd75bc6b0a8b7a62acfb2a516","modified":1733383146000},{"_id":"themes/butterfly/layout/post.pug","hash":"d000b6a16418c1d95d4ce49ff9346416bbb151d3","modified":1733383146000},{"_id":"themes/butterfly/layout/page.pug","hash":"a59b90dd3f845ef6bac18091c55e8e019f4fe7a3","modified":1733383146000},{"_id":"themes/butterfly/layout/tag.pug","hash":"98c0084a4c62415775ca9e261e3d4eeb7668f35b","modified":1733383146000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"df07add8fca55a7a12173af53201d306000fd9e0","modified":1733383146000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1733383146000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7b4831ae8f8f8c55dd1b856781210c517c63e6dd","modified":1733383146000},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"cd2e0141d7bbd2bd348703ead52c8060904ab338","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"78cd51877c72a66de13ad88af6687627d4743b03","modified":1733383146000},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"82548510310fb44587371fcc9afd7f0bbdb673b1","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"345cb07213cdf66cfef7d9699c60f5f3297e9585","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"eb31f49a826c1f95890078745e55c9a2ccb319f9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"7d3581a446285b0cd9362266d54b59fe8768af9e","modified":1733383146000},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"b69c137c06791db58e347474b88803e112d100dd","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"d4f3a798cdded0c0744efab3b1397b00cdb0c6e5","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/404.js","hash":"a196e0d2eb40d1643bcf53a467ad37104f877ca5","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"0e59424100fc3138b9096b38a0a2384a6411f8d9","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"072f042e069e7a0523fa439569c0c672f389b5c4","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"1ac9527c510ca757724f15dec84b0ead032411b2","modified":1733383146000},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"860f967ecf3c6a6ea785b560a7aae4d0757cd18a","modified":1733383146000},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a8eef3f37428436554f58a2b6bac7c255fbdf38d","modified":1733383146000},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"24a88d138ccabf29698a6cfe399b2e10f126367f","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7397db8012c27a4a1da75dd659745676654a0c65","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"1b37a484cbcc81f51953ea093644b70499c26314","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"5edf400514843e28b329c3fd3f12f66ed5faca66","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"39325366b622cfd2089cb1c9344d89f2edd79816","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"9c2ee5868879529f7cef7d93edca5b755f45e7e9","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"132d1e7757d0dac42d6b0957a25484613d7ed873","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"a26402edc63cbe8faa6a99647f039ffd9616e1f6","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"555f7e4a2a7d8c4420ca467e87625bf96db11a70","modified":1733383146000},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"806e2e5843df23e7eb94709056676f5ce6bfefa7","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"e0abf9f0ec51a78258bbf0101632e7dd2c54db25","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"365db87ddfc582bf8c15cb440c48bed95106e4b1","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"22bc3a24c3610b5a3c3a2043b7d10e26d00018b8","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"5c2a07df5874b5377540884e4da14dd21489378f","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"512c68a22ae4a58d6a6b24b368a0c00c2ccb4fcb","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"5cb273e95846874e3a58074074c501df23c5e912","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"1acefc59ead75ebd8cafee36efc7da4fa426d088","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3a9a28f6833e9cea60761e52ab8990fcb597444f","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"f4507d1527cc0d5fe9fdd89eb769e15814a18fec","modified":1733383146000},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"67c1aad5ddfe56deae672146c2774379aa65af95","modified":1733383146000},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1733383146000},{"_id":"themes/butterfly/source/css/var.styl","hash":"8cc7b245da61e35cfcc80cafb4e553b5fa968111","modified":1733383146000},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1733383146000},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1733383146000},{"_id":"themes/butterfly/source/js/main.js","hash":"9fb88eb196f9368768aaa554c679129e4969f069","modified":1733383146000},{"_id":"themes/butterfly/source/js/utils.js","hash":"fd3c26366c78dd82bc87d4ddebe76c582122e1b7","modified":1733383146000},{"_id":"themes/butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1733383146000},{"_id":"themes/butterfly/source/img/head-pic.png","hash":"3f0bf78cf120b48293a5ba6652684fe748faeb1c","modified":1734164859846},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1733383146000},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"e5a26d2e2ca789dffc6bd9cfc13ff9e530c9911c","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"c681697eac3657c2c3e921c2774d67bb93d47331","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"fbe602e22ee4a60d711485ad925dfe06b92a4c76","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"5208fe1e75d97a05fd9bdd6cc53c59d8b741b94b","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"2beb68bdd43b09a539c8f4ed0cb7c0838c03409a","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"0e301fe266b3260257b5a619dc8eedf2c1955e7e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"f4f590102c1937d63da5edf35f2ff37f5932ccc1","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"605809f97b2f0da0e2e84dd2365fc8ccee1de6bd","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"cd507e58852dc59a72e624fc1b22dc9b138c2575","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"95316827e12ec1a2cee18b7d5f49971e9a88b138","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"10aa44e0216dbde863e2bd41267b613dc220e517","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"b7608dca3d361001d661779fe8be03c370231c41","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"77eca4f5dbf38c2c805b732ff8d7d9c1560b6f16","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"ca9cc03a51561413728d7211f0a544654c5d4e36","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"4912beecdef7af33f0704ef4d6605e1ac69fbb11","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"a6c3a4a608f540d05105a7ae19e2f5719c2a3f71","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"7e7cd9dfd832c8f3e829ad445eccf5cb5dc8ff18","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"38c0781ac7544d2010d5bfe7ae521125f3672975","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/post/outdate-notice.pug","hash":"1661f8a53334789099efffa92246158cb3d933b3","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"2bef558fa87986805b3397319b4c088564ba7c44","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"55090eee8076af761be7741b4e330ceea07c27d7","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"2dca79799c566ffa68b21ecefa9c63432b5088e1","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"38b85f46c8e1bcbc43d2a4875d94ea201518eeeb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"0595d60dbf701e2ffa92181923861b1457a02112","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"8b12fa52bd522dded8b7f1ae3f580f339d75aecf","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"1d39670ee6225f85f5c53bf5c84f3fd6e19290e8","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0c1affa498b28e79e5a465f3f8f18035993bcb88","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"512111475060798925eb1a7bc7617c34b8bd32ab","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"5c7605a0353ef2709f75bad27794f985c7c78907","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"21d42f43f26a2075abf2e6d13d35fb1aaf53a8b4","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"e2fa3804c0fef70bb6fa884f1055c978725ccef2","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"4ae59a48f8984ce8316cfc82756180dc496774eb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"bd5ad01277f8c6ddf8a3a29af1518e5fe6eed23f","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"ba95646b78688bcdcf77166407c4799e5e3c3e6d","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"a658a274c5f7896ee5122725bee45548693bdd66","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"66f7a8b0cebc05c575ec3cb70b08d6854029d87a","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"5da5f11a0f7f0fc06732df412bb77a7dddc41429","modified":1733383146000},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"15f321aee7876f2366677914a7cd2ab8b071b162","modified":1733383146000},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"506bbff9c954d5f92a6d97145be2d732571fae39","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3312e3bc1076ac8ba9dd902a671602c78a5e1479","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"4382ecffdb778de9fa05edf24765b68ae6da1220","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"134811b2d696f9ed2c0cd578f3886f1c60770c0a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dbd4af28bbf2fe9a7d75a75fdf460dfb3317311a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"316447b94933af2cc580cc9c2b8b42e3875b8c08","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"0ba6e4f5252d1a95e9dfa20b4a17207b6713947d","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"1a864887fb1bc9d24caa6b8b63a9bfc251762ffd","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"517361bf999e41fdea2c57e0af6e82d310f76edd","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"0d0ef8a9260b494e50ef545e5f395d649418f0a9","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"743f9dd5585ecac812f3aa908eede4093d84fbd7","modified":1733383146000},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"11a0fde4e784b0af5bb813c9e9ca9e480e5db99a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"a96513acd7f51ffa01531ef3a24fdf5391ae93ae","modified":1733383146000},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"be7ee2c63cedbc6b7f03cb3993ec533d9ae9d8bb","modified":1733383146000},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"e2761a2515b34d2d41dea00551abc44d4ce72aeb","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"354902d03f13068cf8a3617fb0ea92669e6b2a86","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c08432ecceaa187005c55144cf6f2b092ca50820","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"8aa755a3f588e6e598e4fb6510faa6e766d59a94","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"b02e88bb5dafcef11be4669da6cd9cddbf9a852a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"3fa5aa012c62da3b5220654426c0708cab24e9af","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"643ff8c79d033947da312b70847b1b45850d7b29","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"855af8f97daad51b0161d96d50abd71edec87142","modified":1733383146000},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"e765323537d174c7dcb88614100ccdc3e2d020e1","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"79e95511d8d51e8944092b9596994d9779c1f4e4","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"4765d72ab300910437d64991d3f70a82b41d4e3a","modified":1733383146000},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"44d6b9fa9f0cb9026722f7dda15368d41d3fed20","modified":1733383146000},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e2046eed9503ac506d5ca120b60203dd2cd968af","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"2c71b5bfb873d57eb6532144f66e86183dd0dcf6","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1733383146000},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"1ce084ed240d0e998bcdf1416ada598637878398","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"5ded9ddc66777e93cc4f0e1e4349540c0249346d","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"7e5ca6a899c66b26cebc027db530d54018e2c5c0","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"f7415acfee7adb5ba01fd278b1e16b636a6b20a1","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"4a651e47d658340443bb63b7d15a1e9e34f76aca","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"909bb5079b26b6ee68177919f522566503654058","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"e76655e699154c3d39043c1a5bb8400dc1658399","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"cf24d72ea16ef253a438efe95b9a0a8fdfbb6d01","modified":1733383146000},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"62d03f6c429c2de256a204399610a041cab23b04","modified":1733383146000},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1733383146000},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"cb77a73a2b47156d18afb9f2376b3d502d0d12d7","modified":1733383146000},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"f71d8acf5b0f3ece91ae1e018962c73b50941a45","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"cabb3a06f8ef297a1ea3d91ced8abeaa0831aa14","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"be40f20273c31e8b37353d9705ad9b9c693e16a2","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"966ef931a9545cdde8c270322e8650b54b965935","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"dd5c7e808654aefeb3fcc81c7b0911cff1ee8776","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"8f3d4c33ec3d1be4bd203ba2461db9ccfad63f23","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"a9709905593d960954e2dd572f09f48a6c2b1ef7","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"6ddd9dce1a553a0d24509d7f9c78b9f6742be030","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"d040c00332e83c985dbc0e76e3242336edbcd764","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"830bafcf50180fed4fcf76f0da277d702e66a5b3","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"8869bac6ec822a70dfe432d7bd5e599750441ddb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"bfc6e6690e70c5bd646bdff354b750ebd782f4ad","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"8b21906b1b3f3faa19bdc16f4167b0b5d487c9ac","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"46c177643a8e65f036cb08c29387d4ab29485859","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2c6eb1b0b3586ce6a92228f809be37642a2010b0","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"5aaef147ae31e1ffc49152acd43dabc5f15b39ba","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"5227663ccbe86c830447e4dcc594202b1582595d","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"9ed621742714de6de6593490e3d4aaa3f30a4791","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"71af0b679e00290b0854384368b3c7e9b3e5f26a","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"007bb96fd84f38852b7ab5f761e6867b6058422f","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"c5f7081ca29db8cc80f808dfc29e36d5fa22fd7e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"a35c21e9ec2bef465c945408da515bfb5d848d6d","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"5715fc2dc75808af0a434fe66b81d0f651d03ed3","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"a3f409a0c1ed3df8c920f7d32b86c3832459f3bf","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"3a5ccfc69bd8ccb4b8f3ce3502023f7914f2a022","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"bd87dc207f1cab66e48496548b18f0dd9021eb91","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"49aece5be2a0a8e414257ecbfc2abd7d0d5f8c64","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"1c2190c9bac26992de8d52be4f8522309d566750","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"2e82651607326e7f999fc7891480c74a06cbb416","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"86cf7ba9cae6eb8bee0ca792df7a82f58c8451ff","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"7e3b4e1124c9917b820e96bd0c915c08da68aecd","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"619c41729691a54871b49da54ea27657d1b58e7e","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"b82c936cb73c325fcac69832a3e475ed732e06f9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"988f75833dcb18d4a02c34cdea51e39434ea5723","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"393a327a7f41de070abd53cd95149d3e7e1bbf61","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"eee2c6b5c73ea280c7b683a1d117cab5a2ea5f66","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"18b492731f67d449bb32d7fac321deb57a92e75f","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"16796729df739a47508999b5467a57037ee6e9df","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"11a4e7decb634fbd6af454aa5ec230945837b6a9","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"8a7d5cdca6a87897d435fc88ebcb7ec0b7ec8591","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"f11c6db285f57a475db638e74920efb2d0e5a4d0","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"393c94702fd65c585e37bcf9a4f33c638d8bac72","modified":1733383146000},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"fdcc5a88505fcbf0593aa04ecb4ac0c8ad4f8fa3","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"cc272f7d612a52f4f1d2a95456cc89bc709fe0e5","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"dcd3af96d8be1a6358a88daf2c66165cc9b792d9","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"1997713a8722391c8b5c8c1598ec19adee993fa5","modified":1733383146000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"ed77729c26cf815c75efd3a6889b6ac805471765","modified":1733383146000},{"_id":"themes/butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1733383146000},{"_id":"themes/butterfly/source/img/background.png","hash":"fad38e75bb760bd9794f7ea9d2583fb3dc4921a4","modified":1734164701664},{"_id":"public/archives/2024/12/index.html","hash":"f7b19a2e2106982f708e7d7e3f2c12bcdc3daef1","modified":1734167904441},{"_id":"public/categories/八股文/index.html","hash":"087703ed1a74dd3650b006766fc4a6b099efff89","modified":1734167904441},{"_id":"public/categories/实习业务/index.html","hash":"08887f7f7f84160139c55a39bb3cd27aed009ca4","modified":1734167904441},{"_id":"public/categories/业务场景/index.html","hash":"2de8274e6e6bbb863ca57014c1ee7b90762f1327","modified":1734167904441},{"_id":"public/categories/算法/index.html","hash":"7155a2656777760719a2644518da13c51239aff4","modified":1734167904441},{"_id":"public/tags/java基础/index.html","hash":"2dbde8e9282ea613680362fbbdf710f36fe65b8f","modified":1734167904441},{"_id":"public/tags/mysql/index.html","hash":"faa11ebeb21621a80b2e843e4552058196540e80","modified":1734167904441},{"_id":"public/tags/实习/index.html","hash":"86abdace88548b1fc5ff745168452179277c8826","modified":1734167904441},{"_id":"public/tags/redis/index.html","hash":"44325cab03f7c6f37ab707f8c034428d6117d445","modified":1734167904441},{"_id":"public/tags/设计模式/index.html","hash":"f4ad62684266a16536f97a8aafcfc23f165ee0cc","modified":1734167904441},{"_id":"public/2024/12/14/leetcode第31题解/index.html","hash":"29670d4fc30e0b0acc62651a47ad461418fb895b","modified":1734167904441},{"_id":"public/2024/12/14/java中的代理/index.html","hash":"ae8163e7b3021b04ed229b9e1877bc0223dbfa62","modified":1734167904441},{"_id":"public/2024/11/21/用线程池执行批量耗时任务的优点/index.html","hash":"4077d855729d9298c88e3626a318ed3cf11a3f71","modified":1734167904441},{"_id":"public/2024/11/14/工厂-注册表模式设计nodeHandler/index.html","hash":"32d959001491410d11bb5ed43bc160245cf136dd","modified":1734167904441},{"_id":"public/2024/11/01/普通线程池的执行流程/index.html","hash":"a1d914a35a88873de3044b5cc024af20105ffefb","modified":1734167904441},{"_id":"public/2024/10/26/实在智能实习经历收获/index.html","hash":"2572a396cad90553c4e85bac7d70510f4ab42da2","modified":1734167904441},{"_id":"public/2024/10/15/redis淘汰策略/index.html","hash":"901ab1ba28406ae36452e443952b4b2cf77f5bd0","modified":1734167904441},{"_id":"public/2024/10/15/java中Atomic原子类型/index.html","hash":"22b2d69d32fd46b7486fe7f5f603203b6bed7c1f","modified":1734167904441},{"_id":"public/2024/10/15/mysql数据库索引分类及其底层数据结构/index.html","hash":"d63704cd369218d0c697914ca9a1d46d367cb176","modified":1734167904441},{"_id":"public/2024/10/15/redo-log和undo-log/index.html","hash":"41e7d9c7c25b60f6781d7eff6a2750250edd8dc2","modified":1734167904441},{"_id":"public/archives/index.html","hash":"174edfbbe2c1e6a518cc6465fca47ea81d6f0f87","modified":1734167904441},{"_id":"public/archives/2024/index.html","hash":"80dd0d4483d601ef7e714e5123f1dafedd3e6e81","modified":1734167904441},{"_id":"public/archives/2024/10/index.html","hash":"0fb1145182492ec7960957eb6c00562a7372a700","modified":1734167904441},{"_id":"public/archives/2024/11/index.html","hash":"ce6abf8999c922ad948a274e0ea85d47ed5c3eeb","modified":1734167904441},{"_id":"public/index.html","hash":"51858db5a77f585575d39b44c0c5370e3600130a","modified":1734167904441},{"_id":"public/tags/leetcode/index.html","hash":"0d2a01158b199b5e59e37fcf97109de9575b0912","modified":1734167904441},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1734167904441},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1734167904441},{"_id":"public/img/head-pic.png","hash":"3f0bf78cf120b48293a5ba6652684fe748faeb1c","modified":1734167904441},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1734167904441},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1734167904441},{"_id":"public/js/utils.js","hash":"fd3c26366c78dd82bc87d4ddebe76c582122e1b7","modified":1734167904441},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1734167904441},{"_id":"public/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1734167904441},{"_id":"public/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1734167904441},{"_id":"public/css/index.css","hash":"cc3365c69cfd129ba8d7b18d78b0af25565c3d2f","modified":1734167904441},{"_id":"public/js/main.js","hash":"9fb88eb196f9368768aaa554c679129e4969f069","modified":1734167904441},{"_id":"public/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1734167904441},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1734167904441},{"_id":"public/img/background.png","hash":"fad38e75bb760bd9794f7ea9d2583fb3dc4921a4","modified":1734167904441}],"Category":[{"name":"八股文","_id":"cm4nysna400024oa87uqc6pud"},{"name":"实习业务","_id":"cm4nysnae000k4oa88qzp2ssk"},{"name":"业务场景","_id":"cm4nysnaf000r4oa87pez3win"},{"name":"算法","_id":"cm4nysnag000w4oa85wby3hh8"}],"Data":[],"Page":[],"Post":[{"title":"java中Atomic原子类型","date":"2024-10-15T06:19:12.000Z","_content":"\n​\n\n# Java中atomic原子类型\n\n原子类型是 Java 中用于支持多线程并发编程的类型，属于 `java.util.concurrent.atomic` 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。\n\n## 常见的原子类型：\n\n- `AtomicBoolean`\n\n- `AtomicInteger`\n\n- `AtomicLong`\n\n- `AtomicReference<T>`\n\n## 原子类型的特性：\n\n- 支持无锁的线程安全操作，避免使用 `synchronized` 或显式锁。\n- 提供了常见的原子操作，如 `get()`、`set()`、`compareAndSet()`、`incrementAndGet()` 等。\n\n## 以AtomicInteger为例，解析原子类型的特性：\n\n一些常见的 `AtomicInteger` 方法包括：\n\n1. `get()`：获取当前值。\n2. `set(int newValue)`：设置为指定值。\n3. `getAndIncrement()`：先获取当前值，然后递增。\n4. `incrementAndGet()`：先递增，然后获取当前值。\n5. `compareAndSet(int expect, int update)`：如果当前值等于 `expect`，则将值设置为 `update`。\n\n参考源码可知：\n\n通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。\n\n示例代码：\n\n```\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicIntegerExample {\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(0);\n\n        // 递增并获取值\n        System.out.println(atomicInteger.incrementAndGet()); // 输出 1\n\n        // 获取并递增值\n        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2\n\n        // 比较并设置值\n        boolean result = atomicInteger.compareAndSet(2, 5);\n        System.out.println(result); // 输出 true，因为当前值是 2\n        System.out.println(atomicInteger.get()); // 输出 5\n    }\n}\n```\n\n![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== \"点击并拖拽以移动\")\n\n通过 `AtomicInteger`，你可以避免使用 `synchronized` 关键字或手动管理锁，简化了多线程操作。\n\n​\n","source":"_posts/java中Atomic原子类型.md","raw":"---\ntitle: java中Atomic原子类型\ndate: 2024-10-15 14:19:12\ntags: java基础\ncategories: 八股文\n---\n\n​\n\n# Java中atomic原子类型\n\n原子类型是 Java 中用于支持多线程并发编程的类型，属于 `java.util.concurrent.atomic` 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。\n\n## 常见的原子类型：\n\n- `AtomicBoolean`\n\n- `AtomicInteger`\n\n- `AtomicLong`\n\n- `AtomicReference<T>`\n\n## 原子类型的特性：\n\n- 支持无锁的线程安全操作，避免使用 `synchronized` 或显式锁。\n- 提供了常见的原子操作，如 `get()`、`set()`、`compareAndSet()`、`incrementAndGet()` 等。\n\n## 以AtomicInteger为例，解析原子类型的特性：\n\n一些常见的 `AtomicInteger` 方法包括：\n\n1. `get()`：获取当前值。\n2. `set(int newValue)`：设置为指定值。\n3. `getAndIncrement()`：先获取当前值，然后递增。\n4. `incrementAndGet()`：先递增，然后获取当前值。\n5. `compareAndSet(int expect, int update)`：如果当前值等于 `expect`，则将值设置为 `update`。\n\n参考源码可知：\n\n通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。\n\n示例代码：\n\n```\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicIntegerExample {\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(0);\n\n        // 递增并获取值\n        System.out.println(atomicInteger.incrementAndGet()); // 输出 1\n\n        // 获取并递增值\n        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2\n\n        // 比较并设置值\n        boolean result = atomicInteger.compareAndSet(2, 5);\n        System.out.println(result); // 输出 true，因为当前值是 2\n        System.out.println(atomicInteger.get()); // 输出 5\n    }\n}\n```\n\n![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== \"点击并拖拽以移动\")\n\n通过 `AtomicInteger`，你可以避免使用 `synchronized` 关键字或手动管理锁，简化了多线程操作。\n\n​\n","slug":"java中Atomic原子类型","published":1,"updated":"2024-12-14T07:48:36.139Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysn9z00004oa82huzbuql","content":"<p>​</p>\n<h1 id=\"Java中atomic原子类型\"><a href=\"#Java中atomic原子类型\" class=\"headerlink\" title=\"Java中atomic原子类型\"></a>Java中atomic原子类型</h1><p>原子类型是 Java 中用于支持多线程并发编程的类型，属于 <code>java.util.concurrent.atomic</code> 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。</p>\n<h2 id=\"常见的原子类型：\"><a href=\"#常见的原子类型：\" class=\"headerlink\" title=\"常见的原子类型：\"></a>常见的原子类型：</h2><ul>\n<li><p><code>AtomicBoolean</code></p>\n</li>\n<li><p><code>AtomicInteger</code></p>\n</li>\n<li><p><code>AtomicLong</code></p>\n</li>\n<li><p><code>AtomicReference&lt;T&gt;</code></p>\n</li>\n</ul>\n<h2 id=\"原子类型的特性：\"><a href=\"#原子类型的特性：\" class=\"headerlink\" title=\"原子类型的特性：\"></a>原子类型的特性：</h2><ul>\n<li>支持无锁的线程安全操作，避免使用 <code>synchronized</code> 或显式锁。</li>\n<li>提供了常见的原子操作，如 <code>get()</code>、<code>set()</code>、<code>compareAndSet()</code>、<code>incrementAndGet()</code> 等。</li>\n</ul>\n<h2 id=\"以AtomicInteger为例，解析原子类型的特性：\"><a href=\"#以AtomicInteger为例，解析原子类型的特性：\" class=\"headerlink\" title=\"以AtomicInteger为例，解析原子类型的特性：\"></a>以AtomicInteger为例，解析原子类型的特性：</h2><p>一些常见的 <code>AtomicInteger</code> 方法包括：</p>\n<ol>\n<li><code>get()</code>：获取当前值。</li>\n<li><code>set(int newValue)</code>：设置为指定值。</li>\n<li><code>getAndIncrement()</code>：先获取当前值，然后递增。</li>\n<li><code>incrementAndGet()</code>：先递增，然后获取当前值。</li>\n<li><code>compareAndSet(int expect, int update)</code>：如果当前值等于 <code>expect</code>，则将值设置为 <code>update</code>。</li>\n</ol>\n<p>参考源码可知：</p>\n<p>通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。</p>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AtomicIntegerExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 递增并获取值</span><br><span class=\"line\">        System.out.println(atomicInteger.incrementAndGet()); // 输出 1</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取并递增值</span><br><span class=\"line\">        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2</span><br><span class=\"line\"></span><br><span class=\"line\">        // 比较并设置值</span><br><span class=\"line\">        boolean result = atomicInteger.compareAndSet(2, 5);</span><br><span class=\"line\">        System.out.println(result); // 输出 true，因为当前值是 2</span><br><span class=\"line\">        System.out.println(atomicInteger.get()); // 输出 5</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\" title=\"点击并拖拽以移动\"></p>\n<p>通过 <code>AtomicInteger</code>，你可以避免使用 <code>synchronized</code> 关键字或手动管理锁，简化了多线程操作。</p>\n<p>​</p>\n","cover":false,"excerpt":"","more":"<p>​</p>\n<h1 id=\"Java中atomic原子类型\"><a href=\"#Java中atomic原子类型\" class=\"headerlink\" title=\"Java中atomic原子类型\"></a>Java中atomic原子类型</h1><p>原子类型是 Java 中用于支持多线程并发编程的类型，属于 <code>java.util.concurrent.atomic</code> 包。原子类型提供了一种在多线程环境中执行线程安全操作的机制，它们通过底层硬件指令来实现原子操作（不可中断）。</p>\n<h2 id=\"常见的原子类型：\"><a href=\"#常见的原子类型：\" class=\"headerlink\" title=\"常见的原子类型：\"></a>常见的原子类型：</h2><ul>\n<li><p><code>AtomicBoolean</code></p>\n</li>\n<li><p><code>AtomicInteger</code></p>\n</li>\n<li><p><code>AtomicLong</code></p>\n</li>\n<li><p><code>AtomicReference&lt;T&gt;</code></p>\n</li>\n</ul>\n<h2 id=\"原子类型的特性：\"><a href=\"#原子类型的特性：\" class=\"headerlink\" title=\"原子类型的特性：\"></a>原子类型的特性：</h2><ul>\n<li>支持无锁的线程安全操作，避免使用 <code>synchronized</code> 或显式锁。</li>\n<li>提供了常见的原子操作，如 <code>get()</code>、<code>set()</code>、<code>compareAndSet()</code>、<code>incrementAndGet()</code> 等。</li>\n</ul>\n<h2 id=\"以AtomicInteger为例，解析原子类型的特性：\"><a href=\"#以AtomicInteger为例，解析原子类型的特性：\" class=\"headerlink\" title=\"以AtomicInteger为例，解析原子类型的特性：\"></a>以AtomicInteger为例，解析原子类型的特性：</h2><p>一些常见的 <code>AtomicInteger</code> 方法包括：</p>\n<ol>\n<li><code>get()</code>：获取当前值。</li>\n<li><code>set(int newValue)</code>：设置为指定值。</li>\n<li><code>getAndIncrement()</code>：先获取当前值，然后递增。</li>\n<li><code>incrementAndGet()</code>：先递增，然后获取当前值。</li>\n<li><code>compareAndSet(int expect, int update)</code>：如果当前值等于 <code>expect</code>，则将值设置为 <code>update</code>。</li>\n</ol>\n<p>参考源码可知：</p>\n<p>通过CAS无锁算法即Unsafe类中的compareAndSetInt方法实现原子性，保证数据修改时的线程安全。</p>\n<p>示例代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AtomicIntegerExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 递增并获取值</span><br><span class=\"line\">        System.out.println(atomicInteger.incrementAndGet()); // 输出 1</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取并递增值</span><br><span class=\"line\">        System.out.println(atomicInteger.getAndIncrement()); // 输出 1, 但值已变为 2</span><br><span class=\"line\"></span><br><span class=\"line\">        // 比较并设置值</span><br><span class=\"line\">        boolean result = atomicInteger.compareAndSet(2, 5);</span><br><span class=\"line\">        System.out.println(result); // 输出 true，因为当前值是 2</span><br><span class=\"line\">        System.out.println(atomicInteger.get()); // 输出 5</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\" title=\"点击并拖拽以移动\"></p>\n<p>通过 <code>AtomicInteger</code>，你可以避免使用 <code>synchronized</code> 关键字或手动管理锁，简化了多线程操作。</p>\n<p>​</p>\n"},{"title":"java中的代理","date":"2024-12-14T03:43:38.000Z","_content":"\n在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：**静态代理**和**动态代理**。\n\n### 1. **静态代理**\n\n静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。\n\n#### 示例：\n\n```java\n// 目标类\npublic class RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\n// 代理类\npublic class ProxySubject implements Subject {\n    private RealSubject realSubject;\n\n    public ProxySubject(RealSubject realSubject) {\n        this.realSubject = realSubject;\n    }\n\n    @Override\n    public void request() {\n        System.out.println(\"ProxySubject before request.\");\n        realSubject.request();\n        System.out.println(\"ProxySubject after request.\");\n    }\n}\n\n// 接口\npublic interface Subject {\n    void request();\n}\n\n// 使用代理\npublic class Main {\n    public static void main(String[] args) {\n        Subject subject = new ProxySubject(new RealSubject());\n        subject.request();\n    }\n}\n```\n\n输出：\n\n```\nProxySubject before request.\nRealSubject request.\nProxySubject after request.\n```\n\n### 2. **动态代理**\n\n动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 `java.lang.reflect.Proxy` 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。\n\nJava 动态代理需要以下几个组成部分：\n\n- **接口**：被代理的类或接口。\n- **InvocationHandler**：代理类的处理器，实现了 `invoke` 方法，负责代理行为。\n\n#### 示例：\n\n```java\nimport java.lang.reflect.*;\n\ninterface Subject {\n    void request();\n}\n\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\nclass ProxyHandler implements InvocationHandler {\n    private Object target;\n\n    public ProxyHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before invoking \" + method.getName());\n        Object result = method.invoke(target, args);  // 调用真实方法\n        System.out.println(\"After invoking \" + method.getName());\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        RealSubject realSubject = new RealSubject();\n        Subject proxySubject = (Subject) Proxy.newProxyInstance(\n            RealSubject.class.getClassLoader(),\n            new Class[]{Subject.class},\n            new ProxyHandler(realSubject)\n        );\n\n        proxySubject.request();\n    }\n}\n```\n\n输出：\n\n```\nBefore invoking request\nRealSubject request.\nAfter invoking request\n```\n\n### 3. **CGLIB 代理**\n\n除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。\n\n### 4. **代理的应用场景**\n\n- **日志记录**：在方法调用前后记录日志。\n- **性能监控**：在方法调用前后记录时间。\n- **权限控制**：在方法调用前检查用户权限。\n- **缓存**：使用代理实现方法的缓存。\n- **事务管理**：在方法调用前开启事务，调用后提交或回滚事务。\n\n### 总结\n\nJava 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。\n","source":"_posts/java中的代理.md","raw":"---\ntitle: java中的代理\ndate: 2024-12-14 11:43:38\ntags: java基础\ncategories: 八股文\n---\n\n在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：**静态代理**和**动态代理**。\n\n### 1. **静态代理**\n\n静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。\n\n#### 示例：\n\n```java\n// 目标类\npublic class RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\n// 代理类\npublic class ProxySubject implements Subject {\n    private RealSubject realSubject;\n\n    public ProxySubject(RealSubject realSubject) {\n        this.realSubject = realSubject;\n    }\n\n    @Override\n    public void request() {\n        System.out.println(\"ProxySubject before request.\");\n        realSubject.request();\n        System.out.println(\"ProxySubject after request.\");\n    }\n}\n\n// 接口\npublic interface Subject {\n    void request();\n}\n\n// 使用代理\npublic class Main {\n    public static void main(String[] args) {\n        Subject subject = new ProxySubject(new RealSubject());\n        subject.request();\n    }\n}\n```\n\n输出：\n\n```\nProxySubject before request.\nRealSubject request.\nProxySubject after request.\n```\n\n### 2. **动态代理**\n\n动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 `java.lang.reflect.Proxy` 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。\n\nJava 动态代理需要以下几个组成部分：\n\n- **接口**：被代理的类或接口。\n- **InvocationHandler**：代理类的处理器，实现了 `invoke` 方法，负责代理行为。\n\n#### 示例：\n\n```java\nimport java.lang.reflect.*;\n\ninterface Subject {\n    void request();\n}\n\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println(\"RealSubject request.\");\n    }\n}\n\nclass ProxyHandler implements InvocationHandler {\n    private Object target;\n\n    public ProxyHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before invoking \" + method.getName());\n        Object result = method.invoke(target, args);  // 调用真实方法\n        System.out.println(\"After invoking \" + method.getName());\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        RealSubject realSubject = new RealSubject();\n        Subject proxySubject = (Subject) Proxy.newProxyInstance(\n            RealSubject.class.getClassLoader(),\n            new Class[]{Subject.class},\n            new ProxyHandler(realSubject)\n        );\n\n        proxySubject.request();\n    }\n}\n```\n\n输出：\n\n```\nBefore invoking request\nRealSubject request.\nAfter invoking request\n```\n\n### 3. **CGLIB 代理**\n\n除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。\n\n### 4. **代理的应用场景**\n\n- **日志记录**：在方法调用前后记录日志。\n- **性能监控**：在方法调用前后记录时间。\n- **权限控制**：在方法调用前检查用户权限。\n- **缓存**：使用代理实现方法的缓存。\n- **事务管理**：在方法调用前开启事务，调用后提交或回滚事务。\n\n### 总结\n\nJava 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。\n","slug":"java中的代理","published":1,"updated":"2024-12-14T07:50:14.235Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysna300014oa805tdbq1a","content":"<p>在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：<strong>静态代理</strong>和<strong>动态代理</strong>。</p>\n<h3 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. <strong>静态代理</strong></h3><p>静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxySubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealSubject realSubject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxySubject</span><span class=\"params\">(RealSubject realSubject)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.realSubject = realSubject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject before request.&quot;</span>);</span><br><span class=\"line\">        realSubject.request();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject after request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxySubject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>());</span><br><span class=\"line\">        subject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxySubject before request.</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">ProxySubject after request.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. <strong>动态代理</strong></h3><p>动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 <code>java.lang.reflect.Proxy</code> 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。</p>\n<p>Java 动态代理需要以下几个组成部分：</p>\n<ul>\n<li><strong>接口</strong>：被代理的类或接口。</li>\n<li><strong>InvocationHandler</strong>：代理类的处理器，实现了 <code>invoke</code> 方法，负责代理行为。</li>\n</ul>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);  <span class=\"comment\">// 调用真实方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RealSubject</span> <span class=\"variable\">realSubject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>();</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">proxySubject</span> <span class=\"operator\">=</span> (Subject) Proxy.newProxyInstance(</span><br><span class=\"line\">            RealSubject.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;Subject.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyHandler</span>(realSubject)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        proxySubject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before invoking request</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">After invoking request</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-CGLIB-代理\"><a href=\"#3-CGLIB-代理\" class=\"headerlink\" title=\"3. CGLIB 代理\"></a>3. <strong>CGLIB 代理</strong></h3><p>除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。</p>\n<h3 id=\"4-代理的应用场景\"><a href=\"#4-代理的应用场景\" class=\"headerlink\" title=\"4. 代理的应用场景\"></a>4. <strong>代理的应用场景</strong></h3><ul>\n<li><strong>日志记录</strong>：在方法调用前后记录日志。</li>\n<li><strong>性能监控</strong>：在方法调用前后记录时间。</li>\n<li><strong>权限控制</strong>：在方法调用前检查用户权限。</li>\n<li><strong>缓存</strong>：使用代理实现方法的缓存。</li>\n<li><strong>事务管理</strong>：在方法调用前开启事务，调用后提交或回滚事务。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。</p>\n","cover":false,"excerpt":"","more":"<p>在 Java 中，代理（Proxy）是一种设计模式，它允许你通过代理对象来间接访问目标对象。代理对象可以在不改变目标对象代码的情况下，对目标对象进行增强（例如添加日志、权限控制、事务管理等）。Java 提供了两种常见的代理方式：<strong>静态代理</strong>和<strong>动态代理</strong>。</p>\n<h3 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. <strong>静态代理</strong></h3><p>静态代理通过手动创建代理类来实现。代理类通常与目标类实现相同的接口，并在代理类中调用目标类的实际方法。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxySubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealSubject realSubject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxySubject</span><span class=\"params\">(RealSubject realSubject)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.realSubject = realSubject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject before request.&quot;</span>);</span><br><span class=\"line\">        realSubject.request();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ProxySubject after request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProxySubject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>());</span><br><span class=\"line\">        subject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxySubject before request.</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">ProxySubject after request.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. <strong>动态代理</strong></h3><p>动态代理是 Java 的一个特性，允许你在运行时创建代理对象，而不需要明确地创建代理类。Java 提供了 <code>java.lang.reflect.Proxy</code> 类来实现动态代理。动态代理一般用于增强类或接口的功能，常见的场景有 AOP（面向切面编程）和事务管理等。</p>\n<p>Java 动态代理需要以下几个组成部分：</p>\n<ul>\n<li><strong>接口</strong>：被代理的类或接口。</li>\n<li><strong>InvocationHandler</strong>：代理类的处理器，实现了 <code>invoke</code> 方法，负责代理行为。</li>\n</ul>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">request</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealSubject request.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProxyHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);  <span class=\"comment\">// 调用真实方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After invoking &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RealSubject</span> <span class=\"variable\">realSubject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealSubject</span>();</span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">proxySubject</span> <span class=\"operator\">=</span> (Subject) Proxy.newProxyInstance(</span><br><span class=\"line\">            RealSubject.class.getClassLoader(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;Subject.class&#125;,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ProxyHandler</span>(realSubject)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        proxySubject.request();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Before invoking request</span><br><span class=\"line\">RealSubject request.</span><br><span class=\"line\">After invoking request</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-CGLIB-代理\"><a href=\"#3-CGLIB-代理\" class=\"headerlink\" title=\"3. CGLIB 代理\"></a>3. <strong>CGLIB 代理</strong></h3><p>除了 JDK 提供的动态代理外，CGLIB（Code Generation Library）是一种基于继承的代理方式。它不需要目标类实现接口，而是通过继承目标类来生成代理类。CGLIB 通常用于目标类没有实现接口的情况。Spring AOP 就是使用 CGLIB 实现代理的。</p>\n<h3 id=\"4-代理的应用场景\"><a href=\"#4-代理的应用场景\" class=\"headerlink\" title=\"4. 代理的应用场景\"></a>4. <strong>代理的应用场景</strong></h3><ul>\n<li><strong>日志记录</strong>：在方法调用前后记录日志。</li>\n<li><strong>性能监控</strong>：在方法调用前后记录时间。</li>\n<li><strong>权限控制</strong>：在方法调用前检查用户权限。</li>\n<li><strong>缓存</strong>：使用代理实现方法的缓存。</li>\n<li><strong>事务管理</strong>：在方法调用前开启事务，调用后提交或回滚事务。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java 中的代理主要分为静态代理和动态代理，静态代理通过手动编写代理类实现，而动态代理通过反射机制动态生成代理类。动态代理通常用于需要增强功能的场景，如 AOP、权限控制、事务管理等。</p>\n"},{"title":"redo log和undo log","date":"2024-10-15T05:55:26.000Z","_content":"\n# 1.redo log:\n\nRedo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。\n\n## Redo Log 的工作原理：\n\n1. 事务开始：\n   当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。\n\n2. 写入内存：\n   修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。\n\n3. 写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。\n\n4. 数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。\n\n5. 崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。\n\n## Redo Log 的特性：\n\n- 循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。\n\n- 持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。\n\n- 效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。\n  \n  ### Redo Log 与 Binlog 的区别：\n\n- Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。\n\n- Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。\n  通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。\n  \n  # 2.undo log:\n  \n  Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和**多版本并发控制（MVCC）**的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。\n\n## Undo Log 的工作原理：\n\n1. 事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。\n\n2. 回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。\n\n3. 多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。\n\n## Undo Log 的特性：\n\n- 用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。\n\n- 支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。\n\n- 存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。\n\n- 删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。\n\n## Undo Log 与 Redo Log 的区别：\n\n- Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。\n\n- Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。\n  \n  ## Undo Log 的作用：\n1. 回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。\n\n2. 快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。\n\n总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。\n","source":"_posts/redo-log和undo-log.md","raw":"---\ntitle: redo log和undo log\ndate: 2024-10-15 13:55:26\ntags: mysql\ncategories: 八股文\n---\n\n# 1.redo log:\n\nRedo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。\n\n## Redo Log 的工作原理：\n\n1. 事务开始：\n   当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。\n\n2. 写入内存：\n   修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。\n\n3. 写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。\n\n4. 数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。\n\n5. 崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。\n\n## Redo Log 的特性：\n\n- 循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。\n\n- 持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。\n\n- 效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。\n  \n  ### Redo Log 与 Binlog 的区别：\n\n- Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。\n\n- Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。\n  通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。\n  \n  # 2.undo log:\n  \n  Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和**多版本并发控制（MVCC）**的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。\n\n## Undo Log 的工作原理：\n\n1. 事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。\n\n2. 回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。\n\n3. 多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。\n\n## Undo Log 的特性：\n\n- 用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。\n\n- 支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。\n\n- 存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。\n\n- 删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。\n\n## Undo Log 与 Redo Log 的区别：\n\n- Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。\n\n- Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。\n  \n  ## Undo Log 的作用：\n1. 回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。\n\n2. 快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。\n\n总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。\n","slug":"redo-log和undo-log","published":1,"updated":"2024-12-14T09:14:44.312Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysna600044oa8ensf4jqv","content":"<h1 id=\"1-redo-log\"><a href=\"#1-redo-log\" class=\"headerlink\" title=\"1.redo log:\"></a>1.redo log:</h1><p>Redo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。</p>\n<h2 id=\"Redo-Log-的工作原理：\"><a href=\"#Redo-Log-的工作原理：\" class=\"headerlink\" title=\"Redo Log 的工作原理：\"></a>Redo Log 的工作原理：</h2><ol>\n<li><p>事务开始：<br>当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。</p>\n</li>\n<li><p>写入内存：<br>修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。</p>\n</li>\n<li><p>写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。</p>\n</li>\n<li><p>数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。</p>\n</li>\n<li><p>崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。</p>\n</li>\n</ol>\n<h2 id=\"Redo-Log-的特性：\"><a href=\"#Redo-Log-的特性：\" class=\"headerlink\" title=\"Redo Log 的特性：\"></a>Redo Log 的特性：</h2><ul>\n<li><p>循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。</p>\n</li>\n<li><p>持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。</p>\n</li>\n<li><p>效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。</p>\n<h3 id=\"Redo-Log-与-Binlog-的区别：\"><a href=\"#Redo-Log-与-Binlog-的区别：\" class=\"headerlink\" title=\"Redo Log 与 Binlog 的区别：\"></a>Redo Log 与 Binlog 的区别：</h3></li>\n<li><p>Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。</p>\n</li>\n<li><p>Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。<br>通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。</p>\n<h1 id=\"2-undo-log\"><a href=\"#2-undo-log\" class=\"headerlink\" title=\"2.undo log:\"></a>2.undo log:</h1><p>Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和<strong>多版本并发控制（MVCC）</strong>的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-的工作原理：\"><a href=\"#Undo-Log-的工作原理：\" class=\"headerlink\" title=\"Undo Log 的工作原理：\"></a>Undo Log 的工作原理：</h2><ol>\n<li><p>事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。</p>\n</li>\n<li><p>回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。</p>\n</li>\n<li><p>多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。</p>\n</li>\n</ol>\n<h2 id=\"Undo-Log-的特性：\"><a href=\"#Undo-Log-的特性：\" class=\"headerlink\" title=\"Undo Log 的特性：\"></a>Undo Log 的特性：</h2><ul>\n<li><p>用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。</p>\n</li>\n<li><p>支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。</p>\n</li>\n<li><p>存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。</p>\n</li>\n<li><p>删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-与-Redo-Log-的区别：\"><a href=\"#Undo-Log-与-Redo-Log-的区别：\" class=\"headerlink\" title=\"Undo Log 与 Redo Log 的区别：\"></a>Undo Log 与 Redo Log 的区别：</h2><ul>\n<li><p>Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。</p>\n</li>\n<li><p>Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。</p>\n<h2 id=\"Undo-Log-的作用：\"><a href=\"#Undo-Log-的作用：\" class=\"headerlink\" title=\"Undo Log 的作用：\"></a>Undo Log 的作用：</h2></li>\n</ul>\n<ol>\n<li><p>回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。</p>\n</li>\n<li><p>快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。</p>\n</li>\n</ol>\n<p>总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"1-redo-log\"><a href=\"#1-redo-log\" class=\"headerlink\" title=\"1.redo log:\"></a>1.redo log:</h1><p>Redo Log 是数据库系统（尤其是 MySQL 的 InnoDB 存储引擎）中用于实现事务持久性的重要机制。它记录了事务对数据库所做的修改，确保即使数据库发生崩溃，事务的提交仍然不会丢失。</p>\n<h2 id=\"Redo-Log-的工作原理：\"><a href=\"#Redo-Log-的工作原理：\" class=\"headerlink\" title=\"Redo Log 的工作原理：\"></a>Redo Log 的工作原理：</h2><ol>\n<li><p>事务开始：<br>当事务执行开始时，任何对数据的修改都会先写入 redo log，而不是直接写入磁盘中的数据页。</p>\n</li>\n<li><p>写入内存：<br>修改的数据首先会写入内存中的缓冲池，并在内存中更新数据页，同时记录这次修改的操作到 redo log 缓冲区中。</p>\n</li>\n<li><p>写入磁盘：事务提交时，InnoDB 会将 redo log 缓冲区的内容持久化到磁盘中的 redo log 文件中（即“预写日志”原则，WAL，Write-Ahead Logging），确保即使系统崩溃，仍可以通过 redo log 恢复事务。</p>\n</li>\n<li><p>数据刷入磁盘：数据页的实际刷盘操作（即将内存中的数据页持久化到磁盘）并不需要立刻完成，数据库可以延迟将数据刷入磁盘。这意味着 redo log 能够保证数据的完整性，即使数据页还没有完全写入磁盘。</p>\n</li>\n<li><p>崩溃恢复：如果数据库发生故障，InnoDB 会在重启时通过 redo log 进行崩溃恢复。它会根据 redo log 的内容，重做所有已提交但尚未写入磁盘的数据修改，确保数据的一致性。</p>\n</li>\n</ol>\n<h2 id=\"Redo-Log-的特性：\"><a href=\"#Redo-Log-的特性：\" class=\"headerlink\" title=\"Redo Log 的特性：\"></a>Redo Log 的特性：</h2><ul>\n<li><p>循环写：InnoDB 使用的是固定大小的 redo log 文件，它们组成一个循环日志（circular log）。当写满后，会回头覆盖最早的日志。</p>\n</li>\n<li><p>持久性保证：通过 redo log 机制，即使数据库出现崩溃，已提交的事务也能在重启时得到恢复。</p>\n</li>\n<li><p>效率提升：因为 redo log 是顺序写入的操作，相比随机写磁盘效率更高。</p>\n<h3 id=\"Redo-Log-与-Binlog-的区别：\"><a href=\"#Redo-Log-与-Binlog-的区别：\" class=\"headerlink\" title=\"Redo Log 与 Binlog 的区别：\"></a>Redo Log 与 Binlog 的区别：</h3></li>\n<li><p>Redo Log：由存储引擎（如 InnoDB）生成，记录数据的物理修改，用于崩溃恢复。</p>\n</li>\n<li><p>Binlog：由 MySQL Server 生成，记录逻辑 SQL 操作，用于主从复制和数据库恢复。<br>通过 redo log，数据库能够实现事务的持久性（Durability），即使在意外中断或崩溃的情况下，已提交的事务仍能被恢复。</p>\n<h1 id=\"2-undo-log\"><a href=\"#2-undo-log\" class=\"headerlink\" title=\"2.undo log:\"></a>2.undo log:</h1><p>Undo Log 是数据库系统（如 MySQL 的 InnoDB 存储引擎）中用于实现事务回滚和<strong>多版本并发控制（MVCC）</strong>的重要机制。它记录了事务在执行过程中所做的修改之前的数据快照，从而支持事务的回滚以及提供一致的读视图。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-的工作原理：\"><a href=\"#Undo-Log-的工作原理：\" class=\"headerlink\" title=\"Undo Log 的工作原理：\"></a>Undo Log 的工作原理：</h2><ol>\n<li><p>事务开始：当事务修改数据时，InnoDB 会将修改前的旧数据（即原始数据）记录到 Undo Log 中，以便在事务回滚时恢复原始状态。</p>\n</li>\n<li><p>回滚操作：如果事务执行过程中发生错误或主动执行回滚操作，数据库会使用 Undo Log 将数据恢复到修改前的状态，从而撤销事务对数据库的影响。</p>\n</li>\n<li><p>多版本并发控制（MVCC）：在并发控制中，未提交的事务会对数据进行修改，而其他事务需要读取一致的数据快照。在这种情况下，数据库可以通过 Undo Log 提供修改前的数据版本，从而实现快照读，避免读取到未提交的数据。这样，事务可以在不加锁的情况下，读到一致性视图的数据。</p>\n</li>\n</ol>\n<h2 id=\"Undo-Log-的特性：\"><a href=\"#Undo-Log-的特性：\" class=\"headerlink\" title=\"Undo Log 的特性：\"></a>Undo Log 的特性：</h2><ul>\n<li><p>用于回滚：Undo Log 保存的是事务修改前的旧值，因此可以在回滚时使用这些旧值恢复数据库原来的状态。无论事务是主动回滚还是由于系统故障引发的回滚，Undo Log 都能确保数据恢复到事务之前的状态。</p>\n</li>\n<li><p>支持 MVCC：多版本并发控制（MVCC）依赖 Undo Log 机制来维护多个数据版本。通过 Undo Log，数据库可以为不同的事务提供不同的历史版本数据，从而实现非阻塞读操作。</p>\n</li>\n<li><p>存储方式：Undo Log 记录的数据并不会直接存储在独立的文件中，而是存放在系统表空间（System Tablespace）或者独立的 undo 表空间中。</p>\n</li>\n<li><p>删除延迟：当事务修改数据并提交时，这些修改可能会覆盖旧数据。然而，数据库并不会立即删除 Undo Log，特别是在有其他事务依赖这些旧版本数据时。只有当没有事务需要使用旧版本数据时，Undo Log 才会被回收。</p>\n</li>\n</ul>\n<h2 id=\"Undo-Log-与-Redo-Log-的区别：\"><a href=\"#Undo-Log-与-Redo-Log-的区别：\" class=\"headerlink\" title=\"Undo Log 与 Redo Log 的区别：\"></a>Undo Log 与 Redo Log 的区别：</h2><ul>\n<li><p>Undo Log：记录的是事务修改之前的数据，用于支持事务回滚和 MVCC。</p>\n</li>\n<li><p>Redo Log：记录的是事务修改后的数据，用于崩溃恢复和持久化。</p>\n<h2 id=\"Undo-Log-的作用：\"><a href=\"#Undo-Log-的作用：\" class=\"headerlink\" title=\"Undo Log 的作用：\"></a>Undo Log 的作用：</h2></li>\n</ul>\n<ol>\n<li><p>回滚事务：当事务发生错误或中断时，Undo Log 用于撤销事务的所有修改，确保数据库的一致性。</p>\n</li>\n<li><p>快照读（Snapshot Read）：在 MVCC 中，数据库使用 Undo Log 提供历史数据的快照，确保读操作不受其他未提交事务的影响，实现一致性读。</p>\n</li>\n</ol>\n<p>总之，Undo Log 在数据库中主要用于提供事务的回滚能力和支持一致性读，尤其在并发场景下，通过 Undo Log 保持数据的多个版本，使得事务在读写时能够相互独立，提高了并发性能。</p>\n"},{"title":"redis淘汰策略","date":"2024-10-15T06:20:22.000Z","_content":"\n在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n### 1. Redis 支持的淘汰策略\n\n- **noeviction**：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n- **allkeys-lru**：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n- **volatile-lru**：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n- **allkeys-random**：对所有的键随机淘汰。\n- **volatile-random**：只对设置了过期时间的键随机淘汰。\n- **volatile-ttl**：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n\n#### Redis 4.0 之后新增的策略\n\n- **allkeys-lfu**：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n- **volatile-lfu**：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n\n### 2. 配置 Redis 缓存淘汰策略\n\nRedis 的淘汰策略可以通过修改配置文件 `redis.conf` 或运行时使用命令行配置。\n\n#### 配置方式一：修改 `redis.conf`\n\n找到 Redis 配置文件 `redis.conf`，修改 `maxmemory-policy` 来设置淘汰策略。例如：\n\n```bash\nmaxmemory-policy allkeys-lru\n```\n\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\n```bash\nmaxmemory 256mb\n```\n\n#### 配置方式二：运行时设置\n\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\n```bash\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\n### 3. TTL（过期时间）实现\n\nRedis 提供了两种设置过期时间的方法：\n\n- `EXPIRE key seconds`：为键设置一个存活时间（秒），过期后自动删除。\n- `SET key value EX seconds`：在设置键的同时指定过期时间（秒）。\n\n#### 示例：\n\n```bash\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n```\n\n### 4. Redis LRU 实现机制\n\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 `maxmemory-samples` 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n#### 示例：\n\n在配置文件中设置采样数：\n\n```bash\nmaxmemory-samples 10\n```\n\n运行时设置：\n\n```bash\nCONFIG SET maxmemory-samples 10\n```\n\n### 5. Redis 缓存淘汰策略实战\n\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n1. **设置 Redis 的最大内存和 LRU 策略**：\n   \n   ```bash\n   CONFIG SET maxmemory 128mb\n   CONFIG SET maxmemory-policy allkeys-lru\n   ```\n\n2. **向 Redis 写入会话数据，并设置过期时间**：\n   \n   ```bash\n   SET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\n   SET session:user:1002 \"session_data\" EX 3600\n   ```\n\n3. **监控淘汰情况**：\n    当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n### 总结\n\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 `volatile-lru` 或 `volatile-ttl`，而如果没有过期时间且想控制整体缓存大小，可以选择 `allkeys-lru` 或 `allkeys-random`。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n1. Redis 支持的淘汰策略\n   noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n   allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n   volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n   allkeys-random：对所有的键随机淘汰。\n   volatile-random：只对设置了过期时间的键随机淘汰。\n   volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n   Redis 4.0 之后新增的策略\n   allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n   volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n2. 配置 Redis 缓存淘汰策略\n   Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。\n\n配置方式一：修改 redis.conf\n找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：\n\nmaxmemory-policy allkeys-lru\n1\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\nmaxmemory 256mb\n1\n配置方式二：运行时设置\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n3. TTL（过期时间）实现\nRedis 提供了两种设置过期时间的方法：\n\nEXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。\nSET key value EX seconds：在设置键的同时指定过期时间（秒）。\n示例：\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n1\n2\n4. Redis LRU 实现机制\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n示例：\n在配置文件中设置采样数：\n\nmaxmemory-samples 10\n1\n运行时设置：\n\nCONFIG SET maxmemory-samples 10\n1\n5. Redis 缓存淘汰策略实战\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n设置 Redis 的最大内存和 LRU 策略：\n\nCONFIG SET maxmemory 128mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n向 Redis 写入会话数据，并设置过期时间：\n\nSET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\nSET session:user:1002 \"session_data\" EX 3600\n1\n2\n监控淘汰情况：\n当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n总结\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。\n","source":"_posts/redis淘汰策略.md","raw":"---\ntitle: redis淘汰策略\ndate: 2024-10-15 14:20:22\ntags: redis\ncategories: 八股文\n---\n\n在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n### 1. Redis 支持的淘汰策略\n\n- **noeviction**：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n- **allkeys-lru**：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n- **volatile-lru**：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n- **allkeys-random**：对所有的键随机淘汰。\n- **volatile-random**：只对设置了过期时间的键随机淘汰。\n- **volatile-ttl**：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n\n#### Redis 4.0 之后新增的策略\n\n- **allkeys-lfu**：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n- **volatile-lfu**：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n\n### 2. 配置 Redis 缓存淘汰策略\n\nRedis 的淘汰策略可以通过修改配置文件 `redis.conf` 或运行时使用命令行配置。\n\n#### 配置方式一：修改 `redis.conf`\n\n找到 Redis 配置文件 `redis.conf`，修改 `maxmemory-policy` 来设置淘汰策略。例如：\n\n```bash\nmaxmemory-policy allkeys-lru\n```\n\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\n```bash\nmaxmemory 256mb\n```\n\n#### 配置方式二：运行时设置\n\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\n```bash\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n```\n\n### 3. TTL（过期时间）实现\n\nRedis 提供了两种设置过期时间的方法：\n\n- `EXPIRE key seconds`：为键设置一个存活时间（秒），过期后自动删除。\n- `SET key value EX seconds`：在设置键的同时指定过期时间（秒）。\n\n#### 示例：\n\n```bash\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n```\n\n### 4. Redis LRU 实现机制\n\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 `maxmemory-samples` 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n#### 示例：\n\n在配置文件中设置采样数：\n\n```bash\nmaxmemory-samples 10\n```\n\n运行时设置：\n\n```bash\nCONFIG SET maxmemory-samples 10\n```\n\n### 5. Redis 缓存淘汰策略实战\n\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n1. **设置 Redis 的最大内存和 LRU 策略**：\n   \n   ```bash\n   CONFIG SET maxmemory 128mb\n   CONFIG SET maxmemory-policy allkeys-lru\n   ```\n\n2. **向 Redis 写入会话数据，并设置过期时间**：\n   \n   ```bash\n   SET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\n   SET session:user:1002 \"session_data\" EX 3600\n   ```\n\n3. **监控淘汰情况**：\n    当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n### 总结\n\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 `volatile-lru` 或 `volatile-ttl`，而如果没有过期时间且想控制整体缓存大小，可以选择 `allkeys-lru` 或 `allkeys-random`。\n\nRedis 中的主要缓存淘汰策略有以下几种：\n\n1. Redis 支持的淘汰策略\n   noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。\n   allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。\n   volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。\n   allkeys-random：对所有的键随机淘汰。\n   volatile-random：只对设置了过期时间的键随机淘汰。\n   volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。\n   Redis 4.0 之后新增的策略\n   allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。\n   volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。\n2. 配置 Redis 缓存淘汰策略\n   Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。\n\n配置方式一：修改 redis.conf\n找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：\n\nmaxmemory-policy allkeys-lru\n1\n此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：\n\nmaxmemory 256mb\n1\n配置方式二：运行时设置\n你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：\n\nCONFIG SET maxmemory 256mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n3. TTL（过期时间）实现\nRedis 提供了两种设置过期时间的方法：\n\nEXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。\nSET key value EX seconds：在设置键的同时指定过期时间（秒）。\n示例：\nSET user:1001 \"John\" EX 60  # 设置 key 为 user:1001，60秒后过期\nEXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间\n1\n2\n4. Redis LRU 实现机制\nRedis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。\n\n示例：\n在配置文件中设置采样数：\n\nmaxmemory-samples 10\n1\n运行时设置：\n\nCONFIG SET maxmemory-samples 10\n1\n5. Redis 缓存淘汰策略实战\n假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：\n\n设置 Redis 的最大内存和 LRU 策略：\n\nCONFIG SET maxmemory 128mb\nCONFIG SET maxmemory-policy allkeys-lru\n1\n2\n向 Redis 写入会话数据，并设置过期时间：\n\nSET session:user:1001 \"session_data\" EX 3600  # 会话信息1小时过期\nSET session:user:1002 \"session_data\" EX 3600\n1\n2\n监控淘汰情况：\n当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。\n\n总结\n在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。\n","slug":"redis淘汰策略","published":1,"updated":"2024-12-14T09:14:20.682Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysna700054oa8f0f999hw","content":"<p>在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<h3 id=\"1-Redis-支持的淘汰策略\"><a href=\"#1-Redis-支持的淘汰策略\" class=\"headerlink\" title=\"1. Redis 支持的淘汰策略\"></a>1. Redis 支持的淘汰策略</h3><ul>\n<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。</li>\n<li><strong>allkeys-lru</strong>：对所有的键使用 LRU（最近最少使用）算法进行淘汰。</li>\n<li><strong>volatile-lru</strong>：只对设置了过期时间的键使用 LRU 算法进行淘汰。</li>\n<li><strong>allkeys-random</strong>：对所有的键随机淘汰。</li>\n<li><strong>volatile-random</strong>：只对设置了过期时间的键随机淘汰。</li>\n<li><strong>volatile-ttl</strong>：只对设置了过期时间的键，选择即将过期的键进行淘汰。</li>\n</ul>\n<h4 id=\"Redis-4-0-之后新增的策略\"><a href=\"#Redis-4-0-之后新增的策略\" class=\"headerlink\" title=\"Redis 4.0 之后新增的策略\"></a>Redis 4.0 之后新增的策略</h4><ul>\n<li><strong>allkeys-lfu</strong>：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。</li>\n<li><strong>volatile-lfu</strong>：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n</ul>\n<h3 id=\"2-配置-Redis-缓存淘汰策略\"><a href=\"#2-配置-Redis-缓存淘汰策略\" class=\"headerlink\" title=\"2. 配置 Redis 缓存淘汰策略\"></a>2. 配置 Redis 缓存淘汰策略</h3><p>Redis 的淘汰策略可以通过修改配置文件 <code>redis.conf</code> 或运行时使用命令行配置。</p>\n<h4 id=\"配置方式一：修改-redis-conf\"><a href=\"#配置方式一：修改-redis-conf\" class=\"headerlink\" title=\"配置方式一：修改 redis.conf\"></a>配置方式一：修改 <code>redis.conf</code></h4><p>找到 Redis 配置文件 <code>redis.conf</code>，修改 <code>maxmemory-policy</code> 来设置淘汰策略。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<p>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory 256mb</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置方式二：运行时设置\"><a href=\"#配置方式二：运行时设置\" class=\"headerlink\" title=\"配置方式二：运行时设置\"></a>配置方式二：运行时设置</h4><p>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 256mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-TTL（过期时间）实现\"><a href=\"#3-TTL（过期时间）实现\" class=\"headerlink\" title=\"3. TTL（过期时间）实现\"></a>3. TTL（过期时间）实现</h3><p>Redis 提供了两种设置过期时间的方法：</p>\n<ul>\n<li><code>EXPIRE key seconds</code>：为键设置一个存活时间（秒），过期后自动删除。</li>\n<li><code>SET key value EX seconds</code>：在设置键的同时指定过期时间（秒）。</li>\n</ul>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET user:1001 <span class=\"string\">&quot;John&quot;</span> EX 60  <span class=\"comment\"># 设置 key 为 user:1001，60秒后过期</span></span><br><span class=\"line\">EXPIRE user:1002 120         <span class=\"comment\"># 为现有 key user:1002 设置120秒的过期时间</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Redis-LRU-实现机制\"><a href=\"#4-Redis-LRU-实现机制\" class=\"headerlink\" title=\"4. Redis LRU 实现机制\"></a>4. Redis LRU 实现机制</h3><p>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 <code>maxmemory-samples</code> 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><p>在配置文件中设置采样数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<p>运行时设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Redis-缓存淘汰策略实战\"><a href=\"#5-Redis-缓存淘汰策略实战\" class=\"headerlink\" title=\"5. Redis 缓存淘汰策略实战\"></a>5. Redis 缓存淘汰策略实战</h3><p>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<ol>\n<li><p><strong>设置 Redis 的最大内存和 LRU 策略</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 128mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>向 Redis 写入会话数据，并设置过期时间</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET session:user:1001 <span class=\"string\">&quot;session_data&quot;</span> EX 3600  <span class=\"comment\"># 会话信息1小时过期</span></span><br><span class=\"line\">SET session:user:1002 <span class=\"string\">&quot;session_data&quot;</span> EX 3600</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>监控淘汰情况</strong>：<br> 当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 <code>volatile-lru</code> 或 <code>volatile-ttl</code>，而如果没有过期时间且想控制整体缓存大小，可以选择 <code>allkeys-lru</code> 或 <code>allkeys-random</code>。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<ol>\n<li>Redis 支持的淘汰策略<br>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。<br>allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。<br>volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。<br>allkeys-random：对所有的键随机淘汰。<br>volatile-random：只对设置了过期时间的键随机淘汰。<br>volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。<br>Redis 4.0 之后新增的策略<br>allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。<br>volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n<li>配置 Redis 缓存淘汰策略<br>Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。</li>\n</ol>\n<p>配置方式一：修改 redis.conf<br>找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：</p>\n<p>maxmemory-policy allkeys-lru<br>1<br>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<p>maxmemory 256mb<br>1<br>配置方式二：运行时设置<br>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<p>CONFIG SET maxmemory 256mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>3. TTL（过期时间）实现<br>Redis 提供了两种设置过期时间的方法：</p>\n<p>EXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。<br>SET key value EX seconds：在设置键的同时指定过期时间（秒）。<br>示例：<br>SET user:1001 “John” EX 60  # 设置 key 为 user:1001，60秒后过期<br>EXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间<br>1<br>2<br>4. Redis LRU 实现机制<br>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<p>示例：<br>在配置文件中设置采样数：</p>\n<p>maxmemory-samples 10<br>1<br>运行时设置：</p>\n<p>CONFIG SET maxmemory-samples 10<br>1<br>5. Redis 缓存淘汰策略实战<br>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<p>设置 Redis 的最大内存和 LRU 策略：</p>\n<p>CONFIG SET maxmemory 128mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>向 Redis 写入会话数据，并设置过期时间：</p>\n<p>SET session:user:1001 “session_data” EX 3600  # 会话信息1小时过期<br>SET session:user:1002 “session_data” EX 3600<br>1<br>2<br>监控淘汰情况：<br>当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n<p>总结<br>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。</p>\n","cover":false,"excerpt":"","more":"<p>在 Redis 中，缓存淘汰策略是内置的，用户可以通过配置来选择合适的策略。Redis 提供多种缓存淘汰策略，主要用于内存限制时控制数据的自动过期或删除。当 Redis 内存达到指定的上限时，会根据配置的策略自动淘汰一些数据。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<h3 id=\"1-Redis-支持的淘汰策略\"><a href=\"#1-Redis-支持的淘汰策略\" class=\"headerlink\" title=\"1. Redis 支持的淘汰策略\"></a>1. Redis 支持的淘汰策略</h3><ul>\n<li><strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。</li>\n<li><strong>allkeys-lru</strong>：对所有的键使用 LRU（最近最少使用）算法进行淘汰。</li>\n<li><strong>volatile-lru</strong>：只对设置了过期时间的键使用 LRU 算法进行淘汰。</li>\n<li><strong>allkeys-random</strong>：对所有的键随机淘汰。</li>\n<li><strong>volatile-random</strong>：只对设置了过期时间的键随机淘汰。</li>\n<li><strong>volatile-ttl</strong>：只对设置了过期时间的键，选择即将过期的键进行淘汰。</li>\n</ul>\n<h4 id=\"Redis-4-0-之后新增的策略\"><a href=\"#Redis-4-0-之后新增的策略\" class=\"headerlink\" title=\"Redis 4.0 之后新增的策略\"></a>Redis 4.0 之后新增的策略</h4><ul>\n<li><strong>allkeys-lfu</strong>：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。</li>\n<li><strong>volatile-lfu</strong>：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n</ul>\n<h3 id=\"2-配置-Redis-缓存淘汰策略\"><a href=\"#2-配置-Redis-缓存淘汰策略\" class=\"headerlink\" title=\"2. 配置 Redis 缓存淘汰策略\"></a>2. 配置 Redis 缓存淘汰策略</h3><p>Redis 的淘汰策略可以通过修改配置文件 <code>redis.conf</code> 或运行时使用命令行配置。</p>\n<h4 id=\"配置方式一：修改-redis-conf\"><a href=\"#配置方式一：修改-redis-conf\" class=\"headerlink\" title=\"配置方式一：修改 redis.conf\"></a>配置方式一：修改 <code>redis.conf</code></h4><p>找到 Redis 配置文件 <code>redis.conf</code>，修改 <code>maxmemory-policy</code> 来设置淘汰策略。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<p>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory 256mb</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置方式二：运行时设置\"><a href=\"#配置方式二：运行时设置\" class=\"headerlink\" title=\"配置方式二：运行时设置\"></a>配置方式二：运行时设置</h4><p>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 256mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-TTL（过期时间）实现\"><a href=\"#3-TTL（过期时间）实现\" class=\"headerlink\" title=\"3. TTL（过期时间）实现\"></a>3. TTL（过期时间）实现</h3><p>Redis 提供了两种设置过期时间的方法：</p>\n<ul>\n<li><code>EXPIRE key seconds</code>：为键设置一个存活时间（秒），过期后自动删除。</li>\n<li><code>SET key value EX seconds</code>：在设置键的同时指定过期时间（秒）。</li>\n</ul>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET user:1001 <span class=\"string\">&quot;John&quot;</span> EX 60  <span class=\"comment\"># 设置 key 为 user:1001，60秒后过期</span></span><br><span class=\"line\">EXPIRE user:1002 120         <span class=\"comment\"># 为现有 key user:1002 设置120秒的过期时间</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Redis-LRU-实现机制\"><a href=\"#4-Redis-LRU-实现机制\" class=\"headerlink\" title=\"4. Redis LRU 实现机制\"></a>4. Redis LRU 实现机制</h3><p>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 <code>maxmemory-samples</code> 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<h4 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><p>在配置文件中设置采样数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<p>运行时设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory-samples 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Redis-缓存淘汰策略实战\"><a href=\"#5-Redis-缓存淘汰策略实战\" class=\"headerlink\" title=\"5. Redis 缓存淘汰策略实战\"></a>5. Redis 缓存淘汰策略实战</h3><p>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<ol>\n<li><p><strong>设置 Redis 的最大内存和 LRU 策略</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG SET maxmemory 128mb</span><br><span class=\"line\">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>向 Redis 写入会话数据，并设置过期时间</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET session:user:1001 <span class=\"string\">&quot;session_data&quot;</span> EX 3600  <span class=\"comment\"># 会话信息1小时过期</span></span><br><span class=\"line\">SET session:user:1002 <span class=\"string\">&quot;session_data&quot;</span> EX 3600</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>监控淘汰情况</strong>：<br> 当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 <code>volatile-lru</code> 或 <code>volatile-ttl</code>，而如果没有过期时间且想控制整体缓存大小，可以选择 <code>allkeys-lru</code> 或 <code>allkeys-random</code>。</p>\n<p>Redis 中的主要缓存淘汰策略有以下几种：</p>\n<ol>\n<li>Redis 支持的淘汰策略<br>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。这是 Redis 默认策略，适用于不希望数据被自动淘汰的场景。<br>allkeys-lru：对所有的键使用 LRU（最近最少使用）算法进行淘汰。<br>volatile-lru：只对设置了过期时间的键使用 LRU 算法进行淘汰。<br>allkeys-random：对所有的键随机淘汰。<br>volatile-random：只对设置了过期时间的键随机淘汰。<br>volatile-ttl：只对设置了过期时间的键，选择即将过期的键进行淘汰。<br>Redis 4.0 之后新增的策略<br>allkeys-lfu：对所有键使用 LFU 算法进行淘汰，淘汰最少使用的键。<br>volatile-lfu：只对设置了过期时间的键使用 LFU 算法进行淘汰。</li>\n<li>配置 Redis 缓存淘汰策略<br>Redis 的淘汰策略可以通过修改配置文件 redis.conf 或运行时使用命令行配置。</li>\n</ol>\n<p>配置方式一：修改 redis.conf<br>找到 Redis 配置文件 redis.conf，修改 maxmemory-policy 来设置淘汰策略。例如：</p>\n<p>maxmemory-policy allkeys-lru<br>1<br>此外，可以设置 Redis 的最大内存使用量，超过该内存时 Redis 将开始执行淘汰策略：</p>\n<p>maxmemory 256mb<br>1<br>配置方式二：运行时设置<br>你可以通过 Redis CLI 动态设置淘汰策略和最大内存使用。执行以下命令：</p>\n<p>CONFIG SET maxmemory 256mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>3. TTL（过期时间）实现<br>Redis 提供了两种设置过期时间的方法：</p>\n<p>EXPIRE key seconds：为键设置一个存活时间（秒），过期后自动删除。<br>SET key value EX seconds：在设置键的同时指定过期时间（秒）。<br>示例：<br>SET user:1001 “John” EX 60  # 设置 key 为 user:1001，60秒后过期<br>EXPIRE user:1002 120         # 为现有 key user:1002 设置120秒的过期时间<br>1<br>2<br>4. Redis LRU 实现机制<br>Redis 的 LRU 并不是严格精确的 LRU，它使用了近似算法。默认情况下，Redis 通过采样的方式（默认采样 5 个键）来判断最近最少使用的键进行淘汰。你可以通过调整 maxmemory-samples 参数来控制采样数，采样数越大，LRU 越准确，但性能也会受到一定影响。</p>\n<p>示例：<br>在配置文件中设置采样数：</p>\n<p>maxmemory-samples 10<br>1<br>运行时设置：</p>\n<p>CONFIG SET maxmemory-samples 10<br>1<br>5. Redis 缓存淘汰策略实战<br>假设我们有一个 Redis 实例，用来缓存用户的会话信息，并且只想缓存最新活跃的会话用户，同时确保 Redis 的内存不会超过 128MB，并使用 LRU 算法淘汰不活跃的会话：</p>\n<p>设置 Redis 的最大内存和 LRU 策略：</p>\n<p>CONFIG SET maxmemory 128mb<br>CONFIG SET maxmemory-policy allkeys-lru<br>1<br>2<br>向 Redis 写入会话数据，并设置过期时间：</p>\n<p>SET session:user:1001 “session_data” EX 3600  # 会话信息1小时过期<br>SET session:user:1002 “session_data” EX 3600<br>1<br>2<br>监控淘汰情况：<br>当 Redis 内存达到 128MB 时，Redis 将根据 LRU 算法自动淘汰最近最少使用的会话数据，以腾出空间。</p>\n<p>总结<br>在 Redis 中，缓存淘汰策略已经内置并且可以通过简单配置来启用。在选择合适的策略时，应该结合业务场景，例如如果业务中所有键都有过期时间，可以选择 volatile-lru 或 volatile-ttl，而如果没有过期时间且想控制整体缓存大小，可以选择 allkeys-lru 或 allkeys-random。</p>\n"},{"title":"mysql数据库索引分类及其底层数据结构","date":"2024-10-15T06:17:49.000Z","catigories":"八股文","_content":"\n数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：\n\n## 一、数据库索引的分类\n\n### 1. **主键索引（Primary Key Index）**\n\n- **分类**：唯一性索引的一种特殊形式。\n- **特点**：对主键列创建的索引，保证唯一性且不能为空。\n- **底层结构**：B+树。\n\n### 2. **唯一索引（Unique Index）**\n\n- **分类**：确保列中的值唯一，但可以包含空值。\n- **特点**：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。\n- **底层结构**：B+树。\n\n### 3. **普通索引（Non-Unique Index）**\n\n- **分类**：不对列的唯一性做要求，最常见的索引类型。\n- **特点**：支持常规的查询加速，允许重复值。\n- **底层结构**：B+树。\n\n### 4. **复合索引（Composite Index）**\n\n- **分类**：在多个列上创建的索引。\n- **特点**：按指定列顺序建立，遵循“最左前缀原则”。\n- **底层结构**：B+树。\n\n### 5. **全文索引（Full-Text Index）**\n\n- **分类**：专门用于大文本字段搜索的索引。\n- **特点**：基于分词进行全文检索，支持复杂的文本查询。\n- **底层结构**：倒排索引（Inverted Index）。\n\n### 6. **空间索引（Spatial Index）**\n\n- **分类**：用于地理空间数据（如坐标、地图位置）的索引。\n- **特点**：支持多维数据的范围查询。\n- **底层结构**：R树（R-Tree）。\n\n### 7. **聚集索引（Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序一致的索引。\n- **特点**：通常用于主键索引，每个表只能有一个聚集索引。\n- **底层结构**：B+树。\n\n### 8. **非聚集索引（Non-Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序无关的索引。\n- **特点**：每个表可以有多个非聚集索引，独立于数据存储。\n- **底层结构**：B+树。\n\n### 9. **哈希索引（Hash Index）**\n\n- **分类**：基于哈希函数的索引。\n- **特点**：等值查询效率极高，但不支持范围查询。\n- **底层结构**：哈希表。\n\n### 10. **位图索引（Bitmap Index）**\n\n- **分类**：通过位图表示数据的索引。\n- **特点**：适合低基数列，适用于组合查询，但不适合频繁更新的场景。\n- **底层结构**：位图（Bitmap）。\n\n---\n\n## 二、数据库索引的底层数据结构\n\n### 1. **B+树（B+ Tree）**\n\n- **用途**：最常用于主键索引、唯一索引、普通索引和复合索引。\n- **结构特点**：\n  - **多路平衡树**：节点包含多个键值，树高度低，磁盘I/O次数少。\n  - **叶子节点链表**：所有数据存储在叶子节点，并通过链表连接，支持范围查询。\n  - **顺序访问效率高**：适合范围查询和排序操作。\n\n### 2. **哈希表（Hash Table）**\n\n- **用途**：用于哈希索引，主要针对等值查询场景。\n- **结构特点**：\n  - **哈希函数映射**：通过哈希函数将键值映射到哈希表中的桶（bucket）。\n  - **不支持范围查询**：哈希表只能快速处理等值查询，对于范围查询无效。\n\n### 3. **倒排索引（Inverted Index）**\n\n- **用途**：主要用于全文索引。\n- **结构特点**：\n  - **关键词映射**：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。\n  - **分词处理**：适用于大文本数据，通过词语的匹配加速查询。\n  - **高效全文搜索**：特别适合搜索引擎和文本数据中的关键词查找。\n\n### 4. **R树（R-Tree）**\n\n- **用途**：用于空间索引，主要处理二维或多维的空间数据。\n- **结构特点**：\n  - **范围查询**：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。\n  - **分层结构**：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。\n\n### 5. **位图（Bitmap）**\n\n- **用途**：主要用于位图索引，适用于低基数（如性别、状态等）的列。\n- **结构特点**：\n  - **位数组表示**：使用位数组来表示数据的位置，适合数据重复较多的场景。\n  - **组合查询高效**：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。\n  - **不适合频繁更新**：因为每次修改需要更新整个位图，频繁更新时效率较低。\n\n### 6. **跳表（Skip List）**\n\n- **用途**：Redis等轻量级存储中常用的索引结构。\n- **结构特点**：\n  - **多层链表结构**：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。\n  - **范围查询**：跳表支持快速的范围查找，且实现简单。\n\n---\n\n### 三、总结\n\n1. **常见索引结构**：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。\n2. **其他结构**：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。\n3. **性能权衡**：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。\n","source":"_posts/mysql数据库索引分类及其底层数据结构.md","raw":"---\ntitle: mysql数据库索引分类及其底层数据结构\ndate: 2024-10-15 14:17:49\ntags: mysql\ncatigories: 八股文\n---\n\n数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：\n\n## 一、数据库索引的分类\n\n### 1. **主键索引（Primary Key Index）**\n\n- **分类**：唯一性索引的一种特殊形式。\n- **特点**：对主键列创建的索引，保证唯一性且不能为空。\n- **底层结构**：B+树。\n\n### 2. **唯一索引（Unique Index）**\n\n- **分类**：确保列中的值唯一，但可以包含空值。\n- **特点**：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。\n- **底层结构**：B+树。\n\n### 3. **普通索引（Non-Unique Index）**\n\n- **分类**：不对列的唯一性做要求，最常见的索引类型。\n- **特点**：支持常规的查询加速，允许重复值。\n- **底层结构**：B+树。\n\n### 4. **复合索引（Composite Index）**\n\n- **分类**：在多个列上创建的索引。\n- **特点**：按指定列顺序建立，遵循“最左前缀原则”。\n- **底层结构**：B+树。\n\n### 5. **全文索引（Full-Text Index）**\n\n- **分类**：专门用于大文本字段搜索的索引。\n- **特点**：基于分词进行全文检索，支持复杂的文本查询。\n- **底层结构**：倒排索引（Inverted Index）。\n\n### 6. **空间索引（Spatial Index）**\n\n- **分类**：用于地理空间数据（如坐标、地图位置）的索引。\n- **特点**：支持多维数据的范围查询。\n- **底层结构**：R树（R-Tree）。\n\n### 7. **聚集索引（Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序一致的索引。\n- **特点**：通常用于主键索引，每个表只能有一个聚集索引。\n- **底层结构**：B+树。\n\n### 8. **非聚集索引（Non-Clustered Index）**\n\n- **分类**：索引顺序与物理存储顺序无关的索引。\n- **特点**：每个表可以有多个非聚集索引，独立于数据存储。\n- **底层结构**：B+树。\n\n### 9. **哈希索引（Hash Index）**\n\n- **分类**：基于哈希函数的索引。\n- **特点**：等值查询效率极高，但不支持范围查询。\n- **底层结构**：哈希表。\n\n### 10. **位图索引（Bitmap Index）**\n\n- **分类**：通过位图表示数据的索引。\n- **特点**：适合低基数列，适用于组合查询，但不适合频繁更新的场景。\n- **底层结构**：位图（Bitmap）。\n\n---\n\n## 二、数据库索引的底层数据结构\n\n### 1. **B+树（B+ Tree）**\n\n- **用途**：最常用于主键索引、唯一索引、普通索引和复合索引。\n- **结构特点**：\n  - **多路平衡树**：节点包含多个键值，树高度低，磁盘I/O次数少。\n  - **叶子节点链表**：所有数据存储在叶子节点，并通过链表连接，支持范围查询。\n  - **顺序访问效率高**：适合范围查询和排序操作。\n\n### 2. **哈希表（Hash Table）**\n\n- **用途**：用于哈希索引，主要针对等值查询场景。\n- **结构特点**：\n  - **哈希函数映射**：通过哈希函数将键值映射到哈希表中的桶（bucket）。\n  - **不支持范围查询**：哈希表只能快速处理等值查询，对于范围查询无效。\n\n### 3. **倒排索引（Inverted Index）**\n\n- **用途**：主要用于全文索引。\n- **结构特点**：\n  - **关键词映射**：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。\n  - **分词处理**：适用于大文本数据，通过词语的匹配加速查询。\n  - **高效全文搜索**：特别适合搜索引擎和文本数据中的关键词查找。\n\n### 4. **R树（R-Tree）**\n\n- **用途**：用于空间索引，主要处理二维或多维的空间数据。\n- **结构特点**：\n  - **范围查询**：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。\n  - **分层结构**：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。\n\n### 5. **位图（Bitmap）**\n\n- **用途**：主要用于位图索引，适用于低基数（如性别、状态等）的列。\n- **结构特点**：\n  - **位数组表示**：使用位数组来表示数据的位置，适合数据重复较多的场景。\n  - **组合查询高效**：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。\n  - **不适合频繁更新**：因为每次修改需要更新整个位图，频繁更新时效率较低。\n\n### 6. **跳表（Skip List）**\n\n- **用途**：Redis等轻量级存储中常用的索引结构。\n- **结构特点**：\n  - **多层链表结构**：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。\n  - **范围查询**：跳表支持快速的范围查找，且实现简单。\n\n---\n\n### 三、总结\n\n1. **常见索引结构**：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。\n2. **其他结构**：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。\n3. **性能权衡**：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。\n","slug":"mysql数据库索引分类及其底层数据结构","published":1,"updated":"2024-12-14T07:51:45.874Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysna800064oa88v1g3wx5","content":"<p>数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：</p>\n<h2 id=\"一、数据库索引的分类\"><a href=\"#一、数据库索引的分类\" class=\"headerlink\" title=\"一、数据库索引的分类\"></a>一、数据库索引的分类</h2><h3 id=\"1-主键索引（Primary-Key-Index）\"><a href=\"#1-主键索引（Primary-Key-Index）\" class=\"headerlink\" title=\"1. 主键索引（Primary Key Index）\"></a>1. <strong>主键索引（Primary Key Index）</strong></h3><ul>\n<li><strong>分类</strong>：唯一性索引的一种特殊形式。</li>\n<li><strong>特点</strong>：对主键列创建的索引，保证唯一性且不能为空。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"2-唯一索引（Unique-Index）\"><a href=\"#2-唯一索引（Unique-Index）\" class=\"headerlink\" title=\"2. 唯一索引（Unique Index）\"></a>2. <strong>唯一索引（Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：确保列中的值唯一，但可以包含空值。</li>\n<li><strong>特点</strong>：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"3-普通索引（Non-Unique-Index）\"><a href=\"#3-普通索引（Non-Unique-Index）\" class=\"headerlink\" title=\"3. 普通索引（Non-Unique Index）\"></a>3. <strong>普通索引（Non-Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：不对列的唯一性做要求，最常见的索引类型。</li>\n<li><strong>特点</strong>：支持常规的查询加速，允许重复值。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"4-复合索引（Composite-Index）\"><a href=\"#4-复合索引（Composite-Index）\" class=\"headerlink\" title=\"4. 复合索引（Composite Index）\"></a>4. <strong>复合索引（Composite Index）</strong></h3><ul>\n<li><strong>分类</strong>：在多个列上创建的索引。</li>\n<li><strong>特点</strong>：按指定列顺序建立，遵循“最左前缀原则”。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"5-全文索引（Full-Text-Index）\"><a href=\"#5-全文索引（Full-Text-Index）\" class=\"headerlink\" title=\"5. 全文索引（Full-Text Index）\"></a>5. <strong>全文索引（Full-Text Index）</strong></h3><ul>\n<li><strong>分类</strong>：专门用于大文本字段搜索的索引。</li>\n<li><strong>特点</strong>：基于分词进行全文检索，支持复杂的文本查询。</li>\n<li><strong>底层结构</strong>：倒排索引（Inverted Index）。</li>\n</ul>\n<h3 id=\"6-空间索引（Spatial-Index）\"><a href=\"#6-空间索引（Spatial-Index）\" class=\"headerlink\" title=\"6. 空间索引（Spatial Index）\"></a>6. <strong>空间索引（Spatial Index）</strong></h3><ul>\n<li><strong>分类</strong>：用于地理空间数据（如坐标、地图位置）的索引。</li>\n<li><strong>特点</strong>：支持多维数据的范围查询。</li>\n<li><strong>底层结构</strong>：R树（R-Tree）。</li>\n</ul>\n<h3 id=\"7-聚集索引（Clustered-Index）\"><a href=\"#7-聚集索引（Clustered-Index）\" class=\"headerlink\" title=\"7. 聚集索引（Clustered Index）\"></a>7. <strong>聚集索引（Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序一致的索引。</li>\n<li><strong>特点</strong>：通常用于主键索引，每个表只能有一个聚集索引。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"8-非聚集索引（Non-Clustered-Index）\"><a href=\"#8-非聚集索引（Non-Clustered-Index）\" class=\"headerlink\" title=\"8. 非聚集索引（Non-Clustered Index）\"></a>8. <strong>非聚集索引（Non-Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序无关的索引。</li>\n<li><strong>特点</strong>：每个表可以有多个非聚集索引，独立于数据存储。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"9-哈希索引（Hash-Index）\"><a href=\"#9-哈希索引（Hash-Index）\" class=\"headerlink\" title=\"9. 哈希索引（Hash Index）\"></a>9. <strong>哈希索引（Hash Index）</strong></h3><ul>\n<li><strong>分类</strong>：基于哈希函数的索引。</li>\n<li><strong>特点</strong>：等值查询效率极高，但不支持范围查询。</li>\n<li><strong>底层结构</strong>：哈希表。</li>\n</ul>\n<h3 id=\"10-位图索引（Bitmap-Index）\"><a href=\"#10-位图索引（Bitmap-Index）\" class=\"headerlink\" title=\"10. 位图索引（Bitmap Index）\"></a>10. <strong>位图索引（Bitmap Index）</strong></h3><ul>\n<li><strong>分类</strong>：通过位图表示数据的索引。</li>\n<li><strong>特点</strong>：适合低基数列，适用于组合查询，但不适合频繁更新的场景。</li>\n<li><strong>底层结构</strong>：位图（Bitmap）。</li>\n</ul>\n<hr>\n<h2 id=\"二、数据库索引的底层数据结构\"><a href=\"#二、数据库索引的底层数据结构\" class=\"headerlink\" title=\"二、数据库索引的底层数据结构\"></a>二、数据库索引的底层数据结构</h2><h3 id=\"1-B-树（B-Tree）\"><a href=\"#1-B-树（B-Tree）\" class=\"headerlink\" title=\"1. B+树（B+ Tree）\"></a>1. <strong>B+树（B+ Tree）</strong></h3><ul>\n<li><strong>用途</strong>：最常用于主键索引、唯一索引、普通索引和复合索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多路平衡树</strong>：节点包含多个键值，树高度低，磁盘I&#x2F;O次数少。</li>\n<li><strong>叶子节点链表</strong>：所有数据存储在叶子节点，并通过链表连接，支持范围查询。</li>\n<li><strong>顺序访问效率高</strong>：适合范围查询和排序操作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-哈希表（Hash-Table）\"><a href=\"#2-哈希表（Hash-Table）\" class=\"headerlink\" title=\"2. 哈希表（Hash Table）\"></a>2. <strong>哈希表（Hash Table）</strong></h3><ul>\n<li><strong>用途</strong>：用于哈希索引，主要针对等值查询场景。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>哈希函数映射</strong>：通过哈希函数将键值映射到哈希表中的桶（bucket）。</li>\n<li><strong>不支持范围查询</strong>：哈希表只能快速处理等值查询，对于范围查询无效。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-倒排索引（Inverted-Index）\"><a href=\"#3-倒排索引（Inverted-Index）\" class=\"headerlink\" title=\"3. 倒排索引（Inverted Index）\"></a>3. <strong>倒排索引（Inverted Index）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于全文索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>关键词映射</strong>：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。</li>\n<li><strong>分词处理</strong>：适用于大文本数据，通过词语的匹配加速查询。</li>\n<li><strong>高效全文搜索</strong>：特别适合搜索引擎和文本数据中的关键词查找。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-R树（R-Tree）\"><a href=\"#4-R树（R-Tree）\" class=\"headerlink\" title=\"4. R树（R-Tree）\"></a>4. <strong>R树（R-Tree）</strong></h3><ul>\n<li><strong>用途</strong>：用于空间索引，主要处理二维或多维的空间数据。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>范围查询</strong>：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。</li>\n<li><strong>分层结构</strong>：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-位图（Bitmap）\"><a href=\"#5-位图（Bitmap）\" class=\"headerlink\" title=\"5. 位图（Bitmap）\"></a>5. <strong>位图（Bitmap）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于位图索引，适用于低基数（如性别、状态等）的列。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>位数组表示</strong>：使用位数组来表示数据的位置，适合数据重复较多的场景。</li>\n<li><strong>组合查询高效</strong>：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。</li>\n<li><strong>不适合频繁更新</strong>：因为每次修改需要更新整个位图，频繁更新时效率较低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-跳表（Skip-List）\"><a href=\"#6-跳表（Skip-List）\" class=\"headerlink\" title=\"6. 跳表（Skip List）\"></a>6. <strong>跳表（Skip List）</strong></h3><ul>\n<li><strong>用途</strong>：Redis等轻量级存储中常用的索引结构。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多层链表结构</strong>：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。</li>\n<li><strong>范围查询</strong>：跳表支持快速的范围查找，且实现简单。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><ol>\n<li><strong>常见索引结构</strong>：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。</li>\n<li><strong>其他结构</strong>：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。</li>\n<li><strong>性能权衡</strong>：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。</li>\n</ol>\n","cover":false,"excerpt":"","more":"<p>数据库索引的分类和底层数据结构直接决定了它在不同场景下的性能和适用性。以下是数据库索引的主要分类及其底层数据结构的详细分析：</p>\n<h2 id=\"一、数据库索引的分类\"><a href=\"#一、数据库索引的分类\" class=\"headerlink\" title=\"一、数据库索引的分类\"></a>一、数据库索引的分类</h2><h3 id=\"1-主键索引（Primary-Key-Index）\"><a href=\"#1-主键索引（Primary-Key-Index）\" class=\"headerlink\" title=\"1. 主键索引（Primary Key Index）\"></a>1. <strong>主键索引（Primary Key Index）</strong></h3><ul>\n<li><strong>分类</strong>：唯一性索引的一种特殊形式。</li>\n<li><strong>特点</strong>：对主键列创建的索引，保证唯一性且不能为空。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"2-唯一索引（Unique-Index）\"><a href=\"#2-唯一索引（Unique-Index）\" class=\"headerlink\" title=\"2. 唯一索引（Unique Index）\"></a>2. <strong>唯一索引（Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：确保列中的值唯一，但可以包含空值。</li>\n<li><strong>特点</strong>：每个表可以有多个唯一索引，用于对独立列进行唯一性约束。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"3-普通索引（Non-Unique-Index）\"><a href=\"#3-普通索引（Non-Unique-Index）\" class=\"headerlink\" title=\"3. 普通索引（Non-Unique Index）\"></a>3. <strong>普通索引（Non-Unique Index）</strong></h3><ul>\n<li><strong>分类</strong>：不对列的唯一性做要求，最常见的索引类型。</li>\n<li><strong>特点</strong>：支持常规的查询加速，允许重复值。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"4-复合索引（Composite-Index）\"><a href=\"#4-复合索引（Composite-Index）\" class=\"headerlink\" title=\"4. 复合索引（Composite Index）\"></a>4. <strong>复合索引（Composite Index）</strong></h3><ul>\n<li><strong>分类</strong>：在多个列上创建的索引。</li>\n<li><strong>特点</strong>：按指定列顺序建立，遵循“最左前缀原则”。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"5-全文索引（Full-Text-Index）\"><a href=\"#5-全文索引（Full-Text-Index）\" class=\"headerlink\" title=\"5. 全文索引（Full-Text Index）\"></a>5. <strong>全文索引（Full-Text Index）</strong></h3><ul>\n<li><strong>分类</strong>：专门用于大文本字段搜索的索引。</li>\n<li><strong>特点</strong>：基于分词进行全文检索，支持复杂的文本查询。</li>\n<li><strong>底层结构</strong>：倒排索引（Inverted Index）。</li>\n</ul>\n<h3 id=\"6-空间索引（Spatial-Index）\"><a href=\"#6-空间索引（Spatial-Index）\" class=\"headerlink\" title=\"6. 空间索引（Spatial Index）\"></a>6. <strong>空间索引（Spatial Index）</strong></h3><ul>\n<li><strong>分类</strong>：用于地理空间数据（如坐标、地图位置）的索引。</li>\n<li><strong>特点</strong>：支持多维数据的范围查询。</li>\n<li><strong>底层结构</strong>：R树（R-Tree）。</li>\n</ul>\n<h3 id=\"7-聚集索引（Clustered-Index）\"><a href=\"#7-聚集索引（Clustered-Index）\" class=\"headerlink\" title=\"7. 聚集索引（Clustered Index）\"></a>7. <strong>聚集索引（Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序一致的索引。</li>\n<li><strong>特点</strong>：通常用于主键索引，每个表只能有一个聚集索引。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"8-非聚集索引（Non-Clustered-Index）\"><a href=\"#8-非聚集索引（Non-Clustered-Index）\" class=\"headerlink\" title=\"8. 非聚集索引（Non-Clustered Index）\"></a>8. <strong>非聚集索引（Non-Clustered Index）</strong></h3><ul>\n<li><strong>分类</strong>：索引顺序与物理存储顺序无关的索引。</li>\n<li><strong>特点</strong>：每个表可以有多个非聚集索引，独立于数据存储。</li>\n<li><strong>底层结构</strong>：B+树。</li>\n</ul>\n<h3 id=\"9-哈希索引（Hash-Index）\"><a href=\"#9-哈希索引（Hash-Index）\" class=\"headerlink\" title=\"9. 哈希索引（Hash Index）\"></a>9. <strong>哈希索引（Hash Index）</strong></h3><ul>\n<li><strong>分类</strong>：基于哈希函数的索引。</li>\n<li><strong>特点</strong>：等值查询效率极高，但不支持范围查询。</li>\n<li><strong>底层结构</strong>：哈希表。</li>\n</ul>\n<h3 id=\"10-位图索引（Bitmap-Index）\"><a href=\"#10-位图索引（Bitmap-Index）\" class=\"headerlink\" title=\"10. 位图索引（Bitmap Index）\"></a>10. <strong>位图索引（Bitmap Index）</strong></h3><ul>\n<li><strong>分类</strong>：通过位图表示数据的索引。</li>\n<li><strong>特点</strong>：适合低基数列，适用于组合查询，但不适合频繁更新的场景。</li>\n<li><strong>底层结构</strong>：位图（Bitmap）。</li>\n</ul>\n<hr>\n<h2 id=\"二、数据库索引的底层数据结构\"><a href=\"#二、数据库索引的底层数据结构\" class=\"headerlink\" title=\"二、数据库索引的底层数据结构\"></a>二、数据库索引的底层数据结构</h2><h3 id=\"1-B-树（B-Tree）\"><a href=\"#1-B-树（B-Tree）\" class=\"headerlink\" title=\"1. B+树（B+ Tree）\"></a>1. <strong>B+树（B+ Tree）</strong></h3><ul>\n<li><strong>用途</strong>：最常用于主键索引、唯一索引、普通索引和复合索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多路平衡树</strong>：节点包含多个键值，树高度低，磁盘I&#x2F;O次数少。</li>\n<li><strong>叶子节点链表</strong>：所有数据存储在叶子节点，并通过链表连接，支持范围查询。</li>\n<li><strong>顺序访问效率高</strong>：适合范围查询和排序操作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-哈希表（Hash-Table）\"><a href=\"#2-哈希表（Hash-Table）\" class=\"headerlink\" title=\"2. 哈希表（Hash Table）\"></a>2. <strong>哈希表（Hash Table）</strong></h3><ul>\n<li><strong>用途</strong>：用于哈希索引，主要针对等值查询场景。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>哈希函数映射</strong>：通过哈希函数将键值映射到哈希表中的桶（bucket）。</li>\n<li><strong>不支持范围查询</strong>：哈希表只能快速处理等值查询，对于范围查询无效。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-倒排索引（Inverted-Index）\"><a href=\"#3-倒排索引（Inverted-Index）\" class=\"headerlink\" title=\"3. 倒排索引（Inverted Index）\"></a>3. <strong>倒排索引（Inverted Index）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于全文索引。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>关键词映射</strong>：倒排索引将每个关键词映射到包含该关键词的文档或记录列表中。</li>\n<li><strong>分词处理</strong>：适用于大文本数据，通过词语的匹配加速查询。</li>\n<li><strong>高效全文搜索</strong>：特别适合搜索引擎和文本数据中的关键词查找。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-R树（R-Tree）\"><a href=\"#4-R树（R-Tree）\" class=\"headerlink\" title=\"4. R树（R-Tree）\"></a>4. <strong>R树（R-Tree）</strong></h3><ul>\n<li><strong>用途</strong>：用于空间索引，主要处理二维或多维的空间数据。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>范围查询</strong>：通过最小边界矩形（MBR，Minimum Bounding Rectangle）来划分空间数据，支持多维空间范围查询。</li>\n<li><strong>分层结构</strong>：R树的节点存储空间范围信息，非叶子节点存储矩形的边界范围，叶子节点存储数据位置。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-位图（Bitmap）\"><a href=\"#5-位图（Bitmap）\" class=\"headerlink\" title=\"5. 位图（Bitmap）\"></a>5. <strong>位图（Bitmap）</strong></h3><ul>\n<li><strong>用途</strong>：主要用于位图索引，适用于低基数（如性别、状态等）的列。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>位数组表示</strong>：使用位数组来表示数据的位置，适合数据重复较多的场景。</li>\n<li><strong>组合查询高效</strong>：多个位图可以进行按位操作（如 AND、OR 等），快速计算组合查询结果。</li>\n<li><strong>不适合频繁更新</strong>：因为每次修改需要更新整个位图，频繁更新时效率较低。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-跳表（Skip-List）\"><a href=\"#6-跳表（Skip-List）\" class=\"headerlink\" title=\"6. 跳表（Skip List）\"></a>6. <strong>跳表（Skip List）</strong></h3><ul>\n<li><strong>用途</strong>：Redis等轻量级存储中常用的索引结构。</li>\n<li><strong>结构特点</strong>：<ul>\n<li><strong>多层链表结构</strong>：通过引入多层级指针，跳表能够实现接近于平衡树的查询效率。</li>\n<li><strong>范围查询</strong>：跳表支持快速的范围查找，且实现简单。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><ol>\n<li><strong>常见索引结构</strong>：B+树结构是大多数关系型数据库索引的主要实现方式，广泛应用于主键索引、唯一索引和普通索引。它支持快速的查找、插入、删除操作，且能够高效处理范围查询。</li>\n<li><strong>其他结构</strong>：哈希索引适用于等值查询，倒排索引适合全文搜索，R树则处理空间数据查询，而位图索引擅长组合查询但不适合频繁更新。</li>\n<li><strong>性能权衡</strong>：每种索引结构都有其特定的应用场景，合理选择合适的索引类型和结构可以显著提升数据库的查询性能，同时也要平衡插入、更新操作的开销。</li>\n</ol>\n"},{"title":"实在智能实习经历收获","date":"2024-10-26T10:32:16.000Z","_content":"\n> 2024年9月18日入职杭州实在智能有限公司java实习生\n\n## 实习历程：\n\n- 刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令\n\n- 杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解\n\n- 接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力\n\n- 设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用\n\n- 设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回\n\n- 完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug\n\n- 完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题\n\n- 完成crm接口的开发，联调，测试，上线\n\n## 实习项目介绍（实习经历）\n\n**项目介绍：**\n\nIDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：[http://idp.ai-indeed.com/](http://idp.ai-indeed.com/)。\n\n**负责模块**:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署\n\n**主要工作：** \n\n- **自定义抽取模板开发**：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。\n- **自定义抽取任务管理**：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。\n- **OCR集成与CRM审核模板生成**：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。\n- **CRM异步任务处理和结果反馈**：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。\n- **私有化定制部署**：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。\n\n## 实习期间遇到的难点：\n\n- 项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核\n  解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核\n\n- 项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台\n  首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台\n","source":"_posts/实在智能实习经历收获.md","raw":"---\ntitle: 实在智能实习经历收获\ndate: 2024-10-26 18:32:16\ntags: 实习\ncategories: 实习业务\n---\n\n> 2024年9月18日入职杭州实在智能有限公司java实习生\n\n## 实习历程：\n\n- 刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令\n\n- 杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解\n\n- 接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力\n\n- 设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用\n\n- 设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回\n\n- 完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug\n\n- 完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题\n\n- 完成crm接口的开发，联调，测试，上线\n\n## 实习项目介绍（实习经历）\n\n**项目介绍：**\n\nIDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：[http://idp.ai-indeed.com/](http://idp.ai-indeed.com/)。\n\n**负责模块**:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署\n\n**主要工作：** \n\n- **自定义抽取模板开发**：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。\n- **自定义抽取任务管理**：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。\n- **OCR集成与CRM审核模板生成**：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。\n- **CRM异步任务处理和结果反馈**：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。\n- **私有化定制部署**：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。\n\n## 实习期间遇到的难点：\n\n- 项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核\n  解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核\n\n- 项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台\n  首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台\n","slug":"实在智能实习经历收获","published":1,"updated":"2024-12-14T09:16:47.121Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysnaa000a4oa8fc7b30e0","content":"<blockquote>\n<p>2024年9月18日入职杭州实在智能有限公司java实习生</p>\n</blockquote>\n<h2 id=\"实习历程：\"><a href=\"#实习历程：\" class=\"headerlink\" title=\"实习历程：\"></a>实习历程：</h2><ul>\n<li><p>刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令</p>\n</li>\n<li><p>杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解</p>\n</li>\n<li><p>接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力</p>\n</li>\n<li><p>设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用</p>\n</li>\n<li><p>设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回</p>\n</li>\n<li><p>完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug</p>\n</li>\n<li><p>完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题</p>\n</li>\n<li><p>完成crm接口的开发，联调，测试，上线</p>\n</li>\n</ul>\n<h2 id=\"实习项目介绍（实习经历）\"><a href=\"#实习项目介绍（实习经历）\" class=\"headerlink\" title=\"实习项目介绍（实习经历）\"></a>实习项目介绍（实习经历）</h2><p><strong>项目介绍：</strong></p>\n<p>IDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：<a href=\"http://idp.ai-indeed.com/\">http://idp.ai-indeed.com/</a>。</p>\n<p><strong>负责模块</strong>:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署</p>\n<p><strong>主要工作：</strong> </p>\n<ul>\n<li><strong>自定义抽取模板开发</strong>：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。</li>\n<li><strong>自定义抽取任务管理</strong>：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。</li>\n<li><strong>OCR集成与CRM审核模板生成</strong>：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。</li>\n<li><strong>CRM异步任务处理和结果反馈</strong>：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。</li>\n<li><strong>私有化定制部署</strong>：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。</li>\n</ul>\n<h2 id=\"实习期间遇到的难点：\"><a href=\"#实习期间遇到的难点：\" class=\"headerlink\" title=\"实习期间遇到的难点：\"></a>实习期间遇到的难点：</h2><ul>\n<li><p>项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核<br>解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核</p>\n</li>\n<li><p>项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台<br>首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台</p>\n</li>\n</ul>\n","cover":false,"excerpt":"","more":"<blockquote>\n<p>2024年9月18日入职杭州实在智能有限公司java实习生</p>\n</blockquote>\n<h2 id=\"实习历程：\"><a href=\"#实习历程：\" class=\"headerlink\" title=\"实习历程：\"></a>实习历程：</h2><ul>\n<li><p>刚入职被要求去杭州烟草部署IDP项目，接触到了k8s流水线打包，集群一键部署，了解到了IDP的私有化应用场景，对IDP项目产品有了初步认识，更加熟练的掌握了linux，docker，k8s的一些命令</p>\n</li>\n<li><p>杭州烟草完成部署后，开始熟悉IDP4.4.0代码，写自定义抽取模板的标注任务相关接口，学习到了很多代码编写规范，枚举，stream流，git，分布式锁等的使用场景，通过阅读复杂的大项目代码，让我的阅读代码能力有了显著的提升，对代码结构和表结构都更加了解</p>\n</li>\n<li><p>接口开发完后与前端联调接口，让我学习到了怎么快速去发现问题，定位问题，debug调试，最后修复异常解决问题，联调过程中提高了与同事沟通交流的能力</p>\n</li>\n<li><p>设计自定义抽取模板的节点数据结构和处理器，这部分让我学会了如何根据prd设计复杂的数据结构，也让我接触到了工厂模式和注册表模式的实际应用场景，对spring有了更深的理解，通过接算法用到了远程调用</p>\n</li>\n<li><p>设计crm合同审核调用接口，通过sql去生成模板和配置模板，通过python代码配置内置规则，与算法对接抽取模板，在接口方法中用到了工厂加注册表模式，提高程序扩展性，可维护性，设计异步任务执行的回调接口，通过redis缓存任务邮箱，最后和任务结果比对，异步返回</p>\n</li>\n<li><p>完成ocr任务对接，联调抽取自定义的任务执行，通过连接k8s集群通过日志跟踪状态，修复bug</p>\n</li>\n<li><p>完成自定义抽取模板任务执行的bug修复开发，使用线程池，completableFuture，mq等工具优化任务的异步执行，实现并发提速，线程复用减小开销，控制线程资源防止资源耗尽，通过异步解耦防止主线程阻塞，提高响应速度和任务执行效率。通过synchronized同步节点结果合并防止并发合并导致结果出错,通过数据库的版本号优化用户结果修改反馈，防止多个用户操作统一资源导致线程安全问题</p>\n</li>\n<li><p>完成crm接口的开发，联调，测试，上线</p>\n</li>\n</ul>\n<h2 id=\"实习项目介绍（实习经历）\"><a href=\"#实习项目介绍（实习经历）\" class=\"headerlink\" title=\"实习项目介绍（实习经历）\"></a>实习项目介绍（实习经历）</h2><p><strong>项目介绍：</strong></p>\n<p>IDP文档审阅系统是一个集成多种文档处理功能的平台，涵盖抽取模板、审核模板、文本比对，OCR识别等模板，支持用户自定义模板配置。该系统大幅降低了文档处理的人工成本，用户通过上传文件便可完成多种文档审阅任务，项目支持线上使用和私有化部署，线上地址：<a href=\"http://idp.ai-indeed.com/\">http://idp.ai-indeed.com/</a>。</p>\n<p><strong>负责模块</strong>:主要负责IDP4.4.0自定义抽取模板，IDP4.3.0CRM平台合同审核接口开发、测试、联调以及一些私有化定制部署</p>\n<p><strong>主要工作：</strong> </p>\n<ul>\n<li><strong>自定义抽取模板开发</strong>：采用工厂模式+注册表模式优化自定义抽取模板节点数据结构和处理器的设计，使自定义抽取流程灵活可扩展。集成OpenFeign远程调用OCR算法，实现表格抽取功能，通过Hystrix做熔断降级策略，当高并发请求而算法服务不可用时通过熔断降级防止资源的浪费并提升5秒以上响应速度。</li>\n<li><strong>自定义抽取任务管理</strong>：开发了NLP抽取节点标注任务(用于模型训练)，通过Redis实现简易分布式锁，避免nlp节点标注父任务重复创建，确保幂等性。通过mq,线程池,completableFuture等工具优化自定义抽取任务的异步执行，异步解耦提升响应速度和任务执行效率。 通过悲观锁和乐观锁分别优化节点结果合并，多个用户操作同一结果，防止多线程抢夺同一资源出现并发问题。</li>\n<li><strong>OCR集成与CRM审核模板生成</strong>：编写SQL脚本创建OCR抽取模板，并为其配置字段审核规则。调用阿里云数脉API验证合同中公司信息的合法性，生成符合CRM平台审核需求的模板，确保OCR数据的准确性及业务信息的合规性。</li>\n<li><strong>CRM异步任务处理和结果反馈</strong>：  为CRM平台开发接口，采用工厂模式根据文件类型动态获取审核模板，异步执行任务，并将任务标识与用户邮箱存入Redis以追踪任务状态。任务完成后，通过回调接口核对Redis中的邮箱信息与任务结果的准确性，利用RocketMQ异步推送结果至CRM平台，确保任务反馈的实时性和系统处理的高效稳定。</li>\n<li><strong>私有化定制部署</strong>：参与系统的私有化部署，基于K8s流水线完成一键打包部署，通过SQL或Shell脚本设定租户授权期限，为客户提供定制化IDP系统。成功完成了杭州烟草、中数通等客户的私有化部署和授权配置，满足了多客户的个性化需求。</li>\n</ul>\n<h2 id=\"实习期间遇到的难点：\"><a href=\"#实习期间遇到的难点：\" class=\"headerlink\" title=\"实习期间遇到的难点：\"></a>实习期间遇到的难点：</h2><ul>\n<li><p>项目难点1：由于平台请求要携带邮箱与任务执行结果中的邮箱做比对，而任务执行是异步无法同步返回结果做比对，而且任务执行无法将对应邮箱带进去做审核<br>解决方案：异步执行任务时同步返回一个taskCode，将taskCode和邮箱作为k,v存入redis，当任务异步执行完毕，拿到任务结果和redis中任务对应的邮箱做比对审核</p>\n</li>\n<li><p>项目难点2:由于任务是异步执行的，而业务需要获取到任务结果异步返回给平台<br>首先想的是任务执行完成后将结果入库，用定时任务去扫描数据库得到任务结果返回，这样的话会浪费线程资源，解决方案是设计一个回调接口，当任务异步执行完后请求回调接口，拿到任务执行结果去redis拿邮箱比对然后mq异步返回结果给平台</p>\n</li>\n</ul>\n"},{"title":"普通线程池的执行流程","date":"2024-11-01T08:50:09.000Z","_content":"\n普通线程池的执行流程通常包括以下几个步骤：\n\n1. **线程池初始化**  \n   在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。\n\n2. **提交任务**  \n   当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。\n\n3. **任务执行流程**  \n   根据线程池的状态和配置，线程池采取以下策略来执行任务：\n   \n   - **核心线程数未满**：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。\n   - **核心线程已满，任务队列未满**：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。\n   - **任务队列已满，且线程数未达上限**：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。\n   - **任务队列已满，且线程数达到上限**：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。\n\n4. **线程执行任务**  \n   被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。\n\n5. **线程回收与销毁**\n   \n   - **空闲线程回收**：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。\n   - **线程池关闭**：当调用线程池的 `shutdown` 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 `shutdownNow` 方法立即中断所有线程，强制关闭线程池。\n\n6. **任务结束后的清理**  \n   当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。\n\n整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。\n","source":"_posts/普通线程池的执行流程.md","raw":"---\ntitle: 普通线程池的执行流程\ndate: 2024-11-01 16:50:09\ntags: java基础\ncategories: 八股文\n---\n\n普通线程池的执行流程通常包括以下几个步骤：\n\n1. **线程池初始化**  \n   在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。\n\n2. **提交任务**  \n   当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。\n\n3. **任务执行流程**  \n   根据线程池的状态和配置，线程池采取以下策略来执行任务：\n   \n   - **核心线程数未满**：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。\n   - **核心线程已满，任务队列未满**：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。\n   - **任务队列已满，且线程数未达上限**：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。\n   - **任务队列已满，且线程数达到上限**：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。\n\n4. **线程执行任务**  \n   被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。\n\n5. **线程回收与销毁**\n   \n   - **空闲线程回收**：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。\n   - **线程池关闭**：当调用线程池的 `shutdown` 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 `shutdownNow` 方法立即中断所有线程，强制关闭线程池。\n\n6. **任务结束后的清理**  \n   当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。\n\n整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。\n","slug":"普通线程池的执行流程","published":1,"updated":"2024-12-14T09:16:09.195Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysnab000b4oa8e0g54wtf","content":"<p>普通线程池的执行流程通常包括以下几个步骤：</p>\n<ol>\n<li><p><strong>线程池初始化</strong><br>在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。</p>\n</li>\n<li><p><strong>提交任务</strong><br>当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。</p>\n</li>\n<li><p><strong>任务执行流程</strong><br>根据线程池的状态和配置，线程池采取以下策略来执行任务：</p>\n<ul>\n<li><strong>核心线程数未满</strong>：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。</li>\n<li><strong>核心线程已满，任务队列未满</strong>：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。</li>\n<li><strong>任务队列已满，且线程数未达上限</strong>：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。</li>\n<li><strong>任务队列已满，且线程数达到上限</strong>：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。</li>\n</ul>\n</li>\n<li><p><strong>线程执行任务</strong><br>被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。</p>\n</li>\n<li><p><strong>线程回收与销毁</strong></p>\n<ul>\n<li><strong>空闲线程回收</strong>：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。</li>\n<li><strong>线程池关闭</strong>：当调用线程池的 <code>shutdown</code> 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 <code>shutdownNow</code> 方法立即中断所有线程，强制关闭线程池。</li>\n</ul>\n</li>\n<li><p><strong>任务结束后的清理</strong><br>当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。</p>\n</li>\n</ol>\n<p>整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。</p>\n","cover":false,"excerpt":"","more":"<p>普通线程池的执行流程通常包括以下几个步骤：</p>\n<ol>\n<li><p><strong>线程池初始化</strong><br>在线程池创建时，预先设置好线程池的参数（如核心线程数、最大线程数、任务队列等），并初始化一组核心线程。线程池会根据参数控制线程的创建和销毁，以实现对资源的合理管理。</p>\n</li>\n<li><p><strong>提交任务</strong><br>当有任务提交到线程池时，线程池会根据当前的线程数和任务队列的状态来判断如何处理该任务。</p>\n</li>\n<li><p><strong>任务执行流程</strong><br>根据线程池的状态和配置，线程池采取以下策略来执行任务：</p>\n<ul>\n<li><strong>核心线程数未满</strong>：如果当前运行的线程数量少于核心线程数，则线程池会立即创建一个新的线程来执行任务。</li>\n<li><strong>核心线程已满，任务队列未满</strong>：如果核心线程数已满，任务会被放入任务队列中，等待空闲线程执行。</li>\n<li><strong>任务队列已满，且线程数未达上限</strong>：如果任务队列已满，且线程池中线程数少于最大线程数，线程池会创建一个新的线程来执行任务。</li>\n<li><strong>任务队列已满，且线程数达到上限</strong>：如果任务队列和线程池的线程数都已达到上限，线程池根据拒绝策略（如抛出异常、丢弃任务等）来处理新任务。</li>\n</ul>\n</li>\n<li><p><strong>线程执行任务</strong><br>被分配到任务的线程开始执行任务代码。当任务执行完毕后，线程会检查任务队列中是否还有等待执行的任务，如果有，则继续从队列中获取任务并执行。</p>\n</li>\n<li><p><strong>线程回收与销毁</strong></p>\n<ul>\n<li><strong>空闲线程回收</strong>：如果一个线程在指定的空闲时间内没有接收到新任务，且线程池的线程数超过了核心线程数，那么线程池会将该线程回收，释放资源。</li>\n<li><strong>线程池关闭</strong>：当调用线程池的 <code>shutdown</code> 方法后，线程池会停止接收新任务，并等待所有已提交的任务执行完毕。可以使用 <code>shutdownNow</code> 方法立即中断所有线程，强制关闭线程池。</li>\n</ul>\n</li>\n<li><p><strong>任务结束后的清理</strong><br>当所有任务执行完毕，线程池会根据配置的回收策略，关闭空闲的线程并清理资源，确保系统资源不会被长期占用。</p>\n</li>\n</ol>\n<p>整个流程使得线程池能够高效地复用线程资源，并在高并发场景下避免频繁的线程创建和销毁，有效地控制系统的资源占用和性能表现。</p>\n"},{"title":"工厂+注册表模式设计nodeHandler","date":"2024-11-14T13:09:17.000Z","_content":"\n# 工厂+注册表模式获取nodeHandler\n\n自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler\n\n其中一个是默认nodeHandler.\n\n由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点\n\n```java\npackage ai.ii.supertext.app.serivce.extraction.handler;\n\nimport ai.ii.supertext.plus.common.util.SpringContext;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Configuration\npublic class NodeHandlerFactory {\n\n    private static final ConcurrentHashMap<String, NodeHandler> nodeHandlerMap = new ConcurrentHashMap<>();\n\n    public static void registerHandler(NodeHandler handler) {\n        nodeHandlerMap.put(handler.getNodeCode(), handler);\n    }\n\n    public NodeHandler getNodeHandler(String nodeCode) {\n        if (nodeCode == null) {\n            log.error(\"action=getNodeHandler node is null. please confirm config\");\n            return null;\n        }\n        return nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));\n    }\n}\n```\n\n工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。\n因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂\n\n工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.\n\n使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本\n","source":"_posts/工厂-注册表模式设计nodeHandler.md","raw":"---\ntitle: 工厂+注册表模式设计nodeHandler\ndate: 2024-11-14 21:09:17\ntags: 设计模式\ncategories: 业务场景\n---\n\n# 工厂+注册表模式获取nodeHandler\n\n自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler\n\n其中一个是默认nodeHandler.\n\n由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点\n\n```java\npackage ai.ii.supertext.app.serivce.extraction.handler;\n\nimport ai.ii.supertext.plus.common.util.SpringContext;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Configuration\npublic class NodeHandlerFactory {\n\n    private static final ConcurrentHashMap<String, NodeHandler> nodeHandlerMap = new ConcurrentHashMap<>();\n\n    public static void registerHandler(NodeHandler handler) {\n        nodeHandlerMap.put(handler.getNodeCode(), handler);\n    }\n\n    public NodeHandler getNodeHandler(String nodeCode) {\n        if (nodeCode == null) {\n            log.error(\"action=getNodeHandler node is null. please confirm config\");\n            return null;\n        }\n        return nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));\n    }\n}\n```\n\n工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。\n因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂\n\n工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.\n\n使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本\n","slug":"工厂-注册表模式设计nodeHandler","published":1,"updated":"2024-12-14T09:15:53.521Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysnac000g4oa8b53aeq4v","content":"<h1 id=\"工厂-注册表模式获取nodeHandler\"><a href=\"#工厂-注册表模式获取nodeHandler\" class=\"headerlink\" title=\"工厂+注册表模式获取nodeHandler\"></a>工厂+注册表模式获取nodeHandler</h1><p>自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler</p>\n<p>其中一个是默认nodeHandler.</p>\n<p>由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ai.ii.supertext.app.serivce.extraction.handler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ai.ii.supertext.plus.common.util.SpringContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NodeHandlerFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, NodeHandler&gt; nodeHandlerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerHandler</span><span class=\"params\">(NodeHandler handler)</span> &#123;</span><br><span class=\"line\">        nodeHandlerMap.put(handler.getNodeCode(), handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> NodeHandler <span class=\"title function_\">getNodeHandler</span><span class=\"params\">(String nodeCode)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeCode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;action=getNodeHandler node is null. please confirm config&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。<br>因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂</p>\n<p>工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.</p>\n<p>使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本</p>\n","cover":false,"excerpt":"","more":"<h1 id=\"工厂-注册表模式获取nodeHandler\"><a href=\"#工厂-注册表模式获取nodeHandler\" class=\"headerlink\" title=\"工厂+注册表模式获取nodeHandler\"></a>工厂+注册表模式获取nodeHandler</h1><p>自定义抽取模板有三种不同节点，因此有三种不同节点处理器nodeHandler</p>\n<p>其中一个是默认nodeHandler.</p>\n<p>由于三种节点的数据结构和处理方法完全不同，而需要走统一入口操作节点，因此使用工厂模式，前端操作节点时传入一个nodeCode,工厂根据nodeCode获取对应的nodeHandler处理节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ai.ii.supertext.app.serivce.extraction.handler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ai.ii.supertext.plus.common.util.SpringContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NodeHandlerFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, NodeHandler&gt; nodeHandlerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerHandler</span><span class=\"params\">(NodeHandler handler)</span> &#123;</span><br><span class=\"line\">        nodeHandlerMap.put(handler.getNodeCode(), handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> NodeHandler <span class=\"title function_\">getNodeHandler</span><span class=\"params\">(String nodeCode)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nodeCode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;action=getNodeHandler node is null. please confirm config&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nodeHandlerMap.getOrDefault(nodeCode, SpringContext.get(DefaultNodeHandler.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂通过维护一个ConcurrentHashMap,提供对象注册方法和获取方法，由于在NodeHandler接口中有个PostConstruct方法，在NodeHandler实现类在bean的初始化之后会执行方法将NodeHandler注册到工厂中，nodeCode为key，nodeHandler为value。<br>因此只需用@Component标记实现类，应用启动时就会把对象注册到工厂</p>\n<p>工厂通过传入的nodeCode获取到对应的nodeHandler处理对应节点，如果工厂找不到nodeHandler会返回默认的nodeHandler.</p>\n<p>使用工厂模式管理节点处理器，增强了可维护性和功能扩展性，而且不同的节点操作可以走统一接口，简化了代码，降低维护成本</p>\n"},{"title":"leetcode第31题解","date":"2024-12-14T07:07:39.000Z","_content":"\n# [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)\n\n整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 修改，只允许使用额外常数空间。\n\n**示例 1：**\n\n**输入：**nums = [1,2,3]\n**输出：**[1,3,2]\n\n**示例 2：**\n\n**输入：**nums = [3,2,1]\n**输出：**[1,2,3]\n\n**示例 3：**\n\n**输入：**nums = [1,1,5]\n**输出：**[1,5,1]\n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`\n\n\n\n\n\n# 思路：\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。\n\n\n\n\n\n# 代码\n\n```java\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i=0;\n        int j=0;\n        outerloop:\n        for(i=nums.length-2;i>=0;i--)//i从后往前找\n        {\n            int min=1000;\n            int minj=-1;\n            for(j=i+1;j<nums.length;j++)//找到i后比i大的最小数\n            {\n               if(nums[i]<nums[j]&&nums[j]<min)\n               {\n                    min=nums[j];\n                    minj=j;\n               }\n            }\n            if(minj!=-1)//找到并交换跳出两重循环\n            {\n                int temp=nums[i];\n                nums[i]=nums[minj];\n                nums[minj]=temp;\n                break outerloop;\n            }\n        }\n        Arrays.sort(nums,i+1,nums.length);//排序i后元素\n    }\n}\n```\n","source":"_posts/leetcode第31题解.md","raw":"---\ntitle: leetcode第31题解\ndate: 2024-12-14 15:07:39\ntags: leetcode\ncategories: 算法\n---\n\n# [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)\n\n整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 修改，只允许使用额外常数空间。\n\n**示例 1：**\n\n**输入：**nums = [1,2,3]\n**输出：**[1,3,2]\n\n**示例 2：**\n\n**输入：**nums = [3,2,1]\n**输出：**[1,2,3]\n\n**示例 3：**\n\n**输入：**nums = [1,1,5]\n**输出：**[1,5,1]\n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`\n\n\n\n\n\n# 思路：\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。\n\n\n\n\n\n# 代码\n\n```java\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i=0;\n        int j=0;\n        outerloop:\n        for(i=nums.length-2;i>=0;i--)//i从后往前找\n        {\n            int min=1000;\n            int minj=-1;\n            for(j=i+1;j<nums.length;j++)//找到i后比i大的最小数\n            {\n               if(nums[i]<nums[j]&&nums[j]<min)\n               {\n                    min=nums[j];\n                    minj=j;\n               }\n            }\n            if(minj!=-1)//找到并交换跳出两重循环\n            {\n                int temp=nums[i];\n                nums[i]=nums[minj];\n                nums[minj]=temp;\n                break outerloop;\n            }\n        }\n        Arrays.sort(nums,i+1,nums.length);//排序i后元素\n    }\n}\n```\n","slug":"leetcode第31题解","published":1,"updated":"2024-12-14T08:09:33.135Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysnad000j4oa8792phuxm","content":"<h1 id=\"31-下一个排列\"><a href=\"#31-下一个排列\" class=\"headerlink\" title=\"31. 下一个排列\"></a><a href=\"https://leetcode.cn/problems/next-permutation/\">31. 下一个排列</a></h1><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>\n</ul>\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>\n<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>\n<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>\n<p>必须 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 修改，只允许使用额外常数空间。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,2,3]<br><strong>输出：</strong>[1,3,2]</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [3,2,1]<br><strong>输出：</strong>[1,2,3]</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,1,5]<br><strong>输出：</strong>[1,5,1]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<h1 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h1><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nextPermutation</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        outerloop:</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=nums.length-<span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;i--)<span class=\"comment\">//i从后往前找</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> min=<span class=\"number\">1000</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> minj=-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;nums.length;j++)<span class=\"comment\">//找到i后比i大的最小数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(nums[i]&lt;nums[j]&amp;&amp;nums[j]&lt;min)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                    min=nums[j];</span><br><span class=\"line\">                    minj=j;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minj!=-<span class=\"number\">1</span>)<span class=\"comment\">//找到并交换跳出两重循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> temp=nums[i];</span><br><span class=\"line\">                nums[i]=nums[minj];</span><br><span class=\"line\">                nums[minj]=temp;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> outerloop;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(nums,i+<span class=\"number\">1</span>,nums.length);<span class=\"comment\">//排序i后元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","cover":false,"excerpt":"","more":"<h1 id=\"31-下一个排列\"><a href=\"#31-下一个排列\" class=\"headerlink\" title=\"31. 下一个排列\"></a><a href=\"https://leetcode.cn/problems/next-permutation/\">31. 下一个排列</a></h1><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>\n</ul>\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n<ul>\n<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>\n<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>\n<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>\n<p>必须 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a></strong> 修改，只允许使用额外常数空间。</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,2,3]<br><strong>输出：</strong>[1,3,2]</p>\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [3,2,1]<br><strong>输出：</strong>[1,2,3]</p>\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong>nums &#x3D; [1,1,5]<br><strong>输出：</strong>[1,5,1]</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<h1 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h1><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列，所以我们要找到比当前排列的整数大，但是又要尽量最小的排列。因为前面的数越大字典序越大，所以我们要找尽量靠后的数i与i后面比i大的数但是又尽量最小的数j，i和j交换位置保证比原来大而且尽量小，还需将i后面的数进行升序排序使其更小。</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">nextPermutation</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">        outerloop:</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=nums.length-<span class=\"number\">2</span>;i&gt;=<span class=\"number\">0</span>;i--)<span class=\"comment\">//i从后往前找</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> min=<span class=\"number\">1000</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> minj=-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>;j&lt;nums.length;j++)<span class=\"comment\">//找到i后比i大的最小数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(nums[i]&lt;nums[j]&amp;&amp;nums[j]&lt;min)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                    min=nums[j];</span><br><span class=\"line\">                    minj=j;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(minj!=-<span class=\"number\">1</span>)<span class=\"comment\">//找到并交换跳出两重循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> temp=nums[i];</span><br><span class=\"line\">                nums[i]=nums[minj];</span><br><span class=\"line\">                nums[minj]=temp;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> outerloop;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(nums,i+<span class=\"number\">1</span>,nums.length);<span class=\"comment\">//排序i后元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"用线程池执行批量耗时任务的优点","date":"2024-11-21T03:08:35.000Z","_content":"\n使用线程池执行批量耗时任务的优点主要体现在以下几个方面：\n\n---\n\n### 1. **线程复用，节约资源**\n\n线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  \n\n- **优点**：  \n  - 减少系统资源的占用（如 CPU 和内存）。  \n  - 降低频繁创建线程带来的开销和延迟。  \n\n例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。\n\n---\n\n### 2. **控制并发数量，防止资源耗尽**\n\n线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  \n\n- **优点**：  \n  - 避免任务数过多导致的线程竞争和阻塞问题。  \n  - 提高系统的稳定性，防止线程爆炸。\n\n例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。\n\n---\n\n### 3. **简化任务管理**\n\n线程池提供了统一的接口用于提交和管理任务。  \n\n- **优点**：  \n  - 可以轻松管理任务的执行、取消、超时等操作。  \n  - 使用线程池调度任务时，无需手动管理线程的生命周期。\n\n例如：`ThreadPoolExecutor` 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。\n\n---\n\n### 4. **支持任务队列，实现任务分批处理**\n\n线程池内部使用任务队列存储待执行的任务。  \n\n- **优点**：  \n  - 可以实现任务的分批处理，适应大批量任务执行需求。  \n  - 支持灵活的队列类型（如 `LinkedBlockingQueue`, `ArrayBlockingQueue`）。\n\n例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。\n\n---\n\n### 5. **提供灵活的线程管理策略**\n\n线程池允许配置不同的线程数量和策略：  \n\n- **优点**：  \n  - 设置核心线程数、最大线程数，适应不同负载需求。  \n  - 支持定时任务、周期性任务等多种调度模式。\n\n例如：使用 `ScheduledThreadPoolExecutor` 可以定时调度任务，而 `CachedThreadPool` 适用于大量短期任务。\n\n---\n\n### 6. **提高任务处理效率**\n\n线程池允许多任务并发执行，充分利用 CPU 多核资源。  \n\n- **优点**：  \n  - 任务可以并行处理，缩短总的执行时间。  \n  - 对于 I/O 密集型任务，可以避免阻塞操作浪费 CPU 时间。\n\n例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。\n\n---\n\n### 7. **支持自定义线程工厂，增强可监控性**\n\n通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  \n\n- **优点**：  \n  - 线程的命名规则便于调试和定位问题。  \n  - 可定制线程池的行为（如异常处理、自定义日志记录等）。\n\n---\n\n### 8. **减少程序的复杂度**\n\n线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  \n\n- **优点**：  \n  - 简化代码，提高可维护性。  \n  - 避免手动管理线程带来的复杂性。\n\n例如：直接提交任务给线程池，而无需手动启动或管理线程。\n\n---\n\n### **总结**\n\n使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于**高效利用系统资源**和**便捷的任务管理**，是处理大规模并发任务的最佳实践之一。\n","source":"_posts/用线程池执行批量耗时任务的优点.md","raw":"---\ntitle: 用线程池执行批量耗时任务的优点\ndate: 2024-11-21 11:08:35\ntags: java基础\ncategories: 八股文\n---\n\n使用线程池执行批量耗时任务的优点主要体现在以下几个方面：\n\n---\n\n### 1. **线程复用，节约资源**\n\n线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  \n\n- **优点**：  \n  - 减少系统资源的占用（如 CPU 和内存）。  \n  - 降低频繁创建线程带来的开销和延迟。  \n\n例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。\n\n---\n\n### 2. **控制并发数量，防止资源耗尽**\n\n线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  \n\n- **优点**：  \n  - 避免任务数过多导致的线程竞争和阻塞问题。  \n  - 提高系统的稳定性，防止线程爆炸。\n\n例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。\n\n---\n\n### 3. **简化任务管理**\n\n线程池提供了统一的接口用于提交和管理任务。  \n\n- **优点**：  \n  - 可以轻松管理任务的执行、取消、超时等操作。  \n  - 使用线程池调度任务时，无需手动管理线程的生命周期。\n\n例如：`ThreadPoolExecutor` 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。\n\n---\n\n### 4. **支持任务队列，实现任务分批处理**\n\n线程池内部使用任务队列存储待执行的任务。  \n\n- **优点**：  \n  - 可以实现任务的分批处理，适应大批量任务执行需求。  \n  - 支持灵活的队列类型（如 `LinkedBlockingQueue`, `ArrayBlockingQueue`）。\n\n例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。\n\n---\n\n### 5. **提供灵活的线程管理策略**\n\n线程池允许配置不同的线程数量和策略：  \n\n- **优点**：  \n  - 设置核心线程数、最大线程数，适应不同负载需求。  \n  - 支持定时任务、周期性任务等多种调度模式。\n\n例如：使用 `ScheduledThreadPoolExecutor` 可以定时调度任务，而 `CachedThreadPool` 适用于大量短期任务。\n\n---\n\n### 6. **提高任务处理效率**\n\n线程池允许多任务并发执行，充分利用 CPU 多核资源。  \n\n- **优点**：  \n  - 任务可以并行处理，缩短总的执行时间。  \n  - 对于 I/O 密集型任务，可以避免阻塞操作浪费 CPU 时间。\n\n例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。\n\n---\n\n### 7. **支持自定义线程工厂，增强可监控性**\n\n通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  \n\n- **优点**：  \n  - 线程的命名规则便于调试和定位问题。  \n  - 可定制线程池的行为（如异常处理、自定义日志记录等）。\n\n---\n\n### 8. **减少程序的复杂度**\n\n线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  \n\n- **优点**：  \n  - 简化代码，提高可维护性。  \n  - 避免手动管理线程带来的复杂性。\n\n例如：直接提交任务给线程池，而无需手动启动或管理线程。\n\n---\n\n### **总结**\n\n使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于**高效利用系统资源**和**便捷的任务管理**，是处理大规模并发任务的最佳实践之一。\n","slug":"用线程池执行批量耗时任务的优点","published":1,"updated":"2024-12-14T09:16:59.572Z","comments":1,"layout":"post","photos":[],"_id":"cm4nysnae000n4oa80oxr40bs","content":"<p>使用线程池执行批量耗时任务的优点主要体现在以下几个方面：</p>\n<hr>\n<h3 id=\"1-线程复用，节约资源\"><a href=\"#1-线程复用，节约资源\" class=\"headerlink\" title=\"1. 线程复用，节约资源\"></a>1. <strong>线程复用，节约资源</strong></h3><p>线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>减少系统资源的占用（如 CPU 和内存）。  </li>\n<li>降低频繁创建线程带来的开销和延迟。</li>\n</ul>\n</li>\n</ul>\n<p>例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。</p>\n<hr>\n<h3 id=\"2-控制并发数量，防止资源耗尽\"><a href=\"#2-控制并发数量，防止资源耗尽\" class=\"headerlink\" title=\"2. 控制并发数量，防止资源耗尽\"></a>2. <strong>控制并发数量，防止资源耗尽</strong></h3><p>线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>避免任务数过多导致的线程竞争和阻塞问题。  </li>\n<li>提高系统的稳定性，防止线程爆炸。</li>\n</ul>\n</li>\n</ul>\n<p>例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。</p>\n<hr>\n<h3 id=\"3-简化任务管理\"><a href=\"#3-简化任务管理\" class=\"headerlink\" title=\"3. 简化任务管理\"></a>3. <strong>简化任务管理</strong></h3><p>线程池提供了统一的接口用于提交和管理任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以轻松管理任务的执行、取消、超时等操作。  </li>\n<li>使用线程池调度任务时，无需手动管理线程的生命周期。</li>\n</ul>\n</li>\n</ul>\n<p>例如：<code>ThreadPoolExecutor</code> 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。</p>\n<hr>\n<h3 id=\"4-支持任务队列，实现任务分批处理\"><a href=\"#4-支持任务队列，实现任务分批处理\" class=\"headerlink\" title=\"4. 支持任务队列，实现任务分批处理\"></a>4. <strong>支持任务队列，实现任务分批处理</strong></h3><p>线程池内部使用任务队列存储待执行的任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以实现任务的分批处理，适应大批量任务执行需求。  </li>\n<li>支持灵活的队列类型（如 <code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code>）。</li>\n</ul>\n</li>\n</ul>\n<p>例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。</p>\n<hr>\n<h3 id=\"5-提供灵活的线程管理策略\"><a href=\"#5-提供灵活的线程管理策略\" class=\"headerlink\" title=\"5. 提供灵活的线程管理策略\"></a>5. <strong>提供灵活的线程管理策略</strong></h3><p>线程池允许配置不同的线程数量和策略：  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>设置核心线程数、最大线程数，适应不同负载需求。  </li>\n<li>支持定时任务、周期性任务等多种调度模式。</li>\n</ul>\n</li>\n</ul>\n<p>例如：使用 <code>ScheduledThreadPoolExecutor</code> 可以定时调度任务，而 <code>CachedThreadPool</code> 适用于大量短期任务。</p>\n<hr>\n<h3 id=\"6-提高任务处理效率\"><a href=\"#6-提高任务处理效率\" class=\"headerlink\" title=\"6. 提高任务处理效率\"></a>6. <strong>提高任务处理效率</strong></h3><p>线程池允许多任务并发执行，充分利用 CPU 多核资源。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>任务可以并行处理，缩短总的执行时间。  </li>\n<li>对于 I&#x2F;O 密集型任务，可以避免阻塞操作浪费 CPU 时间。</li>\n</ul>\n</li>\n</ul>\n<p>例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。</p>\n<hr>\n<h3 id=\"7-支持自定义线程工厂，增强可监控性\"><a href=\"#7-支持自定义线程工厂，增强可监控性\" class=\"headerlink\" title=\"7. 支持自定义线程工厂，增强可监控性\"></a>7. <strong>支持自定义线程工厂，增强可监控性</strong></h3><p>通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>线程的命名规则便于调试和定位问题。  </li>\n<li>可定制线程池的行为（如异常处理、自定义日志记录等）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"8-减少程序的复杂度\"><a href=\"#8-减少程序的复杂度\" class=\"headerlink\" title=\"8. 减少程序的复杂度\"></a>8. <strong>减少程序的复杂度</strong></h3><p>线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>简化代码，提高可维护性。  </li>\n<li>避免手动管理线程带来的复杂性。</li>\n</ul>\n</li>\n</ul>\n<p>例如：直接提交任务给线程池，而无需手动启动或管理线程。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于<strong>高效利用系统资源</strong>和<strong>便捷的任务管理</strong>，是处理大规模并发任务的最佳实践之一。</p>\n","cover":false,"excerpt":"","more":"<p>使用线程池执行批量耗时任务的优点主要体现在以下几个方面：</p>\n<hr>\n<h3 id=\"1-线程复用，节约资源\"><a href=\"#1-线程复用，节约资源\" class=\"headerlink\" title=\"1. 线程复用，节约资源\"></a>1. <strong>线程复用，节约资源</strong></h3><p>线程池通过复用线程资源避免了频繁创建和销毁线程的开销。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>减少系统资源的占用（如 CPU 和内存）。  </li>\n<li>降低频繁创建线程带来的开销和延迟。</li>\n</ul>\n</li>\n</ul>\n<p>例如：如果每个耗时任务都单独创建线程，会浪费大量系统资源，而线程池则能通过复用线程高效执行任务。</p>\n<hr>\n<h3 id=\"2-控制并发数量，防止资源耗尽\"><a href=\"#2-控制并发数量，防止资源耗尽\" class=\"headerlink\" title=\"2. 控制并发数量，防止资源耗尽\"></a>2. <strong>控制并发数量，防止资源耗尽</strong></h3><p>线程池允许设置最大线程数，可以限制并发任务的数量，避免系统因线程过多而资源耗尽。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>避免任务数过多导致的线程竞争和阻塞问题。  </li>\n<li>提高系统的稳定性，防止线程爆炸。</li>\n</ul>\n</li>\n</ul>\n<p>例如：处理 100 个批量任务时，线程池可以限制并发数为 10，确保系统不会因并发任务过多而崩溃。</p>\n<hr>\n<h3 id=\"3-简化任务管理\"><a href=\"#3-简化任务管理\" class=\"headerlink\" title=\"3. 简化任务管理\"></a>3. <strong>简化任务管理</strong></h3><p>线程池提供了统一的接口用于提交和管理任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以轻松管理任务的执行、取消、超时等操作。  </li>\n<li>使用线程池调度任务时，无需手动管理线程的生命周期。</li>\n</ul>\n</li>\n</ul>\n<p>例如：<code>ThreadPoolExecutor</code> 提供了方便的方法处理任务队列，简化了复杂的任务调度逻辑。</p>\n<hr>\n<h3 id=\"4-支持任务队列，实现任务分批处理\"><a href=\"#4-支持任务队列，实现任务分批处理\" class=\"headerlink\" title=\"4. 支持任务队列，实现任务分批处理\"></a>4. <strong>支持任务队列，实现任务分批处理</strong></h3><p>线程池内部使用任务队列存储待执行的任务。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>可以实现任务的分批处理，适应大批量任务执行需求。  </li>\n<li>支持灵活的队列类型（如 <code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code>）。</li>\n</ul>\n</li>\n</ul>\n<p>例如：当新任务到来但线程已满时，可以暂时将任务存放在队列中，等待空闲线程执行。</p>\n<hr>\n<h3 id=\"5-提供灵活的线程管理策略\"><a href=\"#5-提供灵活的线程管理策略\" class=\"headerlink\" title=\"5. 提供灵活的线程管理策略\"></a>5. <strong>提供灵活的线程管理策略</strong></h3><p>线程池允许配置不同的线程数量和策略：  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>设置核心线程数、最大线程数，适应不同负载需求。  </li>\n<li>支持定时任务、周期性任务等多种调度模式。</li>\n</ul>\n</li>\n</ul>\n<p>例如：使用 <code>ScheduledThreadPoolExecutor</code> 可以定时调度任务，而 <code>CachedThreadPool</code> 适用于大量短期任务。</p>\n<hr>\n<h3 id=\"6-提高任务处理效率\"><a href=\"#6-提高任务处理效率\" class=\"headerlink\" title=\"6. 提高任务处理效率\"></a>6. <strong>提高任务处理效率</strong></h3><p>线程池允许多任务并发执行，充分利用 CPU 多核资源。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>任务可以并行处理，缩短总的执行时间。  </li>\n<li>对于 I&#x2F;O 密集型任务，可以避免阻塞操作浪费 CPU 时间。</li>\n</ul>\n</li>\n</ul>\n<p>例如：在多核 CPU 上，多个耗时任务并发执行，可以大幅减少处理时间。</p>\n<hr>\n<h3 id=\"7-支持自定义线程工厂，增强可监控性\"><a href=\"#7-支持自定义线程工厂，增强可监控性\" class=\"headerlink\" title=\"7. 支持自定义线程工厂，增强可监控性\"></a>7. <strong>支持自定义线程工厂，增强可监控性</strong></h3><p>通过自定义线程工厂，可以为线程设置统一的命名规则，方便监控和排查问题。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>线程的命名规则便于调试和定位问题。  </li>\n<li>可定制线程池的行为（如异常处理、自定义日志记录等）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"8-减少程序的复杂度\"><a href=\"#8-减少程序的复杂度\" class=\"headerlink\" title=\"8. 减少程序的复杂度\"></a>8. <strong>减少程序的复杂度</strong></h3><p>线程池封装了线程的创建和调度逻辑，使开发者只需关注任务本身的逻辑。  </p>\n<ul>\n<li><strong>优点</strong>：  <ul>\n<li>简化代码，提高可维护性。  </li>\n<li>避免手动管理线程带来的复杂性。</li>\n</ul>\n</li>\n</ul>\n<p>例如：直接提交任务给线程池，而无需手动启动或管理线程。</p>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>使用线程池执行批量耗时任务，可以大幅提升程序的性能、稳定性和开发效率。线程池的核心优势在于<strong>高效利用系统资源</strong>和<strong>便捷的任务管理</strong>，是处理大规模并发任务的最佳实践之一。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm4nysna700054oa8f0f999hw","category_id":"cm4nysna400024oa87uqc6pud","_id":"cm4nysnab000c4oa8gvnn13y4"},{"post_id":"cm4nysn9z00004oa82huzbuql","category_id":"cm4nysna400024oa87uqc6pud","_id":"cm4nysnac000h4oa8c252850r"},{"post_id":"cm4nysna300014oa805tdbq1a","category_id":"cm4nysna400024oa87uqc6pud","_id":"cm4nysnae000l4oa8e3qv5jjz"},{"post_id":"cm4nysnab000b4oa8e0g54wtf","category_id":"cm4nysna400024oa87uqc6pud","_id":"cm4nysnaf000o4oa81my01zeq"},{"post_id":"cm4nysna600044oa8ensf4jqv","category_id":"cm4nysna400024oa87uqc6pud","_id":"cm4nysnaf000q4oa87blv4upe"},{"post_id":"cm4nysnae000n4oa80oxr40bs","category_id":"cm4nysna400024oa87uqc6pud","_id":"cm4nysnag000v4oa8d7z1br9l"},{"post_id":"cm4nysnaa000a4oa8fc7b30e0","category_id":"cm4nysnae000k4oa88qzp2ssk","_id":"cm4nysnag000y4oa8dmc39i81"},{"post_id":"cm4nysnac000g4oa8b53aeq4v","category_id":"cm4nysnaf000r4oa87pez3win","_id":"cm4nysnah00104oa8fj8934y8"},{"post_id":"cm4nysnad000j4oa8792phuxm","category_id":"cm4nysnag000w4oa85wby3hh8","_id":"cm4nysnah00134oa80fbb5xpm"}],"PostTag":[{"post_id":"cm4nysn9z00004oa82huzbuql","tag_id":"cm4nysna500034oa8brrq0gcr","_id":"cm4nysnaa00094oa8bn0f5uvu"},{"post_id":"cm4nysna300014oa805tdbq1a","tag_id":"cm4nysna500034oa8brrq0gcr","_id":"cm4nysnac000f4oa8dqq96gk3"},{"post_id":"cm4nysnab000b4oa8e0g54wtf","tag_id":"cm4nysna500034oa8brrq0gcr","_id":"cm4nysnad000i4oa8bdyh74re"},{"post_id":"cm4nysna600044oa8ensf4jqv","tag_id":"cm4nysnac000e4oa8ch02fcso","_id":"cm4nysnaf000p4oa847yp27ih"},{"post_id":"cm4nysnae000n4oa80oxr40bs","tag_id":"cm4nysna500034oa8brrq0gcr","_id":"cm4nysnag000t4oa8bopv6s1t"},{"post_id":"cm4nysna700054oa8f0f999hw","tag_id":"cm4nysnae000m4oa8gb7s5nzj","_id":"cm4nysnag000u4oa82vhnhk37"},{"post_id":"cm4nysna800064oa88v1g3wx5","tag_id":"cm4nysnac000e4oa8ch02fcso","_id":"cm4nysnah000z4oa8doabduz6"},{"post_id":"cm4nysnaa000a4oa8fc7b30e0","tag_id":"cm4nysnag000x4oa83omtgs1b","_id":"cm4nysnah00124oa86jbn81d2"},{"post_id":"cm4nysnac000g4oa8b53aeq4v","tag_id":"cm4nysnah00114oa8a6ic4vlz","_id":"cm4nysnah00154oa84v7m1st0"},{"post_id":"cm4nysnad000j4oa8792phuxm","tag_id":"cm4nysnah00144oa81uzq4v1m","_id":"cm4nysnai00164oa8hp38cceh"}],"Tag":[{"name":"java基础","_id":"cm4nysna500034oa8brrq0gcr"},{"name":"mysql","_id":"cm4nysnac000e4oa8ch02fcso"},{"name":"redis","_id":"cm4nysnae000m4oa8gb7s5nzj"},{"name":"实习","_id":"cm4nysnag000x4oa83omtgs1b"},{"name":"设计模式","_id":"cm4nysnah00114oa8a6ic4vlz"},{"name":"leetcode","_id":"cm4nysnah00144oa81uzq4v1m"}]}}